/* tslint:disable */
/* eslint-disable */
/**
 * QLab OSC Rest Proxy
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AlwaysReplyRequest,
    AlwaysReplyRequestFromJSON,
    AlwaysReplyRequestToJSON,
    AlwaysReplyResponse,
    AlwaysReplyResponseFromJSON,
    AlwaysReplyResponseToJSON,
    AuditionWindowRequest,
    AuditionWindowRequestFromJSON,
    AuditionWindowRequestToJSON,
    AuditionWindowResponse,
    AuditionWindowResponseFromJSON,
    AuditionWindowResponseToJSON,
    CueCueNumberActionElapsedResponse,
    CueCueNumberActionElapsedResponseFromJSON,
    CueCueNumberActionElapsedResponseToJSON,
    CueCueNumberAddSliceMarkerRequest,
    CueCueNumberAddSliceMarkerRequestFromJSON,
    CueCueNumberAddSliceMarkerRequestToJSON,
    CueCueNumberAddSliceMarkerResponse,
    CueCueNumberAddSliceMarkerResponseFromJSON,
    CueCueNumberAddSliceMarkerResponseToJSON,
    CueCueNumberAllowsEditingDurationResponse,
    CueCueNumberAllowsEditingDurationResponseFromJSON,
    CueCueNumberAllowsEditingDurationResponseToJSON,
    CueCueNumberAlwaysCollateRequest,
    CueCueNumberAlwaysCollateRequestFromJSON,
    CueCueNumberAlwaysCollateRequestToJSON,
    CueCueNumberAlwaysCollateResponse,
    CueCueNumberAlwaysCollateResponseFromJSON,
    CueCueNumberAlwaysCollateResponseToJSON,
    CueCueNumberArmedRequest,
    CueCueNumberArmedRequestFromJSON,
    CueCueNumberArmedRequestToJSON,
    CueCueNumberArmedResponse,
    CueCueNumberArmedResponseFromJSON,
    CueCueNumberArmedResponseToJSON,
    CueCueNumberAutoLoadRequest,
    CueCueNumberAutoLoadRequestFromJSON,
    CueCueNumberAutoLoadRequestToJSON,
    CueCueNumberAutoLoadResponse,
    CueCueNumberAutoLoadResponseFromJSON,
    CueCueNumberAutoLoadResponseToJSON,
    CueCueNumberByte1Request,
    CueCueNumberByte1RequestFromJSON,
    CueCueNumberByte1RequestToJSON,
    CueCueNumberByte1Response,
    CueCueNumberByte1ResponseFromJSON,
    CueCueNumberByte1ResponseToJSON,
    CueCueNumberByte2Request,
    CueCueNumberByte2RequestFromJSON,
    CueCueNumberByte2RequestToJSON,
    CueCueNumberByte2Response,
    CueCueNumberByte2ResponseFromJSON,
    CueCueNumberByte2ResponseToJSON,
    CueCueNumberByteComboRequest,
    CueCueNumberByteComboRequestFromJSON,
    CueCueNumberByteComboRequestToJSON,
    CueCueNumberByteComboResponse,
    CueCueNumberByteComboResponseFromJSON,
    CueCueNumberByteComboResponseToJSON,
    CueCueNumberCameraPatchResponse,
    CueCueNumberCameraPatchResponseFromJSON,
    CueCueNumberCameraPatchResponseToJSON,
    CueCueNumberCartColumnsResponse,
    CueCueNumberCartColumnsResponseFromJSON,
    CueCueNumberCartColumnsResponseToJSON,
    CueCueNumberCartPositionResponse,
    CueCueNumberCartPositionResponseFromJSON,
    CueCueNumberCartPositionResponseToJSON,
    CueCueNumberCartRowsResponse,
    CueCueNumberCartRowsResponseFromJSON,
    CueCueNumberCartRowsResponseToJSON,
    CueCueNumberChannelOffsetResponse,
    CueCueNumberChannelOffsetResponseFromJSON,
    CueCueNumberChannelOffsetResponseToJSON,
    CueCueNumberChannelRequest,
    CueCueNumberChannelRequestFromJSON,
    CueCueNumberChannelRequestToJSON,
    CueCueNumberChannelResponse,
    CueCueNumberChannelResponseFromJSON,
    CueCueNumberChannelResponseToJSON,
    CueCueNumberChannelsRequest,
    CueCueNumberChannelsRequestFromJSON,
    CueCueNumberChannelsRequestToJSON,
    CueCueNumberChannelsResponse,
    CueCueNumberChannelsResponseFromJSON,
    CueCueNumberChannelsResponseToJSON,
    CueCueNumberChildrenResponse,
    CueCueNumberChildrenResponseFromJSON,
    CueCueNumberChildrenResponseToJSON,
    CueCueNumberCollateAndStartResponse,
    CueCueNumberCollateAndStartResponseFromJSON,
    CueCueNumberCollateAndStartResponseToJSON,
    CueCueNumberColorNameRequest,
    CueCueNumberColorNameRequestFromJSON,
    CueCueNumberColorNameRequestToJSON,
    CueCueNumberColorNameResponse,
    CueCueNumberColorNameResponseFromJSON,
    CueCueNumberColorNameResponseToJSON,
    CueCueNumberCommandFormatRequest,
    CueCueNumberCommandFormatRequestFromJSON,
    CueCueNumberCommandFormatRequestToJSON,
    CueCueNumberCommandFormatResponse,
    CueCueNumberCommandFormatResponseFromJSON,
    CueCueNumberCommandFormatResponseToJSON,
    CueCueNumberCommandRequest,
    CueCueNumberCommandRequestFromJSON,
    CueCueNumberCommandRequestToJSON,
    CueCueNumberCommandResponse,
    CueCueNumberCommandResponseFromJSON,
    CueCueNumberCommandResponseToJSON,
    CueCueNumberCompileSourceResponse,
    CueCueNumberCompileSourceResponseFromJSON,
    CueCueNumberCompileSourceResponseToJSON,
    CueCueNumberContinueModeRequest,
    CueCueNumberContinueModeRequestFromJSON,
    CueCueNumberContinueModeRequestToJSON,
    CueCueNumberContinueModeResponse,
    CueCueNumberContinueModeResponseFromJSON,
    CueCueNumberContinueModeResponseToJSON,
    CueCueNumberControlNumberRequest,
    CueCueNumberControlNumberRequestFromJSON,
    CueCueNumberControlNumberRequestToJSON,
    CueCueNumberControlNumberResponse,
    CueCueNumberControlNumberResponseFromJSON,
    CueCueNumberControlNumberResponseToJSON,
    CueCueNumberControlValueRequest,
    CueCueNumberControlValueRequestFromJSON,
    CueCueNumberControlValueRequestToJSON,
    CueCueNumberControlValueResponse,
    CueCueNumberControlValueResponseFromJSON,
    CueCueNumberControlValueResponseToJSON,
    CueCueNumberCueSizeResponse,
    CueCueNumberCueSizeResponseFromJSON,
    CueCueNumberCueSizeResponseToJSON,
    CueCueNumberCueTargetIdRequest,
    CueCueNumberCueTargetIdRequestFromJSON,
    CueCueNumberCueTargetIdRequestToJSON,
    CueCueNumberCueTargetIdResponse,
    CueCueNumberCueTargetIdResponseFromJSON,
    CueCueNumberCueTargetIdResponseToJSON,
    CueCueNumberCueTargetNumberRequest,
    CueCueNumberCueTargetNumberRequestFromJSON,
    CueCueNumberCueTargetNumberRequestToJSON,
    CueCueNumberCueTargetNumberResponse,
    CueCueNumberCueTargetNumberResponseFromJSON,
    CueCueNumberCueTargetNumberResponseToJSON,
    CueCueNumberCurrentCueTargetResponse,
    CueCueNumberCurrentCueTargetResponseFromJSON,
    CueCueNumberCurrentCueTargetResponseToJSON,
    CueCueNumberCurrentDurationResponse,
    CueCueNumberCurrentDurationResponseFromJSON,
    CueCueNumberCurrentDurationResponseToJSON,
    CueCueNumberCurrentFileTimeResponse,
    CueCueNumberCurrentFileTimeResponseFromJSON,
    CueCueNumberCurrentFileTimeResponseToJSON,
    CueCueNumberCustomStringRequest,
    CueCueNumberCustomStringRequestFromJSON,
    CueCueNumberCustomStringRequestToJSON,
    CueCueNumberCustomStringResponse,
    CueCueNumberCustomStringResponseFromJSON,
    CueCueNumberCustomStringResponseToJSON,
    CueCueNumberDefaultNameResponse,
    CueCueNumberDefaultNameResponseFromJSON,
    CueCueNumberDefaultNameResponseToJSON,
    CueCueNumberDeleteSliceMarkerIndexResponse,
    CueCueNumberDeleteSliceMarkerIndexResponseFromJSON,
    CueCueNumberDeleteSliceMarkerIndexResponseToJSON,
    CueCueNumberDeleteSliceMarkerRequest,
    CueCueNumberDeleteSliceMarkerRequestFromJSON,
    CueCueNumberDeleteSliceMarkerRequestToJSON,
    CueCueNumberDeleteSliceMarkerResponse,
    CueCueNumberDeleteSliceMarkerResponseFromJSON,
    CueCueNumberDeleteSliceMarkerResponseToJSON,
    CueCueNumberDeleteSliceMarkersResponse,
    CueCueNumberDeleteSliceMarkersResponseFromJSON,
    CueCueNumberDeleteSliceMarkersResponseToJSON,
    CueCueNumberDeviceIDRequest,
    CueCueNumberDeviceIDRequestFromJSON,
    CueCueNumberDeviceIDRequestToJSON,
    CueCueNumberDeviceIDResponse,
    CueCueNumberDeviceIDResponseFromJSON,
    CueCueNumberDeviceIDResponseToJSON,
    CueCueNumberDisplayNameResponse,
    CueCueNumberDisplayNameResponseFromJSON,
    CueCueNumberDisplayNameResponseToJSON,
    CueCueNumberDoEffectRequest,
    CueCueNumberDoEffectRequestFromJSON,
    CueCueNumberDoEffectRequestToJSON,
    CueCueNumberDoEffectResponse,
    CueCueNumberDoEffectResponseFromJSON,
    CueCueNumberDoEffectResponseToJSON,
    CueCueNumberDoFadeRequest,
    CueCueNumberDoFadeRequestFromJSON,
    CueCueNumberDoFadeRequestToJSON,
    CueCueNumberDoFadeResponse,
    CueCueNumberDoFadeResponseFromJSON,
    CueCueNumberDoFadeResponseToJSON,
    CueCueNumberDoOpacityRequest,
    CueCueNumberDoOpacityRequestFromJSON,
    CueCueNumberDoOpacityRequestToJSON,
    CueCueNumberDoOpacityResponse,
    CueCueNumberDoOpacityResponseFromJSON,
    CueCueNumberDoOpacityResponseToJSON,
    CueCueNumberDoPitchShiftRequest,
    CueCueNumberDoPitchShiftRequestFromJSON,
    CueCueNumberDoPitchShiftRequestToJSON,
    CueCueNumberDoPitchShiftResponse,
    CueCueNumberDoPitchShiftResponseFromJSON,
    CueCueNumberDoPitchShiftResponseToJSON,
    CueCueNumberDoRateRequest,
    CueCueNumberDoRateRequestFromJSON,
    CueCueNumberDoRateRequestToJSON,
    CueCueNumberDoRateResponse,
    CueCueNumberDoRateResponseFromJSON,
    CueCueNumberDoRateResponseToJSON,
    CueCueNumberDoRotationRequest,
    CueCueNumberDoRotationRequestFromJSON,
    CueCueNumberDoRotationRequestToJSON,
    CueCueNumberDoRotationResponse,
    CueCueNumberDoRotationResponseFromJSON,
    CueCueNumberDoRotationResponseToJSON,
    CueCueNumberDoScaleRequest,
    CueCueNumberDoScaleRequestFromJSON,
    CueCueNumberDoScaleRequestToJSON,
    CueCueNumberDoScaleResponse,
    CueCueNumberDoScaleResponseFromJSON,
    CueCueNumberDoScaleResponseToJSON,
    CueCueNumberDoTranslationRequest,
    CueCueNumberDoTranslationRequestFromJSON,
    CueCueNumberDoTranslationRequestToJSON,
    CueCueNumberDoTranslationResponse,
    CueCueNumberDoTranslationResponseFromJSON,
    CueCueNumberDoTranslationResponseToJSON,
    CueCueNumberDuckLevelRequest,
    CueCueNumberDuckLevelRequestFromJSON,
    CueCueNumberDuckLevelRequestToJSON,
    CueCueNumberDuckLevelResponse,
    CueCueNumberDuckLevelResponseFromJSON,
    CueCueNumberDuckLevelResponseToJSON,
    CueCueNumberDuckOthersRequest,
    CueCueNumberDuckOthersRequestFromJSON,
    CueCueNumberDuckOthersRequestToJSON,
    CueCueNumberDuckOthersResponse,
    CueCueNumberDuckOthersResponseFromJSON,
    CueCueNumberDuckOthersResponseToJSON,
    CueCueNumberDuckTimeRequest,
    CueCueNumberDuckTimeRequestFromJSON,
    CueCueNumberDuckTimeRequestToJSON,
    CueCueNumberDuckTimeResponse,
    CueCueNumberDuckTimeResponseFromJSON,
    CueCueNumberDuckTimeResponseToJSON,
    CueCueNumberDurationRequest,
    CueCueNumberDurationRequestFromJSON,
    CueCueNumberDurationRequestToJSON,
    CueCueNumberDurationResponse,
    CueCueNumberDurationResponseFromJSON,
    CueCueNumberDurationResponseToJSON,
    CueCueNumberEffectIndexRequest,
    CueCueNumberEffectIndexRequestFromJSON,
    CueCueNumberEffectIndexRequestToJSON,
    CueCueNumberEffectIndexResponse,
    CueCueNumberEffectIndexResponseFromJSON,
    CueCueNumberEffectIndexResponseToJSON,
    CueCueNumberEffectSetRequest,
    CueCueNumberEffectSetRequestFromJSON,
    CueCueNumberEffectSetRequestToJSON,
    CueCueNumberEffectSetResponse,
    CueCueNumberEffectSetResponseFromJSON,
    CueCueNumberEffectSetResponseToJSON,
    CueCueNumberEndTimeRequest,
    CueCueNumberEndTimeRequestFromJSON,
    CueCueNumberEndTimeRequestToJSON,
    CueCueNumberEndTimeResponse,
    CueCueNumberEndTimeResponseFromJSON,
    CueCueNumberEndTimeResponseToJSON,
    CueCueNumberEndValueRequest,
    CueCueNumberEndValueRequestFromJSON,
    CueCueNumberEndValueRequestToJSON,
    CueCueNumberEndValueResponse,
    CueCueNumberEndValueResponseFromJSON,
    CueCueNumberEndValueResponseToJSON,
    CueCueNumberFadeAndStopOthersRequest,
    CueCueNumberFadeAndStopOthersRequestFromJSON,
    CueCueNumberFadeAndStopOthersRequestToJSON,
    CueCueNumberFadeAndStopOthersResponse,
    CueCueNumberFadeAndStopOthersResponseFromJSON,
    CueCueNumberFadeAndStopOthersResponseToJSON,
    CueCueNumberFadeAndStopOthersTimeRequest,
    CueCueNumberFadeAndStopOthersTimeRequestFromJSON,
    CueCueNumberFadeAndStopOthersTimeRequestToJSON,
    CueCueNumberFadeAndStopOthersTimeResponse,
    CueCueNumberFadeAndStopOthersTimeResponseFromJSON,
    CueCueNumberFadeAndStopOthersTimeResponseToJSON,
    CueCueNumberFileTargetRequest,
    CueCueNumberFileTargetRequestFromJSON,
    CueCueNumberFileTargetRequestToJSON,
    CueCueNumberFileTargetResponse,
    CueCueNumberFileTargetResponseFromJSON,
    CueCueNumberFileTargetResponseToJSON,
    CueCueNumberFixedWidthRequest,
    CueCueNumberFixedWidthRequestFromJSON,
    CueCueNumberFixedWidthRequestToJSON,
    CueCueNumberFixedWidthResponse,
    CueCueNumberFixedWidthResponseFromJSON,
    CueCueNumberFixedWidthResponseToJSON,
    CueCueNumberFlaggedRequest,
    CueCueNumberFlaggedRequestFromJSON,
    CueCueNumberFlaggedRequestToJSON,
    CueCueNumberFlaggedResponse,
    CueCueNumberFlaggedResponseFromJSON,
    CueCueNumberFlaggedResponseToJSON,
    CueCueNumberFramesRequest,
    CueCueNumberFramesRequestFromJSON,
    CueCueNumberFramesRequestToJSON,
    CueCueNumberFramesResponse,
    CueCueNumberFramesResponseFromJSON,
    CueCueNumberFramesResponseToJSON,
    CueCueNumberFullScreenRequest,
    CueCueNumberFullScreenRequestFromJSON,
    CueCueNumberFullScreenRequestToJSON,
    CueCueNumberFullScreenResponse,
    CueCueNumberFullScreenResponseFromJSON,
    CueCueNumberFullScreenResponseToJSON,
    CueCueNumberFullSurfaceRequest,
    CueCueNumberFullSurfaceRequestFromJSON,
    CueCueNumberFullSurfaceRequestToJSON,
    CueCueNumberFullSurfaceResponse,
    CueCueNumberFullSurfaceResponseFromJSON,
    CueCueNumberFullSurfaceResponseToJSON,
    CueCueNumberGangInChannelOutChannelRequest,
    CueCueNumberGangInChannelOutChannelRequestFromJSON,
    CueCueNumberGangInChannelOutChannelRequestToJSON,
    CueCueNumberGangInChannelOutChannelResponse,
    CueCueNumberGangInChannelOutChannelResponseFromJSON,
    CueCueNumberGangInChannelOutChannelResponseToJSON,
    CueCueNumberGangRequest,
    CueCueNumberGangRequestFromJSON,
    CueCueNumberGangRequestToJSON,
    CueCueNumberGangResponse,
    CueCueNumberGangResponseFromJSON,
    CueCueNumberGangResponseToJSON,
    CueCueNumberGeoModeRequest,
    CueCueNumberGeoModeRequestFromJSON,
    CueCueNumberGeoModeRequestToJSON,
    CueCueNumberGeoModeResponse,
    CueCueNumberGeoModeResponseFromJSON,
    CueCueNumberGeoModeResponseToJSON,
    CueCueNumberGoResponse,
    CueCueNumberGoResponseFromJSON,
    CueCueNumberGoResponseToJSON,
    CueCueNumberHardPauseResponse,
    CueCueNumberHardPauseResponseFromJSON,
    CueCueNumberHardPauseResponseToJSON,
    CueCueNumberHardStopResponse,
    CueCueNumberHardStopResponseFromJSON,
    CueCueNumberHardStopResponseToJSON,
    CueCueNumberHasCueTargetsResponse,
    CueCueNumberHasCueTargetsResponseFromJSON,
    CueCueNumberHasCueTargetsResponseToJSON,
    CueCueNumberHasFileTargetsResponse,
    CueCueNumberHasFileTargetsResponseFromJSON,
    CueCueNumberHasFileTargetsResponseToJSON,
    CueCueNumberHoldLastFrameRequest,
    CueCueNumberHoldLastFrameRequestFromJSON,
    CueCueNumberHoldLastFrameRequestToJSON,
    CueCueNumberHoldLastFrameResponse,
    CueCueNumberHoldLastFrameResponseFromJSON,
    CueCueNumberHoldLastFrameResponseToJSON,
    CueCueNumberHoursRequest,
    CueCueNumberHoursRequestFromJSON,
    CueCueNumberHoursRequestToJSON,
    CueCueNumberHoursResponse,
    CueCueNumberHoursResponseFromJSON,
    CueCueNumberHoursResponseToJSON,
    CueCueNumberInfiniteLoopRequest,
    CueCueNumberInfiniteLoopRequestFromJSON,
    CueCueNumberInfiniteLoopRequestToJSON,
    CueCueNumberInfiniteLoopResponse,
    CueCueNumberInfiniteLoopResponseFromJSON,
    CueCueNumberInfiniteLoopResponseToJSON,
    CueCueNumberIsActionRunningResponse,
    CueCueNumberIsActionRunningResponseFromJSON,
    CueCueNumberIsActionRunningResponseToJSON,
    CueCueNumberIsBrokenResponse,
    CueCueNumberIsBrokenResponseFromJSON,
    CueCueNumberIsBrokenResponseToJSON,
    CueCueNumberIsLoadedResponse,
    CueCueNumberIsLoadedResponseFromJSON,
    CueCueNumberIsLoadedResponseToJSON,
    CueCueNumberIsOverriddenResponse,
    CueCueNumberIsOverriddenResponseFromJSON,
    CueCueNumberIsOverriddenResponseToJSON,
    CueCueNumberIsPanickingResponse,
    CueCueNumberIsPanickingResponseFromJSON,
    CueCueNumberIsPanickingResponseToJSON,
    CueCueNumberIsPausedResponse,
    CueCueNumberIsPausedResponseFromJSON,
    CueCueNumberIsPausedResponseToJSON,
    CueCueNumberIsRunningResponse,
    CueCueNumberIsRunningResponseFromJSON,
    CueCueNumberIsRunningResponseToJSON,
    CueCueNumberIsTailingOutResponse,
    CueCueNumberIsTailingOutResponseFromJSON,
    CueCueNumberIsTailingOutResponseToJSON,
    CueCueNumberLastSliceInfiniteLoopRequest,
    CueCueNumberLastSliceInfiniteLoopRequestFromJSON,
    CueCueNumberLastSliceInfiniteLoopRequestToJSON,
    CueCueNumberLastSliceInfiniteLoopResponse,
    CueCueNumberLastSliceInfiniteLoopResponseFromJSON,
    CueCueNumberLastSliceInfiniteLoopResponseToJSON,
    CueCueNumberLastSlicePlayCountRequest,
    CueCueNumberLastSlicePlayCountRequestFromJSON,
    CueCueNumberLastSlicePlayCountRequestToJSON,
    CueCueNumberLastSlicePlayCountResponse,
    CueCueNumberLastSlicePlayCountResponseFromJSON,
    CueCueNumberLastSlicePlayCountResponseToJSON,
    CueCueNumberLayerRequest,
    CueCueNumberLayerRequestFromJSON,
    CueCueNumberLayerRequestToJSON,
    CueCueNumberLayerResponse,
    CueCueNumberLayerResponseFromJSON,
    CueCueNumberLayerResponseToJSON,
    CueCueNumberLevelInChannelOutChannelRequest,
    CueCueNumberLevelInChannelOutChannelRequestFromJSON,
    CueCueNumberLevelInChannelOutChannelRequestToJSON,
    CueCueNumberLevelInChannelOutChannelResponse,
    CueCueNumberLevelInChannelOutChannelResponseFromJSON,
    CueCueNumberLevelInChannelOutChannelResponseToJSON,
    CueCueNumberLevelRequest,
    CueCueNumberLevelRequestFromJSON,
    CueCueNumberLevelRequestToJSON,
    CueCueNumberLevelResponse,
    CueCueNumberLevelResponseFromJSON,
    CueCueNumberLevelResponseToJSON,
    CueCueNumberLevelsResponse,
    CueCueNumberLevelsResponseFromJSON,
    CueCueNumberLevelsResponseToJSON,
    CueCueNumberLightCommandTextRequest,
    CueCueNumberLightCommandTextRequestFromJSON,
    CueCueNumberLightCommandTextRequestToJSON,
    CueCueNumberLightCommandTextResponse,
    CueCueNumberLightCommandTextResponseFromJSON,
    CueCueNumberLightCommandTextResponseToJSON,
    CueCueNumberListNameResponse,
    CueCueNumberListNameResponseFromJSON,
    CueCueNumberListNameResponseToJSON,
    CueCueNumberLiveAverageLevelOutputChannelRequest,
    CueCueNumberLiveAverageLevelOutputChannelRequestFromJSON,
    CueCueNumberLiveAverageLevelOutputChannelRequestToJSON,
    CueCueNumberLiveAverageLevelOutputChannelResponse,
    CueCueNumberLiveAverageLevelOutputChannelResponseFromJSON,
    CueCueNumberLiveAverageLevelOutputChannelResponseToJSON,
    CueCueNumberLiveEffectSetRequest,
    CueCueNumberLiveEffectSetRequestFromJSON,
    CueCueNumberLiveEffectSetRequestToJSON,
    CueCueNumberLiveEffectSetResponse,
    CueCueNumberLiveEffectSetResponseFromJSON,
    CueCueNumberLiveEffectSetResponseToJSON,
    CueCueNumberLiveRateRequest,
    CueCueNumberLiveRateRequestFromJSON,
    CueCueNumberLiveRateRequestToJSON,
    CueCueNumberLiveRateResponse,
    CueCueNumberLiveRateResponseFromJSON,
    CueCueNumberLiveRateResponseToJSON,
    CueCueNumberLiveRotationXRequest,
    CueCueNumberLiveRotationXRequestFromJSON,
    CueCueNumberLiveRotationXRequestToJSON,
    CueCueNumberLiveRotationXResponse,
    CueCueNumberLiveRotationXResponseFromJSON,
    CueCueNumberLiveRotationXResponseToJSON,
    CueCueNumberLiveRotationXaxisRequest,
    CueCueNumberLiveRotationXaxisRequestFromJSON,
    CueCueNumberLiveRotationXaxisRequestToJSON,
    CueCueNumberLiveRotationXaxisResponse,
    CueCueNumberLiveRotationXaxisResponseFromJSON,
    CueCueNumberLiveRotationXaxisResponseToJSON,
    CueCueNumberLiveRotationYRequest,
    CueCueNumberLiveRotationYRequestFromJSON,
    CueCueNumberLiveRotationYRequestToJSON,
    CueCueNumberLiveRotationYResponse,
    CueCueNumberLiveRotationYResponseFromJSON,
    CueCueNumberLiveRotationYResponseToJSON,
    CueCueNumberLiveRotationYaxisRequest,
    CueCueNumberLiveRotationYaxisRequestFromJSON,
    CueCueNumberLiveRotationYaxisRequestToJSON,
    CueCueNumberLiveRotationYaxisResponse,
    CueCueNumberLiveRotationYaxisResponseFromJSON,
    CueCueNumberLiveRotationYaxisResponseToJSON,
    CueCueNumberLiveRotationZRequest,
    CueCueNumberLiveRotationZRequestFromJSON,
    CueCueNumberLiveRotationZRequestToJSON,
    CueCueNumberLiveRotationZResponse,
    CueCueNumberLiveRotationZResponseFromJSON,
    CueCueNumberLiveRotationZResponseToJSON,
    CueCueNumberLiveRotationZaxisRequest,
    CueCueNumberLiveRotationZaxisRequestFromJSON,
    CueCueNumberLiveRotationZaxisRequestToJSON,
    CueCueNumberLiveRotationZaxisResponse,
    CueCueNumberLiveRotationZaxisResponseFromJSON,
    CueCueNumberLiveRotationZaxisResponseToJSON,
    CueCueNumberLiveScaleRequest,
    CueCueNumberLiveScaleRequestFromJSON,
    CueCueNumberLiveScaleRequestToJSON,
    CueCueNumberLiveScaleResponse,
    CueCueNumberLiveScaleResponseFromJSON,
    CueCueNumberLiveScaleResponseToJSON,
    CueCueNumberLiveScaleXRequest,
    CueCueNumberLiveScaleXRequestFromJSON,
    CueCueNumberLiveScaleXRequestToJSON,
    CueCueNumberLiveScaleXResponse,
    CueCueNumberLiveScaleXResponseFromJSON,
    CueCueNumberLiveScaleXResponseToJSON,
    CueCueNumberLiveScaleYRequest,
    CueCueNumberLiveScaleYRequestFromJSON,
    CueCueNumberLiveScaleYRequestToJSON,
    CueCueNumberLiveScaleYResponse,
    CueCueNumberLiveScaleYResponseFromJSON,
    CueCueNumberLiveScaleYResponseToJSON,
    CueCueNumberLiveTextOutputSizeResponse,
    CueCueNumberLiveTextOutputSizeResponseFromJSON,
    CueCueNumberLiveTextOutputSizeResponseToJSON,
    CueCueNumberLiveTextRequest,
    CueCueNumberLiveTextRequestFromJSON,
    CueCueNumberLiveTextRequestToJSON,
    CueCueNumberLiveTextResponse,
    CueCueNumberLiveTextResponseFromJSON,
    CueCueNumberLiveTextResponseToJSON,
    CueCueNumberLiveTranslationRequest,
    CueCueNumberLiveTranslationRequestFromJSON,
    CueCueNumberLiveTranslationRequestToJSON,
    CueCueNumberLiveTranslationResponse,
    CueCueNumberLiveTranslationResponseFromJSON,
    CueCueNumberLiveTranslationResponseToJSON,
    CueCueNumberLiveTranslationXRequest,
    CueCueNumberLiveTranslationXRequestFromJSON,
    CueCueNumberLiveTranslationXRequestToJSON,
    CueCueNumberLiveTranslationXResponse,
    CueCueNumberLiveTranslationXResponseFromJSON,
    CueCueNumberLiveTranslationXResponseToJSON,
    CueCueNumberLiveTranslationYRequest,
    CueCueNumberLiveTranslationYRequestFromJSON,
    CueCueNumberLiveTranslationYRequestToJSON,
    CueCueNumberLiveTranslationYResponse,
    CueCueNumberLiveTranslationYResponseFromJSON,
    CueCueNumberLiveTranslationYResponseToJSON,
    CueCueNumberLoadActionAtRequest,
    CueCueNumberLoadActionAtRequestFromJSON,
    CueCueNumberLoadActionAtRequestToJSON,
    CueCueNumberLoadActionAtResponse,
    CueCueNumberLoadActionAtResponseFromJSON,
    CueCueNumberLoadActionAtResponseToJSON,
    CueCueNumberLoadAndSetPlayheadResponse,
    CueCueNumberLoadAndSetPlayheadResponseFromJSON,
    CueCueNumberLoadAndSetPlayheadResponseToJSON,
    CueCueNumberLoadAtRequest,
    CueCueNumberLoadAtRequestFromJSON,
    CueCueNumberLoadAtRequestToJSON,
    CueCueNumberLoadAtResponse,
    CueCueNumberLoadAtResponseFromJSON,
    CueCueNumberLoadAtResponseToJSON,
    CueCueNumberLoadResponse,
    CueCueNumberLoadResponseFromJSON,
    CueCueNumberLoadResponseToJSON,
    CueCueNumberLockFadeToCueRequest,
    CueCueNumberLockFadeToCueRequestFromJSON,
    CueCueNumberLockFadeToCueRequestToJSON,
    CueCueNumberLockFadeToCueResponse,
    CueCueNumberLockFadeToCueResponseFromJSON,
    CueCueNumberLockFadeToCueResponseToJSON,
    CueCueNumberMacroRequest,
    CueCueNumberMacroRequestFromJSON,
    CueCueNumberMacroRequestToJSON,
    CueCueNumberMacroResponse,
    CueCueNumberMacroResponseFromJSON,
    CueCueNumberMacroResponseToJSON,
    CueCueNumberMaxTimeInCueSequenceResponse,
    CueCueNumberMaxTimeInCueSequenceResponseFromJSON,
    CueCueNumberMaxTimeInCueSequenceResponseToJSON,
    CueCueNumberMessageTypeRequest,
    CueCueNumberMessageTypeRequestFromJSON,
    CueCueNumberMessageTypeRequestToJSON,
    CueCueNumberMessageTypeResponse,
    CueCueNumberMessageTypeResponseFromJSON,
    CueCueNumberMessageTypeResponseToJSON,
    CueCueNumberMinutesRequest,
    CueCueNumberMinutesRequestFromJSON,
    CueCueNumberMinutesRequestToJSON,
    CueCueNumberMinutesResponse,
    CueCueNumberMinutesResponseFromJSON,
    CueCueNumberMinutesResponseToJSON,
    CueCueNumberModeRequest,
    CueCueNumberModeRequestFromJSON,
    CueCueNumberModeRequestToJSON,
    CueCueNumberModeResponse,
    CueCueNumberModeResponseFromJSON,
    CueCueNumberModeResponseToJSON,
    CueCueNumberMoveCartCueChildRequest,
    CueCueNumberMoveCartCueChildRequestFromJSON,
    CueCueNumberMoveCartCueChildRequestToJSON,
    CueCueNumberMoveCartCueChildResponse,
    CueCueNumberMoveCartCueChildResponseFromJSON,
    CueCueNumberMoveCartCueChildResponseToJSON,
    CueCueNumberNameRequest,
    CueCueNumberNameRequestFromJSON,
    CueCueNumberNameRequestToJSON,
    CueCueNumberNameResponse,
    CueCueNumberNameResponseFromJSON,
    CueCueNumberNameResponseToJSON,
    CueCueNumberNotesRequest,
    CueCueNumberNotesRequestFromJSON,
    CueCueNumberNotesRequestToJSON,
    CueCueNumberNotesResponse,
    CueCueNumberNotesResponseFromJSON,
    CueCueNumberNotesResponseToJSON,
    CueCueNumberNumChannelsInResponse,
    CueCueNumberNumChannelsInResponseFromJSON,
    CueCueNumberNumChannelsInResponseToJSON,
    CueCueNumberNumberRequest,
    CueCueNumberNumberRequestFromJSON,
    CueCueNumberNumberRequestToJSON,
    CueCueNumberNumberResponse,
    CueCueNumberNumberResponseFromJSON,
    CueCueNumberNumberResponseToJSON,
    CueCueNumberOpacityRequest,
    CueCueNumberOpacityRequestFromJSON,
    CueCueNumberOpacityRequestToJSON,
    CueCueNumberOpacityResponse,
    CueCueNumberOpacityResponseFromJSON,
    CueCueNumberOpacityResponseToJSON,
    CueCueNumberOriginRequest,
    CueCueNumberOriginRequestFromJSON,
    CueCueNumberOriginRequestToJSON,
    CueCueNumberOriginResponse,
    CueCueNumberOriginResponseFromJSON,
    CueCueNumberOriginResponseToJSON,
    CueCueNumberOriginXRequest,
    CueCueNumberOriginXRequestFromJSON,
    CueCueNumberOriginXRequestToJSON,
    CueCueNumberOriginXResponse,
    CueCueNumberOriginXResponseFromJSON,
    CueCueNumberOriginXResponseToJSON,
    CueCueNumberOriginYRequest,
    CueCueNumberOriginYRequestFromJSON,
    CueCueNumberOriginYRequestToJSON,
    CueCueNumberOriginYResponse,
    CueCueNumberOriginYResponseFromJSON,
    CueCueNumberOriginYResponseToJSON,
    CueCueNumberPanicInTimeRequest,
    CueCueNumberPanicInTimeRequestFromJSON,
    CueCueNumberPanicInTimeRequestToJSON,
    CueCueNumberPanicInTimeResponse,
    CueCueNumberPanicInTimeResponseFromJSON,
    CueCueNumberPanicInTimeResponseToJSON,
    CueCueNumberPanicResponse,
    CueCueNumberPanicResponseFromJSON,
    CueCueNumberPanicResponseToJSON,
    CueCueNumberParentResponse,
    CueCueNumberParentResponseFromJSON,
    CueCueNumberParentResponseToJSON,
    CueCueNumberPatchListResponse,
    CueCueNumberPatchListResponseFromJSON,
    CueCueNumberPatchListResponseToJSON,
    CueCueNumberPatchRequest,
    CueCueNumberPatchRequestFromJSON,
    CueCueNumberPatchRequestToJSON,
    CueCueNumberPatchResponse,
    CueCueNumberPatchResponseFromJSON,
    CueCueNumberPatchResponseToJSON,
    CueCueNumberPauseResponse,
    CueCueNumberPauseResponseFromJSON,
    CueCueNumberPauseResponseToJSON,
    CueCueNumberPercentActionElapsedResponse,
    CueCueNumberPercentActionElapsedResponseFromJSON,
    CueCueNumberPercentActionElapsedResponseToJSON,
    CueCueNumberPercentPostWaitElapsedResponse,
    CueCueNumberPercentPostWaitElapsedResponseFromJSON,
    CueCueNumberPercentPostWaitElapsedResponseToJSON,
    CueCueNumberPercentPreWaitElapsedResponse,
    CueCueNumberPercentPreWaitElapsedResponseFromJSON,
    CueCueNumberPercentPreWaitElapsedResponseToJSON,
    CueCueNumberPlayCountRequest,
    CueCueNumberPlayCountRequestFromJSON,
    CueCueNumberPlayCountRequestToJSON,
    CueCueNumberPlayCountResponse,
    CueCueNumberPlayCountResponseFromJSON,
    CueCueNumberPlayCountResponseToJSON,
    CueCueNumberPlaybackPositionIdRequest,
    CueCueNumberPlaybackPositionIdRequestFromJSON,
    CueCueNumberPlaybackPositionIdRequestToJSON,
    CueCueNumberPlaybackPositionIdResponse,
    CueCueNumberPlaybackPositionIdResponseFromJSON,
    CueCueNumberPlaybackPositionIdResponseToJSON,
    CueCueNumberPlaybackPositionRequest,
    CueCueNumberPlaybackPositionRequestFromJSON,
    CueCueNumberPlaybackPositionRequestToJSON,
    CueCueNumberPlaybackPositionResponse,
    CueCueNumberPlaybackPositionResponseFromJSON,
    CueCueNumberPlaybackPositionResponseToJSON,
    CueCueNumberPlayheadIdRequest,
    CueCueNumberPlayheadIdRequestFromJSON,
    CueCueNumberPlayheadIdRequestToJSON,
    CueCueNumberPlayheadIdResponse,
    CueCueNumberPlayheadIdResponseFromJSON,
    CueCueNumberPlayheadIdResponseToJSON,
    CueCueNumberPlayheadNextResponse,
    CueCueNumberPlayheadNextResponseFromJSON,
    CueCueNumberPlayheadNextResponseToJSON,
    CueCueNumberPlayheadPreviousResponse,
    CueCueNumberPlayheadPreviousResponseFromJSON,
    CueCueNumberPlayheadPreviousResponseToJSON,
    CueCueNumberPlayheadRequest,
    CueCueNumberPlayheadRequestFromJSON,
    CueCueNumberPlayheadRequestToJSON,
    CueCueNumberPlayheadResponse,
    CueCueNumberPlayheadResponseFromJSON,
    CueCueNumberPlayheadResponseToJSON,
    CueCueNumberPostWaitElapsedResponse,
    CueCueNumberPostWaitElapsedResponseFromJSON,
    CueCueNumberPostWaitElapsedResponseToJSON,
    CueCueNumberPostWaitRequest,
    CueCueNumberPostWaitRequestFromJSON,
    CueCueNumberPostWaitRequestToJSON,
    CueCueNumberPostWaitResponse,
    CueCueNumberPostWaitResponseFromJSON,
    CueCueNumberPostWaitResponseToJSON,
    CueCueNumberPreWaitElapsedResponse,
    CueCueNumberPreWaitElapsedResponseFromJSON,
    CueCueNumberPreWaitElapsedResponseToJSON,
    CueCueNumberPreWaitRequest,
    CueCueNumberPreWaitRequestFromJSON,
    CueCueNumberPreWaitRequestToJSON,
    CueCueNumberPreWaitResponse,
    CueCueNumberPreWaitResponseFromJSON,
    CueCueNumberPreWaitResponseToJSON,
    CueCueNumberPreserveAspectRatioRequest,
    CueCueNumberPreserveAspectRatioRequestFromJSON,
    CueCueNumberPreserveAspectRatioRequestToJSON,
    CueCueNumberPreserveAspectRatioResponse,
    CueCueNumberPreserveAspectRatioResponseFromJSON,
    CueCueNumberPreserveAspectRatioResponseToJSON,
    CueCueNumberPreviewResponse,
    CueCueNumberPreviewResponseFromJSON,
    CueCueNumberPreviewResponseToJSON,
    CueCueNumberPruneCommandsResponse,
    CueCueNumberPruneCommandsResponseFromJSON,
    CueCueNumberPruneCommandsResponseToJSON,
    CueCueNumberPruneResponse,
    CueCueNumberPruneResponseFromJSON,
    CueCueNumberPruneResponseToJSON,
    CueCueNumberQListRequest,
    CueCueNumberQListRequestFromJSON,
    CueCueNumberQListRequestToJSON,
    CueCueNumberQListResponse,
    CueCueNumberQListResponseFromJSON,
    CueCueNumberQListResponseToJSON,
    CueCueNumberQNumberRequest,
    CueCueNumberQNumberRequestFromJSON,
    CueCueNumberQNumberRequestToJSON,
    CueCueNumberQNumberResponse,
    CueCueNumberQNumberResponseFromJSON,
    CueCueNumberQNumberResponseToJSON,
    CueCueNumberQPathRequest,
    CueCueNumberQPathRequestFromJSON,
    CueCueNumberQPathRequestToJSON,
    CueCueNumberQPathResponse,
    CueCueNumberQPathResponseFromJSON,
    CueCueNumberQPathResponseToJSON,
    CueCueNumberQlabCommandRequest,
    CueCueNumberQlabCommandRequestFromJSON,
    CueCueNumberQlabCommandRequestToJSON,
    CueCueNumberQlabCommandResponse,
    CueCueNumberQlabCommandResponseFromJSON,
    CueCueNumberQlabCommandResponseToJSON,
    CueCueNumberQlabCueNumberRequest,
    CueCueNumberQlabCueNumberRequestFromJSON,
    CueCueNumberQlabCueNumberRequestToJSON,
    CueCueNumberQlabCueNumberResponse,
    CueCueNumberQlabCueNumberResponseFromJSON,
    CueCueNumberQlabCueNumberResponseToJSON,
    CueCueNumberQlabCueParametersRequest,
    CueCueNumberQlabCueParametersRequestFromJSON,
    CueCueNumberQlabCueParametersRequestToJSON,
    CueCueNumberQlabCueParametersResponse,
    CueCueNumberQlabCueParametersResponseFromJSON,
    CueCueNumberQlabCueParametersResponseToJSON,
    CueCueNumberQuaternionRequest,
    CueCueNumberQuaternionRequestFromJSON,
    CueCueNumberQuaternionRequestToJSON,
    CueCueNumberQuaternionResponse,
    CueCueNumberQuaternionResponseFromJSON,
    CueCueNumberQuaternionResponseToJSON,
    CueCueNumberRateRequest,
    CueCueNumberRateRequestFromJSON,
    CueCueNumberRateRequestToJSON,
    CueCueNumberRateResponse,
    CueCueNumberRateResponseFromJSON,
    CueCueNumberRateResponseToJSON,
    CueCueNumberRawStringRequest,
    CueCueNumberRawStringRequestFromJSON,
    CueCueNumberRawStringRequestToJSON,
    CueCueNumberRawStringResponse,
    CueCueNumberRawStringResponseFromJSON,
    CueCueNumberRawStringResponseToJSON,
    CueCueNumberRemoveLightCommandsMatchingRequest,
    CueCueNumberRemoveLightCommandsMatchingRequestFromJSON,
    CueCueNumberRemoveLightCommandsMatchingRequestToJSON,
    CueCueNumberRemoveLightCommandsMatchingResponse,
    CueCueNumberRemoveLightCommandsMatchingResponseFromJSON,
    CueCueNumberRemoveLightCommandsMatchingResponseToJSON,
    CueCueNumberReplaceLightCommandRequest,
    CueCueNumberReplaceLightCommandRequestFromJSON,
    CueCueNumberReplaceLightCommandRequestToJSON,
    CueCueNumberReplaceLightCommandResponse,
    CueCueNumberReplaceLightCommandResponseFromJSON,
    CueCueNumberReplaceLightCommandResponseToJSON,
    CueCueNumberResetResponse,
    CueCueNumberResetResponseFromJSON,
    CueCueNumberResetResponseToJSON,
    CueCueNumberResetRotationResponse,
    CueCueNumberResetRotationResponseFromJSON,
    CueCueNumberResetRotationResponseToJSON,
    CueCueNumberResumeResponse,
    CueCueNumberResumeResponseFromJSON,
    CueCueNumberResumeResponseToJSON,
    CueCueNumberRotateXRequest,
    CueCueNumberRotateXRequestFromJSON,
    CueCueNumberRotateXRequestToJSON,
    CueCueNumberRotateXResponse,
    CueCueNumberRotateXResponseFromJSON,
    CueCueNumberRotateXResponseToJSON,
    CueCueNumberRotateYRequest,
    CueCueNumberRotateYRequestFromJSON,
    CueCueNumberRotateYRequestToJSON,
    CueCueNumberRotateYResponse,
    CueCueNumberRotateYResponseFromJSON,
    CueCueNumberRotateYResponseToJSON,
    CueCueNumberRotateZRequest,
    CueCueNumberRotateZRequestFromJSON,
    CueCueNumberRotateZRequestToJSON,
    CueCueNumberRotateZResponse,
    CueCueNumberRotateZResponseFromJSON,
    CueCueNumberRotateZResponseToJSON,
    CueCueNumberRotationRequest,
    CueCueNumberRotationRequestFromJSON,
    CueCueNumberRotationRequestToJSON,
    CueCueNumberRotationResponse,
    CueCueNumberRotationResponseFromJSON,
    CueCueNumberRotationResponseToJSON,
    CueCueNumberRotationTypeRequest,
    CueCueNumberRotationTypeRequestFromJSON,
    CueCueNumberRotationTypeRequestToJSON,
    CueCueNumberRotationTypeResponse,
    CueCueNumberRotationTypeResponseFromJSON,
    CueCueNumberRotationTypeResponseToJSON,
    CueCueNumberSafeSortCommandsResponse,
    CueCueNumberSafeSortCommandsResponseFromJSON,
    CueCueNumberSafeSortCommandsResponseToJSON,
    CueCueNumberSafeSortResponse,
    CueCueNumberSafeSortResponseFromJSON,
    CueCueNumberSafeSortResponseToJSON,
    CueCueNumberScaleRequest,
    CueCueNumberScaleRequestFromJSON,
    CueCueNumberScaleRequestToJSON,
    CueCueNumberScaleResponse,
    CueCueNumberScaleResponseFromJSON,
    CueCueNumberScaleResponseToJSON,
    CueCueNumberScaleXRequest,
    CueCueNumberScaleXRequestFromJSON,
    CueCueNumberScaleXRequestToJSON,
    CueCueNumberScaleXResponse,
    CueCueNumberScaleXResponseFromJSON,
    CueCueNumberScaleXResponseToJSON,
    CueCueNumberScaleYRequest,
    CueCueNumberScaleYRequestFromJSON,
    CueCueNumberScaleYRequestToJSON,
    CueCueNumberScaleYResponse,
    CueCueNumberScaleYResponseFromJSON,
    CueCueNumberScaleYResponseToJSON,
    CueCueNumberScriptSourceResponse,
    CueCueNumberScriptSourceResponseFromJSON,
    CueCueNumberScriptSourceResponseToJSON,
    CueCueNumberSecondTriggerActionRequest,
    CueCueNumberSecondTriggerActionRequestFromJSON,
    CueCueNumberSecondTriggerActionRequestToJSON,
    CueCueNumberSecondTriggerActionResponse,
    CueCueNumberSecondTriggerActionResponseFromJSON,
    CueCueNumberSecondTriggerActionResponseToJSON,
    CueCueNumberSecondTriggerOnReleaseRequest,
    CueCueNumberSecondTriggerOnReleaseRequestFromJSON,
    CueCueNumberSecondTriggerOnReleaseRequestToJSON,
    CueCueNumberSecondTriggerOnReleaseResponse,
    CueCueNumberSecondTriggerOnReleaseResponseFromJSON,
    CueCueNumberSecondTriggerOnReleaseResponseToJSON,
    CueCueNumberSecondsRequest,
    CueCueNumberSecondsRequestFromJSON,
    CueCueNumberSecondsRequestToJSON,
    CueCueNumberSecondsResponse,
    CueCueNumberSecondsResponseFromJSON,
    CueCueNumberSecondsResponseToJSON,
    CueCueNumberSetDefaultLevelsResponse,
    CueCueNumberSetDefaultLevelsResponseFromJSON,
    CueCueNumberSetDefaultLevelsResponseToJSON,
    CueCueNumberSetGeometryFromTargetResponse,
    CueCueNumberSetGeometryFromTargetResponseFromJSON,
    CueCueNumberSetGeometryFromTargetResponseToJSON,
    CueCueNumberSetLevelsFromTargetResponse,
    CueCueNumberSetLevelsFromTargetResponseFromJSON,
    CueCueNumberSetLevelsFromTargetResponseToJSON,
    CueCueNumberSetLightRequest,
    CueCueNumberSetLightRequestFromJSON,
    CueCueNumberSetLightRequestToJSON,
    CueCueNumberSetLightResponse,
    CueCueNumberSetLightResponseFromJSON,
    CueCueNumberSetLightResponseToJSON,
    CueCueNumberSetSilentLevelsResponse,
    CueCueNumberSetSilentLevelsResponseFromJSON,
    CueCueNumberSetSilentLevelsResponseToJSON,
    CueCueNumberSliceMarkerIndexPlayCountMinusRequest,
    CueCueNumberSliceMarkerIndexPlayCountMinusRequestFromJSON,
    CueCueNumberSliceMarkerIndexPlayCountMinusRequestToJSON,
    CueCueNumberSliceMarkerIndexPlayCountMinusResponse,
    CueCueNumberSliceMarkerIndexPlayCountMinusResponseFromJSON,
    CueCueNumberSliceMarkerIndexPlayCountMinusResponseToJSON,
    CueCueNumberSliceMarkerIndexPlayCountPlusRequest,
    CueCueNumberSliceMarkerIndexPlayCountPlusRequestFromJSON,
    CueCueNumberSliceMarkerIndexPlayCountPlusRequestToJSON,
    CueCueNumberSliceMarkerIndexPlayCountPlusResponse,
    CueCueNumberSliceMarkerIndexPlayCountPlusResponseFromJSON,
    CueCueNumberSliceMarkerIndexPlayCountPlusResponseToJSON,
    CueCueNumberSliceMarkerIndexPlayCountRequest,
    CueCueNumberSliceMarkerIndexPlayCountRequestFromJSON,
    CueCueNumberSliceMarkerIndexPlayCountRequestToJSON,
    CueCueNumberSliceMarkerIndexPlayCountResponse,
    CueCueNumberSliceMarkerIndexPlayCountResponseFromJSON,
    CueCueNumberSliceMarkerIndexPlayCountResponseToJSON,
    CueCueNumberSliceMarkerIndexRequest,
    CueCueNumberSliceMarkerIndexRequestFromJSON,
    CueCueNumberSliceMarkerIndexRequestToJSON,
    CueCueNumberSliceMarkerIndexResponse,
    CueCueNumberSliceMarkerIndexResponseFromJSON,
    CueCueNumberSliceMarkerIndexResponseToJSON,
    CueCueNumberSliceMarkerIndexTimeMinusRequest,
    CueCueNumberSliceMarkerIndexTimeMinusRequestFromJSON,
    CueCueNumberSliceMarkerIndexTimeMinusRequestToJSON,
    CueCueNumberSliceMarkerIndexTimeMinusResponse,
    CueCueNumberSliceMarkerIndexTimeMinusResponseFromJSON,
    CueCueNumberSliceMarkerIndexTimeMinusResponseToJSON,
    CueCueNumberSliceMarkerIndexTimePlusRequest,
    CueCueNumberSliceMarkerIndexTimePlusRequestFromJSON,
    CueCueNumberSliceMarkerIndexTimePlusRequestToJSON,
    CueCueNumberSliceMarkerIndexTimePlusResponse,
    CueCueNumberSliceMarkerIndexTimePlusResponseFromJSON,
    CueCueNumberSliceMarkerIndexTimePlusResponseToJSON,
    CueCueNumberSliceMarkerIndexTimeRequest,
    CueCueNumberSliceMarkerIndexTimeRequestFromJSON,
    CueCueNumberSliceMarkerIndexTimeRequestToJSON,
    CueCueNumberSliceMarkerIndexTimeResponse,
    CueCueNumberSliceMarkerIndexTimeResponseFromJSON,
    CueCueNumberSliceMarkerIndexTimeResponseToJSON,
    CueCueNumberSliceMarkerRequest,
    CueCueNumberSliceMarkerRequestFromJSON,
    CueCueNumberSliceMarkerRequestToJSON,
    CueCueNumberSliceMarkerResponse,
    CueCueNumberSliceMarkerResponseFromJSON,
    CueCueNumberSliceMarkerResponseToJSON,
    CueCueNumberSliceMarkersResponse,
    CueCueNumberSliceMarkersResponseFromJSON,
    CueCueNumberSliceMarkersResponseToJSON,
    CueCueNumberSliceMarkersTimeMinusRequest,
    CueCueNumberSliceMarkersTimeMinusRequestFromJSON,
    CueCueNumberSliceMarkersTimeMinusRequestToJSON,
    CueCueNumberSliceMarkersTimeMinusResponse,
    CueCueNumberSliceMarkersTimeMinusResponseFromJSON,
    CueCueNumberSliceMarkersTimeMinusResponseToJSON,
    CueCueNumberSliceMarkersTimePlusRequest,
    CueCueNumberSliceMarkersTimePlusRequestFromJSON,
    CueCueNumberSliceMarkersTimePlusRequestToJSON,
    CueCueNumberSliceMarkersTimePlusResponse,
    CueCueNumberSliceMarkersTimePlusResponseFromJSON,
    CueCueNumberSliceMarkersTimePlusResponseToJSON,
    CueCueNumberSliderLevelChannelRequest,
    CueCueNumberSliderLevelChannelRequestFromJSON,
    CueCueNumberSliderLevelChannelRequestToJSON,
    CueCueNumberSliderLevelChannelResponse,
    CueCueNumberSliderLevelChannelResponseFromJSON,
    CueCueNumberSliderLevelChannelResponseToJSON,
    CueCueNumberSliderLevelRequest,
    CueCueNumberSliderLevelRequestFromJSON,
    CueCueNumberSliderLevelRequestToJSON,
    CueCueNumberSliderLevelResponse,
    CueCueNumberSliderLevelResponseFromJSON,
    CueCueNumberSliderLevelResponseToJSON,
    CueCueNumberSliderLevelsResponse,
    CueCueNumberSliderLevelsResponseFromJSON,
    CueCueNumberSliderLevelsResponseToJSON,
    CueCueNumberSoloCueInTimeRequest,
    CueCueNumberSoloCueInTimeRequestFromJSON,
    CueCueNumberSoloCueInTimeRequestToJSON,
    CueCueNumberSoloCueInTimeResponse,
    CueCueNumberSoloCueInTimeResponseFromJSON,
    CueCueNumberSoloCueInTimeResponseToJSON,
    CueCueNumberStartAndAutoloadNextResponse,
    CueCueNumberStartAndAutoloadNextResponseFromJSON,
    CueCueNumberStartAndAutoloadNextResponseToJSON,
    CueCueNumberStartNextCueWhenSliceEndsRequest,
    CueCueNumberStartNextCueWhenSliceEndsRequestFromJSON,
    CueCueNumberStartNextCueWhenSliceEndsRequestToJSON,
    CueCueNumberStartNextCueWhenSliceEndsResponse,
    CueCueNumberStartNextCueWhenSliceEndsResponseFromJSON,
    CueCueNumberStartNextCueWhenSliceEndsResponseToJSON,
    CueCueNumberStartResponse,
    CueCueNumberStartResponseFromJSON,
    CueCueNumberStartResponseToJSON,
    CueCueNumberStartTimeRequest,
    CueCueNumberStartTimeRequestFromJSON,
    CueCueNumberStartTimeRequestToJSON,
    CueCueNumberStartTimeResponse,
    CueCueNumberStartTimeResponseFromJSON,
    CueCueNumberStartTimeResponseToJSON,
    CueCueNumberStatusRequest,
    CueCueNumberStatusRequestFromJSON,
    CueCueNumberStatusRequestToJSON,
    CueCueNumberStatusResponse,
    CueCueNumberStatusResponseFromJSON,
    CueCueNumberStatusResponseToJSON,
    CueCueNumberStopResponse,
    CueCueNumberStopResponseFromJSON,
    CueCueNumberStopResponseToJSON,
    CueCueNumberStopTargetWhenDoneRequest,
    CueCueNumberStopTargetWhenDoneRequestFromJSON,
    CueCueNumberStopTargetWhenDoneRequestToJSON,
    CueCueNumberStopTargetWhenDoneResponse,
    CueCueNumberStopTargetWhenDoneResponseFromJSON,
    CueCueNumberStopTargetWhenDoneResponseToJSON,
    CueCueNumberStopTargetWhenSliceEndsRequest,
    CueCueNumberStopTargetWhenSliceEndsRequestFromJSON,
    CueCueNumberStopTargetWhenSliceEndsRequestToJSON,
    CueCueNumberStopTargetWhenSliceEndsResponse,
    CueCueNumberStopTargetWhenSliceEndsResponseFromJSON,
    CueCueNumberStopTargetWhenSliceEndsResponseToJSON,
    CueCueNumberSubframesRequest,
    CueCueNumberSubframesRequestFromJSON,
    CueCueNumberSubframesRequestToJSON,
    CueCueNumberSubframesResponse,
    CueCueNumberSubframesResponseFromJSON,
    CueCueNumberSubframesResponseToJSON,
    CueCueNumberSurfaceIDRequest,
    CueCueNumberSurfaceIDRequestFromJSON,
    CueCueNumberSurfaceIDRequestToJSON,
    CueCueNumberSurfaceIDResponse,
    CueCueNumberSurfaceIDResponseFromJSON,
    CueCueNumberSurfaceIDResponseToJSON,
    CueCueNumberSurfaceListResponse,
    CueCueNumberSurfaceListResponseFromJSON,
    CueCueNumberSurfaceListResponseToJSON,
    CueCueNumberSurfaceNameRequest,
    CueCueNumberSurfaceNameRequestFromJSON,
    CueCueNumberSurfaceNameRequestToJSON,
    CueCueNumberSurfaceNameResponse,
    CueCueNumberSurfaceNameResponseFromJSON,
    CueCueNumberSurfaceNameResponseToJSON,
    CueCueNumberSurfaceSizeResponse,
    CueCueNumberSurfaceSizeResponseFromJSON,
    CueCueNumberSurfaceSizeResponseToJSON,
    CueCueNumberTempCueTargetIdResponse,
    CueCueNumberTempCueTargetIdResponseFromJSON,
    CueCueNumberTempCueTargetIdResponseToJSON,
    CueCueNumberTempCueTargetNumberRequest,
    CueCueNumberTempCueTargetNumberRequestFromJSON,
    CueCueNumberTempCueTargetNumberRequestToJSON,
    CueCueNumberTempCueTargetNumberResponse,
    CueCueNumberTempCueTargetNumberResponseFromJSON,
    CueCueNumberTempCueTargetNumberResponseToJSON,
    CueCueNumberTempDurationRequest,
    CueCueNumberTempDurationRequestFromJSON,
    CueCueNumberTempDurationRequestToJSON,
    CueCueNumberTempDurationResponse,
    CueCueNumberTempDurationResponseFromJSON,
    CueCueNumberTempDurationResponseToJSON,
    CueCueNumberTextFormatAlignmentRequest,
    CueCueNumberTextFormatAlignmentRequestFromJSON,
    CueCueNumberTextFormatAlignmentRequestToJSON,
    CueCueNumberTextFormatAlignmentResponse,
    CueCueNumberTextFormatAlignmentResponseFromJSON,
    CueCueNumberTextFormatAlignmentResponseToJSON,
    CueCueNumberTextFormatBackgroundColorRequest,
    CueCueNumberTextFormatBackgroundColorRequestFromJSON,
    CueCueNumberTextFormatBackgroundColorRequestToJSON,
    CueCueNumberTextFormatBackgroundColorResponse,
    CueCueNumberTextFormatBackgroundColorResponseFromJSON,
    CueCueNumberTextFormatBackgroundColorResponseToJSON,
    CueCueNumberTextFormatColorRequest,
    CueCueNumberTextFormatColorRequestFromJSON,
    CueCueNumberTextFormatColorRequestToJSON,
    CueCueNumberTextFormatColorResponse,
    CueCueNumberTextFormatColorResponseFromJSON,
    CueCueNumberTextFormatColorResponseToJSON,
    CueCueNumberTextFormatFontFamilyAndStyleRequest,
    CueCueNumberTextFormatFontFamilyAndStyleRequestFromJSON,
    CueCueNumberTextFormatFontFamilyAndStyleRequestToJSON,
    CueCueNumberTextFormatFontFamilyAndStyleResponse,
    CueCueNumberTextFormatFontFamilyAndStyleResponseFromJSON,
    CueCueNumberTextFormatFontFamilyAndStyleResponseToJSON,
    CueCueNumberTextFormatFontFamilyResponse,
    CueCueNumberTextFormatFontFamilyResponseFromJSON,
    CueCueNumberTextFormatFontFamilyResponseToJSON,
    CueCueNumberTextFormatFontNameRequest,
    CueCueNumberTextFormatFontNameRequestFromJSON,
    CueCueNumberTextFormatFontNameRequestToJSON,
    CueCueNumberTextFormatFontNameResponse,
    CueCueNumberTextFormatFontNameResponseFromJSON,
    CueCueNumberTextFormatFontNameResponseToJSON,
    CueCueNumberTextFormatFontSizeRequest,
    CueCueNumberTextFormatFontSizeRequestFromJSON,
    CueCueNumberTextFormatFontSizeRequestToJSON,
    CueCueNumberTextFormatFontSizeResponse,
    CueCueNumberTextFormatFontSizeResponseFromJSON,
    CueCueNumberTextFormatFontSizeResponseToJSON,
    CueCueNumberTextFormatFontStyleResponse,
    CueCueNumberTextFormatFontStyleResponseFromJSON,
    CueCueNumberTextFormatFontStyleResponseToJSON,
    CueCueNumberTextFormatLineSpacingRequest,
    CueCueNumberTextFormatLineSpacingRequestFromJSON,
    CueCueNumberTextFormatLineSpacingRequestToJSON,
    CueCueNumberTextFormatLineSpacingResponse,
    CueCueNumberTextFormatLineSpacingResponseFromJSON,
    CueCueNumberTextFormatLineSpacingResponseToJSON,
    CueCueNumberTextFormatRequest,
    CueCueNumberTextFormatRequestFromJSON,
    CueCueNumberTextFormatRequestToJSON,
    CueCueNumberTextFormatResponse,
    CueCueNumberTextFormatResponseFromJSON,
    CueCueNumberTextFormatResponseToJSON,
    CueCueNumberTextFormatStrikethroughColorRequest,
    CueCueNumberTextFormatStrikethroughColorRequestFromJSON,
    CueCueNumberTextFormatStrikethroughColorRequestToJSON,
    CueCueNumberTextFormatStrikethroughColorResponse,
    CueCueNumberTextFormatStrikethroughColorResponseFromJSON,
    CueCueNumberTextFormatStrikethroughColorResponseToJSON,
    CueCueNumberTextFormatStrikethroughStyleRequest,
    CueCueNumberTextFormatStrikethroughStyleRequestFromJSON,
    CueCueNumberTextFormatStrikethroughStyleRequestToJSON,
    CueCueNumberTextFormatStrikethroughStyleResponse,
    CueCueNumberTextFormatStrikethroughStyleResponseFromJSON,
    CueCueNumberTextFormatStrikethroughStyleResponseToJSON,
    CueCueNumberTextFormatUnderlineColorRequest,
    CueCueNumberTextFormatUnderlineColorRequestFromJSON,
    CueCueNumberTextFormatUnderlineColorRequestToJSON,
    CueCueNumberTextFormatUnderlineColorResponse,
    CueCueNumberTextFormatUnderlineColorResponseFromJSON,
    CueCueNumberTextFormatUnderlineColorResponseToJSON,
    CueCueNumberTextFormatUnderlineStyleRequest,
    CueCueNumberTextFormatUnderlineStyleRequestFromJSON,
    CueCueNumberTextFormatUnderlineStyleRequestToJSON,
    CueCueNumberTextFormatUnderlineStyleResponse,
    CueCueNumberTextFormatUnderlineStyleResponseFromJSON,
    CueCueNumberTextFormatUnderlineStyleResponseToJSON,
    CueCueNumberTextOutputSizeResponse,
    CueCueNumberTextOutputSizeResponseFromJSON,
    CueCueNumberTextOutputSizeResponseToJSON,
    CueCueNumberTextRequest,
    CueCueNumberTextRequestFromJSON,
    CueCueNumberTextRequestToJSON,
    CueCueNumberTextResponse,
    CueCueNumberTextResponseFromJSON,
    CueCueNumberTextResponseToJSON,
    CueCueNumberTimecodeFormatRequest,
    CueCueNumberTimecodeFormatRequestFromJSON,
    CueCueNumberTimecodeFormatRequestToJSON,
    CueCueNumberTimecodeFormatResponse,
    CueCueNumberTimecodeFormatResponseFromJSON,
    CueCueNumberTimecodeFormatResponseToJSON,
    CueCueNumberTimecodeStringRequest,
    CueCueNumberTimecodeStringRequestFromJSON,
    CueCueNumberTimecodeStringRequestToJSON,
    CueCueNumberTimecodeStringResponse,
    CueCueNumberTimecodeStringResponseFromJSON,
    CueCueNumberTimecodeStringResponseToJSON,
    CueCueNumberTogglePauseResponse,
    CueCueNumberTogglePauseResponseFromJSON,
    CueCueNumberTogglePauseResponseToJSON,
    CueCueNumberTranslationRequest,
    CueCueNumberTranslationRequestFromJSON,
    CueCueNumberTranslationRequestToJSON,
    CueCueNumberTranslationResponse,
    CueCueNumberTranslationResponseFromJSON,
    CueCueNumberTranslationResponseToJSON,
    CueCueNumberTranslationXRequest,
    CueCueNumberTranslationXRequestFromJSON,
    CueCueNumberTranslationXRequestToJSON,
    CueCueNumberTranslationXResponse,
    CueCueNumberTranslationXResponseFromJSON,
    CueCueNumberTranslationXResponseToJSON,
    CueCueNumberTranslationYRequest,
    CueCueNumberTranslationYRequestFromJSON,
    CueCueNumberTranslationYRequestToJSON,
    CueCueNumberTranslationYResponse,
    CueCueNumberTranslationYResponseFromJSON,
    CueCueNumberTranslationYResponseToJSON,
    CueCueNumberTypeResponse,
    CueCueNumberTypeResponseFromJSON,
    CueCueNumberTypeResponseToJSON,
    CueCueNumberUdpStringRequest,
    CueCueNumberUdpStringRequestFromJSON,
    CueCueNumberUdpStringRequestToJSON,
    CueCueNumberUdpStringResponse,
    CueCueNumberUdpStringResponseFromJSON,
    CueCueNumberUdpStringResponseToJSON,
    CueCueNumberUniqueIDResponse,
    CueCueNumberUniqueIDResponseFromJSON,
    CueCueNumberUniqueIDResponseToJSON,
    CueCueNumberUpdateLightCommandRequest,
    CueCueNumberUpdateLightCommandRequestFromJSON,
    CueCueNumberUpdateLightCommandRequestToJSON,
    CueCueNumberUpdateLightCommandResponse,
    CueCueNumberUpdateLightCommandResponseFromJSON,
    CueCueNumberUpdateLightCommandResponseToJSON,
    CueCueNumberValuesForKeysRequest,
    CueCueNumberValuesForKeysRequestFromJSON,
    CueCueNumberValuesForKeysRequestToJSON,
    CueCueNumberValuesForKeysResponse,
    CueCueNumberValuesForKeysResponseFromJSON,
    CueCueNumberValuesForKeysResponseToJSON,
    CueCueNumberValuesForKeysWithArgumentsRequest,
    CueCueNumberValuesForKeysWithArgumentsRequestFromJSON,
    CueCueNumberValuesForKeysWithArgumentsRequestToJSON,
    CueCueNumberValuesForKeysWithArgumentsResponse,
    CueCueNumberValuesForKeysWithArgumentsResponseFromJSON,
    CueCueNumberValuesForKeysWithArgumentsResponseToJSON,
    CueCueNumberWillFadeRequest,
    CueCueNumberWillFadeRequestFromJSON,
    CueCueNumberWillFadeRequestToJSON,
    CueCueNumberWillFadeResponse,
    CueCueNumberWillFadeResponseFromJSON,
    CueCueNumberWillFadeResponseToJSON,
    CueListsShallowResponse,
    CueListsShallowResponseFromJSON,
    CueListsShallowResponseToJSON,
    CueListsUniqueIDsResponse,
    CueListsUniqueIDsResponseFromJSON,
    CueListsUniqueIDsResponseToJSON,
    CueListsUniqueIDsShallowResponse,
    CueListsUniqueIDsShallowResponseFromJSON,
    CueListsUniqueIDsShallowResponseToJSON,
    CueNumberChildrenShallowResponse,
    CueNumberChildrenShallowResponseFromJSON,
    CueNumberChildrenShallowResponseToJSON,
    CueNumberChildrenUniqueIDsResponse,
    CueNumberChildrenUniqueIDsResponseFromJSON,
    CueNumberChildrenUniqueIDsResponseToJSON,
    CueNumberChildrenUniqueIDsShallowResponse,
    CueNumberChildrenUniqueIDsShallowResponseFromJSON,
    CueNumberChildrenUniqueIDsShallowResponseToJSON,
    FontFamiliesAndStylesResponse,
    FontFamiliesAndStylesResponseFromJSON,
    FontFamiliesAndStylesResponseToJSON,
    FontNamesResponse,
    FontNamesResponseFromJSON,
    FontNamesResponseToJSON,
    LiveFadePreviewRequest,
    LiveFadePreviewRequestFromJSON,
    LiveFadePreviewRequestToJSON,
    LiveFadePreviewResponse,
    LiveFadePreviewResponseFromJSON,
    LiveFadePreviewResponseToJSON,
    OverrideWindowRequest,
    OverrideWindowRequestFromJSON,
    OverrideWindowRequestToJSON,
    OverrideWindowResponse,
    OverrideWindowResponseFromJSON,
    OverrideWindowResponseToJSON,
    OverridesArtNetEnabledRequest,
    OverridesArtNetEnabledRequestFromJSON,
    OverridesArtNetEnabledRequestToJSON,
    OverridesArtNetEnabledResponse,
    OverridesArtNetEnabledResponseFromJSON,
    OverridesArtNetEnabledResponseToJSON,
    OverridesMidiInputEnabledRequest,
    OverridesMidiInputEnabledRequestFromJSON,
    OverridesMidiInputEnabledRequestToJSON,
    OverridesMidiInputEnabledResponse,
    OverridesMidiInputEnabledResponseFromJSON,
    OverridesMidiInputEnabledResponseToJSON,
    OverridesMidiOutputEnabledRequest,
    OverridesMidiOutputEnabledRequestFromJSON,
    OverridesMidiOutputEnabledRequestToJSON,
    OverridesMidiOutputEnabledResponse,
    OverridesMidiOutputEnabledResponseFromJSON,
    OverridesMidiOutputEnabledResponseToJSON,
    OverridesMscInputEnabledRequest,
    OverridesMscInputEnabledRequestFromJSON,
    OverridesMscInputEnabledRequestToJSON,
    OverridesMscInputEnabledResponse,
    OverridesMscInputEnabledResponseFromJSON,
    OverridesMscInputEnabledResponseToJSON,
    OverridesMscOutputEnabledRequest,
    OverridesMscOutputEnabledRequestFromJSON,
    OverridesMscOutputEnabledRequestToJSON,
    OverridesMscOutputEnabledResponse,
    OverridesMscOutputEnabledResponseFromJSON,
    OverridesMscOutputEnabledResponseToJSON,
    OverridesOscInputEnabledRequest,
    OverridesOscInputEnabledRequestFromJSON,
    OverridesOscInputEnabledRequestToJSON,
    OverridesOscInputEnabledResponse,
    OverridesOscInputEnabledResponseFromJSON,
    OverridesOscInputEnabledResponseToJSON,
    OverridesOscOutputEnabledRequest,
    OverridesOscOutputEnabledRequestFromJSON,
    OverridesOscOutputEnabledRequestToJSON,
    OverridesOscOutputEnabledResponse,
    OverridesOscOutputEnabledResponseFromJSON,
    OverridesOscOutputEnabledResponseToJSON,
    OverridesSysexInputEnabledRequest,
    OverridesSysexInputEnabledRequestFromJSON,
    OverridesSysexInputEnabledRequestToJSON,
    OverridesSysexInputEnabledResponse,
    OverridesSysexInputEnabledResponseFromJSON,
    OverridesSysexInputEnabledResponseToJSON,
    OverridesSysexOutputEnabledRequest,
    OverridesSysexOutputEnabledRequestFromJSON,
    OverridesSysexOutputEnabledRequestToJSON,
    OverridesSysexOutputEnabledResponse,
    OverridesSysexOutputEnabledResponseFromJSON,
    OverridesSysexOutputEnabledResponseToJSON,
    OverridesTimecodeInputEnabledRequest,
    OverridesTimecodeInputEnabledRequestFromJSON,
    OverridesTimecodeInputEnabledRequestToJSON,
    OverridesTimecodeInputEnabledResponse,
    OverridesTimecodeInputEnabledResponseFromJSON,
    OverridesTimecodeInputEnabledResponseToJSON,
    OverridesTimecodeOutputEnabledRequest,
    OverridesTimecodeOutputEnabledRequestFromJSON,
    OverridesTimecodeOutputEnabledRequestToJSON,
    OverridesTimecodeOutputEnabledResponse,
    OverridesTimecodeOutputEnabledResponseFromJSON,
    OverridesTimecodeOutputEnabledResponseToJSON,
    OverridesToggleArtNetResponse,
    OverridesToggleArtNetResponseFromJSON,
    OverridesToggleArtNetResponseToJSON,
    OverridesToggleMidiInputResponse,
    OverridesToggleMidiInputResponseFromJSON,
    OverridesToggleMidiInputResponseToJSON,
    OverridesToggleMidiOutputResponse,
    OverridesToggleMidiOutputResponseFromJSON,
    OverridesToggleMidiOutputResponseToJSON,
    OverridesToggleMscInputResponse,
    OverridesToggleMscInputResponseFromJSON,
    OverridesToggleMscInputResponseToJSON,
    OverridesToggleMscOutputResponse,
    OverridesToggleMscOutputResponseFromJSON,
    OverridesToggleMscOutputResponseToJSON,
    OverridesToggleOscInputResponse,
    OverridesToggleOscInputResponseFromJSON,
    OverridesToggleOscInputResponseToJSON,
    OverridesToggleOscOutputResponse,
    OverridesToggleOscOutputResponseFromJSON,
    OverridesToggleOscOutputResponseToJSON,
    OverridesToggleSysexInputResponse,
    OverridesToggleSysexInputResponseFromJSON,
    OverridesToggleSysexInputResponseToJSON,
    OverridesToggleSysexOutputResponse,
    OverridesToggleSysexOutputResponseFromJSON,
    OverridesToggleSysexOutputResponseToJSON,
    OverridesToggleTimecodeInputResponse,
    OverridesToggleTimecodeInputResponseFromJSON,
    OverridesToggleTimecodeInputResponseToJSON,
    OverridesToggleTimecodeOutputResponse,
    OverridesToggleTimecodeOutputResponseFromJSON,
    OverridesToggleTimecodeOutputResponseToJSON,
    ReplyFormatRequest,
    ReplyFormatRequestFromJSON,
    ReplyFormatRequestToJSON,
    ReplyFormatResponse,
    ReplyFormatResponseFromJSON,
    ReplyFormatResponseToJSON,
    RunningCuesShallowResponse,
    RunningCuesShallowResponseFromJSON,
    RunningCuesShallowResponseToJSON,
    RunningCuesUniqueIDsResponse,
    RunningCuesUniqueIDsResponseFromJSON,
    RunningCuesUniqueIDsResponseToJSON,
    RunningCuesUniqueIDsShallowResponse,
    RunningCuesUniqueIDsShallowResponseFromJSON,
    RunningCuesUniqueIDsShallowResponseToJSON,
    RunningOrPausedCuesShallowResponse,
    RunningOrPausedCuesShallowResponseFromJSON,
    RunningOrPausedCuesShallowResponseToJSON,
    RunningOrPausedCuesUniqueIDsResponse,
    RunningOrPausedCuesUniqueIDsResponseFromJSON,
    RunningOrPausedCuesUniqueIDsResponseToJSON,
    RunningOrPausedCuesUniqueIDsShallowResponse,
    RunningOrPausedCuesUniqueIDsShallowResponseFromJSON,
    RunningOrPausedCuesUniqueIDsShallowResponseToJSON,
    SelectedCuesShallowResponse,
    SelectedCuesShallowResponseFromJSON,
    SelectedCuesShallowResponseToJSON,
    SelectedCuesUniqueIDsResponse,
    SelectedCuesUniqueIDsResponseFromJSON,
    SelectedCuesUniqueIDsResponseToJSON,
    SelectedCuesUniqueIDsShallowResponse,
    SelectedCuesUniqueIDsShallowResponseFromJSON,
    SelectedCuesUniqueIDsShallowResponseToJSON,
    SettingsAudioMaxVolumeResponse,
    SettingsAudioMaxVolumeResponseFromJSON,
    SettingsAudioMaxVolumeResponseToJSON,
    SettingsAudioMinVolumeResponse,
    SettingsAudioMinVolumeResponseFromJSON,
    SettingsAudioMinVolumeResponseToJSON,
    SettingsAudioOutputChannelNamesResponse,
    SettingsAudioOutputChannelNamesResponseFromJSON,
    SettingsAudioOutputChannelNamesResponseToJSON,
    SettingsGeneralMinGoTimeRequest,
    SettingsGeneralMinGoTimeRequestFromJSON,
    SettingsGeneralMinGoTimeRequestToJSON,
    SettingsGeneralMinGoTimeResponse,
    SettingsGeneralMinGoTimeResponseFromJSON,
    SettingsGeneralMinGoTimeResponseToJSON,
    SettingsMicOutputChannelNamesResponse,
    SettingsMicOutputChannelNamesResponseFromJSON,
    SettingsMicOutputChannelNamesResponseToJSON,
    SettingsVideoSurfacesResponse,
    SettingsVideoSurfacesResponseFromJSON,
    SettingsVideoSurfacesResponseToJSON,
    SettingsVideoSurfacesSurfaceIDResponse,
    SettingsVideoSurfacesSurfaceIDResponseFromJSON,
    SettingsVideoSurfacesSurfaceIDResponseToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexControlPointRequest,
    SettingsVideoSurfacesSurfaceIDScreenIndexControlPointRequestFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexControlPointRequestToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexControlPointResponse,
    SettingsVideoSurfacesSurfaceIDScreenIndexControlPointResponseFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexControlPointResponseToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridRequest,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridRequestFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridRequestToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridResponse,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridResponseFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridResponseToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesRequest,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesRequestFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesRequestToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesResponse,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesResponseFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesResponseToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexOriginRequest,
    SettingsVideoSurfacesSurfaceIDScreenIndexOriginRequestFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexOriginRequestToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexOriginResponse,
    SettingsVideoSurfacesSurfaceIDScreenIndexOriginResponseFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexOriginResponseToJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexResetControlPointsResponse,
    SettingsVideoSurfacesSurfaceIDScreenIndexResetControlPointsResponseFromJSON,
    SettingsVideoSurfacesSurfaceIDScreenIndexResetControlPointsResponseToJSON,
    TimecodeWindowRequest,
    TimecodeWindowRequestFromJSON,
    TimecodeWindowRequestToJSON,
    TimecodeWindowResponse,
    TimecodeWindowResponseFromJSON,
    TimecodeWindowResponseToJSON,
    ToggleAuditionWindowResponse,
    ToggleAuditionWindowResponseFromJSON,
    ToggleAuditionWindowResponseToJSON,
    ToggleLiveFadePreviewResponse,
    ToggleLiveFadePreviewResponseFromJSON,
    ToggleLiveFadePreviewResponseToJSON,
    ToggleOverrideWindowResponse,
    ToggleOverrideWindowResponseFromJSON,
    ToggleOverrideWindowResponseToJSON,
    ToggleTimecodeWindowResponse,
    ToggleTimecodeWindowResponseFromJSON,
    ToggleTimecodeWindowResponseToJSON,
    VersionResponse,
    VersionResponseFromJSON,
    VersionResponseToJSON,
    WorkingDirectoryRequest,
    WorkingDirectoryRequestFromJSON,
    WorkingDirectoryRequestToJSON,
    WorkingDirectoryResponse,
    WorkingDirectoryResponseFromJSON,
    WorkingDirectoryResponseToJSON,
    WorkspaceIdBasePathResponse,
    WorkspaceIdBasePathResponseFromJSON,
    WorkspaceIdBasePathResponseToJSON,
    WorkspaceIdConnectRequest,
    WorkspaceIdConnectRequestFromJSON,
    WorkspaceIdConnectRequestToJSON,
    WorkspaceIdConnectResponse,
    WorkspaceIdConnectResponseFromJSON,
    WorkspaceIdConnectResponseToJSON,
    WorkspaceIdCueListsResponse,
    WorkspaceIdCueListsResponseFromJSON,
    WorkspaceIdCueListsResponseToJSON,
    WorkspaceIdDashboardClearResponse,
    WorkspaceIdDashboardClearResponseFromJSON,
    WorkspaceIdDashboardClearResponseToJSON,
    WorkspaceIdDashboardModeRequest,
    WorkspaceIdDashboardModeRequestFromJSON,
    WorkspaceIdDashboardModeRequestToJSON,
    WorkspaceIdDashboardModeResponse,
    WorkspaceIdDashboardModeResponseFromJSON,
    WorkspaceIdDashboardModeResponseToJSON,
    WorkspaceIdDashboardNewCueWithAllResponse,
    WorkspaceIdDashboardNewCueWithAllResponseFromJSON,
    WorkspaceIdDashboardNewCueWithAllResponseToJSON,
    WorkspaceIdDashboardNewCueWithChangesResponse,
    WorkspaceIdDashboardNewCueWithChangesResponseFromJSON,
    WorkspaceIdDashboardNewCueWithChangesResponseToJSON,
    WorkspaceIdDashboardNextModeResponse,
    WorkspaceIdDashboardNextModeResponseFromJSON,
    WorkspaceIdDashboardNextModeResponseToJSON,
    WorkspaceIdDashboardRecordAllToLatestResponse,
    WorkspaceIdDashboardRecordAllToLatestResponseFromJSON,
    WorkspaceIdDashboardRecordAllToLatestResponseToJSON,
    WorkspaceIdDashboardRecordAllToSelectedResponse,
    WorkspaceIdDashboardRecordAllToSelectedResponseFromJSON,
    WorkspaceIdDashboardRecordAllToSelectedResponseToJSON,
    WorkspaceIdDashboardRedoResponse,
    WorkspaceIdDashboardRedoResponseFromJSON,
    WorkspaceIdDashboardRedoResponseToJSON,
    WorkspaceIdDashboardRevertResponse,
    WorkspaceIdDashboardRevertResponseFromJSON,
    WorkspaceIdDashboardRevertResponseToJSON,
    WorkspaceIdDashboardSetLightRequest,
    WorkspaceIdDashboardSetLightRequestFromJSON,
    WorkspaceIdDashboardSetLightRequestToJSON,
    WorkspaceIdDashboardSetLightResponse,
    WorkspaceIdDashboardSetLightResponseFromJSON,
    WorkspaceIdDashboardSetLightResponseToJSON,
    WorkspaceIdDashboardUndoResponse,
    WorkspaceIdDashboardUndoResponseFromJSON,
    WorkspaceIdDashboardUndoResponseToJSON,
    WorkspaceIdDashboardUpdateLatestCueResponse,
    WorkspaceIdDashboardUpdateLatestCueResponseFromJSON,
    WorkspaceIdDashboardUpdateLatestCueResponseToJSON,
    WorkspaceIdDashboardUpdateOriginatingCuesResponse,
    WorkspaceIdDashboardUpdateOriginatingCuesResponseFromJSON,
    WorkspaceIdDashboardUpdateOriginatingCuesResponseToJSON,
    WorkspaceIdDashboardUpdateSelectedCuesResponse,
    WorkspaceIdDashboardUpdateSelectedCuesResponseFromJSON,
    WorkspaceIdDashboardUpdateSelectedCuesResponseToJSON,
    WorkspaceIdDeleteActiveResponse,
    WorkspaceIdDeleteActiveResponseFromJSON,
    WorkspaceIdDeleteActiveResponseToJSON,
    WorkspaceIdDeleteCueNumberResponse,
    WorkspaceIdDeleteCueNumberResponseFromJSON,
    WorkspaceIdDeleteCueNumberResponseToJSON,
    WorkspaceIdDeleteIdCueIdResponse,
    WorkspaceIdDeleteIdCueIdResponseFromJSON,
    WorkspaceIdDeleteIdCueIdResponseToJSON,
    WorkspaceIdDeleteSelectedResponse,
    WorkspaceIdDeleteSelectedResponseFromJSON,
    WorkspaceIdDeleteSelectedResponseToJSON,
    WorkspaceIdDisconnectResponse,
    WorkspaceIdDisconnectResponseFromJSON,
    WorkspaceIdDisconnectResponseToJSON,
    WorkspaceIdDoubleGoWindowRemainingResponse,
    WorkspaceIdDoubleGoWindowRemainingResponseFromJSON,
    WorkspaceIdDoubleGoWindowRemainingResponseToJSON,
    WorkspaceIdFullScreenRequest,
    WorkspaceIdFullScreenRequestFromJSON,
    WorkspaceIdFullScreenRequestToJSON,
    WorkspaceIdFullScreenResponse,
    WorkspaceIdFullScreenResponseFromJSON,
    WorkspaceIdFullScreenResponseToJSON,
    WorkspaceIdGoCueNumberResponse,
    WorkspaceIdGoCueNumberResponseFromJSON,
    WorkspaceIdGoCueNumberResponseToJSON,
    WorkspaceIdGoRequest,
    WorkspaceIdGoRequestFromJSON,
    WorkspaceIdGoRequestToJSON,
    WorkspaceIdGoResponse,
    WorkspaceIdGoResponseFromJSON,
    WorkspaceIdGoResponseToJSON,
    WorkspaceIdHardStopResponse,
    WorkspaceIdHardStopResponseFromJSON,
    WorkspaceIdHardStopResponseToJSON,
    WorkspaceIdLightDashboardRequest,
    WorkspaceIdLightDashboardRequestFromJSON,
    WorkspaceIdLightDashboardRequestToJSON,
    WorkspaceIdLightDashboardResponse,
    WorkspaceIdLightDashboardResponseFromJSON,
    WorkspaceIdLightDashboardResponseToJSON,
    WorkspaceIdMoveCueIdRequest,
    WorkspaceIdMoveCueIdRequestFromJSON,
    WorkspaceIdMoveCueIdRequestToJSON,
    WorkspaceIdMoveCueIdResponse,
    WorkspaceIdMoveCueIdResponseFromJSON,
    WorkspaceIdMoveCueIdResponseToJSON,
    WorkspaceIdNewRequest,
    WorkspaceIdNewRequestFromJSON,
    WorkspaceIdNewRequestToJSON,
    WorkspaceIdNewResponse,
    WorkspaceIdNewResponseFromJSON,
    WorkspaceIdNewResponseToJSON,
    WorkspaceIdPanicInTimeRequest,
    WorkspaceIdPanicInTimeRequestFromJSON,
    WorkspaceIdPanicInTimeRequestToJSON,
    WorkspaceIdPanicInTimeResponse,
    WorkspaceIdPanicInTimeResponseFromJSON,
    WorkspaceIdPanicInTimeResponseToJSON,
    WorkspaceIdPanicResponse,
    WorkspaceIdPanicResponseFromJSON,
    WorkspaceIdPanicResponseToJSON,
    WorkspaceIdPauseResponse,
    WorkspaceIdPauseResponseFromJSON,
    WorkspaceIdPauseResponseToJSON,
    WorkspaceIdPlaybackPositionCueNumberResponse,
    WorkspaceIdPlaybackPositionCueNumberResponseFromJSON,
    WorkspaceIdPlaybackPositionCueNumberResponseToJSON,
    WorkspaceIdPlaybackPositionIdCueIdResponse,
    WorkspaceIdPlaybackPositionIdCueIdResponseFromJSON,
    WorkspaceIdPlaybackPositionIdCueIdResponseToJSON,
    WorkspaceIdPlaybackPositionNextResponse,
    WorkspaceIdPlaybackPositionNextResponseFromJSON,
    WorkspaceIdPlaybackPositionNextResponseToJSON,
    WorkspaceIdPlaybackPositionNextSequenceResponse,
    WorkspaceIdPlaybackPositionNextSequenceResponseFromJSON,
    WorkspaceIdPlaybackPositionNextSequenceResponseToJSON,
    WorkspaceIdPlaybackPositionPreviousResponse,
    WorkspaceIdPlaybackPositionPreviousResponseFromJSON,
    WorkspaceIdPlaybackPositionPreviousResponseToJSON,
    WorkspaceIdPlaybackPositionPreviousSequenceResponse,
    WorkspaceIdPlaybackPositionPreviousSequenceResponseFromJSON,
    WorkspaceIdPlaybackPositionPreviousSequenceResponseToJSON,
    WorkspaceIdPlayheadCueNumberResponse,
    WorkspaceIdPlayheadCueNumberResponseFromJSON,
    WorkspaceIdPlayheadCueNumberResponseToJSON,
    WorkspaceIdPlayheadIdCueIdResponse,
    WorkspaceIdPlayheadIdCueIdResponseFromJSON,
    WorkspaceIdPlayheadIdCueIdResponseToJSON,
    WorkspaceIdPlayheadNextResponse,
    WorkspaceIdPlayheadNextResponseFromJSON,
    WorkspaceIdPlayheadNextResponseToJSON,
    WorkspaceIdPlayheadNextSequenceResponse,
    WorkspaceIdPlayheadNextSequenceResponseFromJSON,
    WorkspaceIdPlayheadNextSequenceResponseToJSON,
    WorkspaceIdPlayheadPreviousResponse,
    WorkspaceIdPlayheadPreviousResponseFromJSON,
    WorkspaceIdPlayheadPreviousResponseToJSON,
    WorkspaceIdPlayheadPreviousSequenceResponse,
    WorkspaceIdPlayheadPreviousSequenceResponseFromJSON,
    WorkspaceIdPlayheadPreviousSequenceResponseToJSON,
    WorkspaceIdRedoResponse,
    WorkspaceIdRedoResponseFromJSON,
    WorkspaceIdRedoResponseToJSON,
    WorkspaceIdRenumberRequest,
    WorkspaceIdRenumberRequestFromJSON,
    WorkspaceIdRenumberRequestToJSON,
    WorkspaceIdRenumberResponse,
    WorkspaceIdRenumberResponseFromJSON,
    WorkspaceIdRenumberResponseToJSON,
    WorkspaceIdResetResponse,
    WorkspaceIdResetResponseFromJSON,
    WorkspaceIdResetResponseToJSON,
    WorkspaceIdResumeResponse,
    WorkspaceIdResumeResponseFromJSON,
    WorkspaceIdResumeResponseToJSON,
    WorkspaceIdRunningCuesResponse,
    WorkspaceIdRunningCuesResponseFromJSON,
    WorkspaceIdRunningCuesResponseToJSON,
    WorkspaceIdRunningOrPausedCuesResponse,
    WorkspaceIdRunningOrPausedCuesResponseFromJSON,
    WorkspaceIdRunningOrPausedCuesResponseToJSON,
    WorkspaceIdSaveResponse,
    WorkspaceIdSaveResponseFromJSON,
    WorkspaceIdSaveResponseToJSON,
    WorkspaceIdSelectCueNumberResponse,
    WorkspaceIdSelectCueNumberResponseFromJSON,
    WorkspaceIdSelectCueNumberResponseToJSON,
    WorkspaceIdSelectIdSelectIdResponse,
    WorkspaceIdSelectIdSelectIdResponseFromJSON,
    WorkspaceIdSelectIdSelectIdResponseToJSON,
    WorkspaceIdSelectNextResponse,
    WorkspaceIdSelectNextResponseFromJSON,
    WorkspaceIdSelectNextResponseToJSON,
    WorkspaceIdSelectPreviousResponse,
    WorkspaceIdSelectPreviousResponseFromJSON,
    WorkspaceIdSelectPreviousResponseToJSON,
    WorkspaceIdSelectedCuesResponse,
    WorkspaceIdSelectedCuesResponseFromJSON,
    WorkspaceIdSelectedCuesResponseToJSON,
    WorkspaceIdSelectionIsPlayheadRequest,
    WorkspaceIdSelectionIsPlayheadRequestFromJSON,
    WorkspaceIdSelectionIsPlayheadRequestToJSON,
    WorkspaceIdSelectionIsPlayheadResponse,
    WorkspaceIdSelectionIsPlayheadResponseFromJSON,
    WorkspaceIdSelectionIsPlayheadResponseToJSON,
    WorkspaceIdShowModeRequest,
    WorkspaceIdShowModeRequestFromJSON,
    WorkspaceIdShowModeRequestToJSON,
    WorkspaceIdShowModeResponse,
    WorkspaceIdShowModeResponseFromJSON,
    WorkspaceIdShowModeResponseToJSON,
    WorkspaceIdStopResponse,
    WorkspaceIdStopResponseFromJSON,
    WorkspaceIdStopResponseToJSON,
    WorkspaceIdThumpResponse,
    WorkspaceIdThumpResponseFromJSON,
    WorkspaceIdThumpResponseToJSON,
    WorkspaceIdToggleEditShowModeResponse,
    WorkspaceIdToggleEditShowModeResponseFromJSON,
    WorkspaceIdToggleEditShowModeResponseToJSON,
    WorkspaceIdToggleFullScreenResponse,
    WorkspaceIdToggleFullScreenResponseFromJSON,
    WorkspaceIdToggleFullScreenResponseToJSON,
    WorkspaceIdToggleLightDashboardResponse,
    WorkspaceIdToggleLightDashboardResponseFromJSON,
    WorkspaceIdToggleLightDashboardResponseToJSON,
    WorkspaceIdToggleSelectionIsPlayheadResponse,
    WorkspaceIdToggleSelectionIsPlayheadResponseFromJSON,
    WorkspaceIdToggleSelectionIsPlayheadResponseToJSON,
    WorkspaceIdUndoResponse,
    WorkspaceIdUndoResponseFromJSON,
    WorkspaceIdUndoResponseToJSON,
    WorkspaceIdUpdatesRequest,
    WorkspaceIdUpdatesRequestFromJSON,
    WorkspaceIdUpdatesRequestToJSON,
    WorkspaceIdUpdatesResponse,
    WorkspaceIdUpdatesResponseFromJSON,
    WorkspaceIdUpdatesResponseToJSON,
    WorkspacesResponse,
    WorkspacesResponseFromJSON,
    WorkspacesResponseToJSON,
} from '../models';

export interface AlwaysReplyOperationRequest {
    expectResponse?: boolean;
    alwaysReplyRequest?: AlwaysReplyRequest;
}

export interface AuditionWindowOperationRequest {
    expectResponse?: boolean;
    auditionWindowRequest?: AuditionWindowRequest;
}

export interface CueCueNumberActionElapsedRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberAddSliceMarkerOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberAddSliceMarkerRequest?: CueCueNumberAddSliceMarkerRequest;
}

export interface CueCueNumberAllowsEditingDurationRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberAlwaysCollateOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberAlwaysCollateRequest?: CueCueNumberAlwaysCollateRequest;
}

export interface CueCueNumberArmedOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberArmedRequest?: CueCueNumberArmedRequest;
}

export interface CueCueNumberAutoLoadOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberAutoLoadRequest?: CueCueNumberAutoLoadRequest;
}

export interface CueCueNumberByte1OperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberByte1Request?: CueCueNumberByte1Request;
}

export interface CueCueNumberByte2OperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberByte2Request?: CueCueNumberByte2Request;
}

export interface CueCueNumberByteComboOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberByteComboRequest?: CueCueNumberByteComboRequest;
}

export interface CueCueNumberCameraPatchRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberCartColumnsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberCartPositionRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberCartRowsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberChannelOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberChannelRequest?: CueCueNumberChannelRequest;
}

export interface CueCueNumberChannelOffsetRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberChannelsOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberChannelsRequest?: CueCueNumberChannelsRequest;
}

export interface CueCueNumberChildrenRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberCollateAndStartRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberColorNameOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberColorNameRequest?: CueCueNumberColorNameRequest;
}

export interface CueCueNumberCommandOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberCommandRequest?: CueCueNumberCommandRequest;
}

export interface CueCueNumberCommandFormatOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberCommandFormatRequest?: CueCueNumberCommandFormatRequest;
}

export interface CueCueNumberCompileSourceRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberContinueModeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberContinueModeRequest?: CueCueNumberContinueModeRequest;
}

export interface CueCueNumberControlNumberOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberControlNumberRequest?: CueCueNumberControlNumberRequest;
}

export interface CueCueNumberControlValueOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberControlValueRequest?: CueCueNumberControlValueRequest;
}

export interface CueCueNumberCueSizeRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberCueTargetIdOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberCueTargetIdRequest?: CueCueNumberCueTargetIdRequest;
}

export interface CueCueNumberCueTargetNumberOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberCueTargetNumberRequest?: CueCueNumberCueTargetNumberRequest;
}

export interface CueCueNumberCurrentCueTargetRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberCurrentDurationRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberCurrentFileTimeRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberCustomStringOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberCustomStringRequest?: CueCueNumberCustomStringRequest;
}

export interface CueCueNumberDefaultNameRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberDeleteSliceMarkerOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDeleteSliceMarkerRequest?: CueCueNumberDeleteSliceMarkerRequest;
}

export interface CueCueNumberDeleteSliceMarkerIndexRequest {
    cueNumber: string;
    index: string;
    expectResponse?: boolean;
}

export interface CueCueNumberDeleteSliceMarkersRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberDeviceIdRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDeviceIDRequest?: CueCueNumberDeviceIDRequest;
}

export interface CueCueNumberDisplayNameRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberDoEffectOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDoEffectRequest?: CueCueNumberDoEffectRequest;
}

export interface CueCueNumberDoFadeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDoFadeRequest?: CueCueNumberDoFadeRequest;
}

export interface CueCueNumberDoOpacityOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDoOpacityRequest?: CueCueNumberDoOpacityRequest;
}

export interface CueCueNumberDoPitchShiftOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDoPitchShiftRequest?: CueCueNumberDoPitchShiftRequest;
}

export interface CueCueNumberDoRateOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDoRateRequest?: CueCueNumberDoRateRequest;
}

export interface CueCueNumberDoRotationOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDoRotationRequest?: CueCueNumberDoRotationRequest;
}

export interface CueCueNumberDoScaleOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDoScaleRequest?: CueCueNumberDoScaleRequest;
}

export interface CueCueNumberDoTranslationOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDoTranslationRequest?: CueCueNumberDoTranslationRequest;
}

export interface CueCueNumberDuckLevelOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDuckLevelRequest?: CueCueNumberDuckLevelRequest;
}

export interface CueCueNumberDuckOthersOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDuckOthersRequest?: CueCueNumberDuckOthersRequest;
}

export interface CueCueNumberDuckTimeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDuckTimeRequest?: CueCueNumberDuckTimeRequest;
}

export interface CueCueNumberDurationOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberDurationRequest?: CueCueNumberDurationRequest;
}

export interface CueCueNumberEffectIndexOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberEffectIndexRequest?: CueCueNumberEffectIndexRequest;
}

export interface CueCueNumberEffectSetOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberEffectSetRequest?: CueCueNumberEffectSetRequest;
}

export interface CueCueNumberEndTimeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberEndTimeRequest?: CueCueNumberEndTimeRequest;
}

export interface CueCueNumberEndValueOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberEndValueRequest?: CueCueNumberEndValueRequest;
}

export interface CueCueNumberFadeAndStopOthersOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberFadeAndStopOthersRequest?: CueCueNumberFadeAndStopOthersRequest;
}

export interface CueCueNumberFadeAndStopOthersTimeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberFadeAndStopOthersTimeRequest?: CueCueNumberFadeAndStopOthersTimeRequest;
}

export interface CueCueNumberFileTargetOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberFileTargetRequest?: CueCueNumberFileTargetRequest;
}

export interface CueCueNumberFixedWidthOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberFixedWidthRequest?: CueCueNumberFixedWidthRequest;
}

export interface CueCueNumberFlaggedOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberFlaggedRequest?: CueCueNumberFlaggedRequest;
}

export interface CueCueNumberFramesOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberFramesRequest?: CueCueNumberFramesRequest;
}

export interface CueCueNumberFullScreenOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberFullScreenRequest?: CueCueNumberFullScreenRequest;
}

export interface CueCueNumberFullSurfaceOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberFullSurfaceRequest?: CueCueNumberFullSurfaceRequest;
}

export interface CueCueNumberGangOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberGangRequest?: CueCueNumberGangRequest;
}

export interface CueCueNumberGangInChannelOutChannelOperationRequest {
    cueNumber: string;
    inChannel: string;
    outChannel: string;
    expectResponse?: boolean;
    cueCueNumberGangInChannelOutChannelRequest?: CueCueNumberGangInChannelOutChannelRequest;
}

export interface CueCueNumberGeoModeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberGeoModeRequest?: CueCueNumberGeoModeRequest;
}

export interface CueCueNumberGoRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberHardPauseRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberHardStopRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberHasCueTargetsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberHasFileTargetsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberHoldLastFrameOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberHoldLastFrameRequest?: CueCueNumberHoldLastFrameRequest;
}

export interface CueCueNumberHoursOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberHoursRequest?: CueCueNumberHoursRequest;
}

export interface CueCueNumberInfiniteLoopOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberInfiniteLoopRequest?: CueCueNumberInfiniteLoopRequest;
}

export interface CueCueNumberIsActionRunningRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberIsBrokenRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberIsLoadedRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberIsOverriddenRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberIsPanickingRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberIsPausedRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberIsRunningRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberIsTailingOutRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberLastSliceInfiniteLoopOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLastSliceInfiniteLoopRequest?: CueCueNumberLastSliceInfiniteLoopRequest;
}

export interface CueCueNumberLastSlicePlayCountOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLastSlicePlayCountRequest?: CueCueNumberLastSlicePlayCountRequest;
}

export interface CueCueNumberLayerOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLayerRequest?: CueCueNumberLayerRequest;
}

export interface CueCueNumberLevelOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLevelRequest?: CueCueNumberLevelRequest;
}

export interface CueCueNumberLevelInChannelOutChannelOperationRequest {
    cueNumber: string;
    inChannel: string;
    outChannel: string;
    expectResponse?: boolean;
    cueCueNumberLevelInChannelOutChannelRequest?: CueCueNumberLevelInChannelOutChannelRequest;
}

export interface CueCueNumberLevelsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberLightCommandTextOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLightCommandTextRequest?: CueCueNumberLightCommandTextRequest;
}

export interface CueCueNumberListNameRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberLiveAverageLevelOutputChannelOperationRequest {
    cueNumber: string;
    outputChannel: string;
    expectResponse?: boolean;
    cueCueNumberLiveAverageLevelOutputChannelRequest?: CueCueNumberLiveAverageLevelOutputChannelRequest;
}

export interface CueCueNumberLiveEffectSetOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveEffectSetRequest?: CueCueNumberLiveEffectSetRequest;
}

export interface CueCueNumberLiveRateOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveRateRequest?: CueCueNumberLiveRateRequest;
}

export interface CueCueNumberLiveRotationXOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveRotationXRequest?: CueCueNumberLiveRotationXRequest;
}

export interface CueCueNumberLiveRotationXaxisOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveRotationXaxisRequest?: CueCueNumberLiveRotationXaxisRequest;
}

export interface CueCueNumberLiveRotationYOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveRotationYRequest?: CueCueNumberLiveRotationYRequest;
}

export interface CueCueNumberLiveRotationYaxisOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveRotationYaxisRequest?: CueCueNumberLiveRotationYaxisRequest;
}

export interface CueCueNumberLiveRotationZOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveRotationZRequest?: CueCueNumberLiveRotationZRequest;
}

export interface CueCueNumberLiveRotationZaxisOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveRotationZaxisRequest?: CueCueNumberLiveRotationZaxisRequest;
}

export interface CueCueNumberLiveScaleOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveScaleRequest?: CueCueNumberLiveScaleRequest;
}

export interface CueCueNumberLiveScaleXOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveScaleXRequest?: CueCueNumberLiveScaleXRequest;
}

export interface CueCueNumberLiveScaleYOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveScaleYRequest?: CueCueNumberLiveScaleYRequest;
}

export interface CueCueNumberLiveTextOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveTextRequest?: CueCueNumberLiveTextRequest;
}

export interface CueCueNumberLiveTextOutputSizeRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberLiveTranslationOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveTranslationRequest?: CueCueNumberLiveTranslationRequest;
}

export interface CueCueNumberLiveTranslationXOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveTranslationXRequest?: CueCueNumberLiveTranslationXRequest;
}

export interface CueCueNumberLiveTranslationYOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLiveTranslationYRequest?: CueCueNumberLiveTranslationYRequest;
}

export interface CueCueNumberLoadRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberLoadActionAtOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLoadActionAtRequest?: CueCueNumberLoadActionAtRequest;
}

export interface CueCueNumberLoadAndSetPlayheadRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberLoadAtOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLoadAtRequest?: CueCueNumberLoadAtRequest;
}

export interface CueCueNumberLockFadeToCueOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberLockFadeToCueRequest?: CueCueNumberLockFadeToCueRequest;
}

export interface CueCueNumberMacroOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberMacroRequest?: CueCueNumberMacroRequest;
}

export interface CueCueNumberMaxTimeInCueSequenceRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberMessageTypeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberMessageTypeRequest?: CueCueNumberMessageTypeRequest;
}

export interface CueCueNumberMinutesOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberMinutesRequest?: CueCueNumberMinutesRequest;
}

export interface CueCueNumberModeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberModeRequest?: CueCueNumberModeRequest;
}

export interface CueCueNumberMoveCartCueChildOperationRequest {
    cueNumber: string;
    child: string;
    expectResponse?: boolean;
    cueCueNumberMoveCartCueChildRequest?: CueCueNumberMoveCartCueChildRequest;
}

export interface CueCueNumberNameOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberNameRequest?: CueCueNumberNameRequest;
}

export interface CueCueNumberNotesOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberNotesRequest?: CueCueNumberNotesRequest;
}

export interface CueCueNumberNumChannelsInRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberNumberOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberNumberRequest?: CueCueNumberNumberRequest;
}

export interface CueCueNumberOpacityOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberOpacityRequest?: CueCueNumberOpacityRequest;
}

export interface CueCueNumberOriginOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberOriginRequest?: CueCueNumberOriginRequest;
}

export interface CueCueNumberOriginXOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberOriginXRequest?: CueCueNumberOriginXRequest;
}

export interface CueCueNumberOriginYOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberOriginYRequest?: CueCueNumberOriginYRequest;
}

export interface CueCueNumberPanicRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPanicInTimeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPanicInTimeRequest?: CueCueNumberPanicInTimeRequest;
}

export interface CueCueNumberParentRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPatchOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPatchRequest?: CueCueNumberPatchRequest;
}

export interface CueCueNumberPatchListRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPauseRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPercentActionElapsedRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPercentPostWaitElapsedRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPercentPreWaitElapsedRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPlayCountOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPlayCountRequest?: CueCueNumberPlayCountRequest;
}

export interface CueCueNumberPlaybackPositionOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPlaybackPositionRequest?: CueCueNumberPlaybackPositionRequest;
}

export interface CueCueNumberPlaybackPositionIdOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPlaybackPositionIdRequest?: CueCueNumberPlaybackPositionIdRequest;
}

export interface CueCueNumberPlayheadOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPlayheadRequest?: CueCueNumberPlayheadRequest;
}

export interface CueCueNumberPlayheadIdOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPlayheadIdRequest?: CueCueNumberPlayheadIdRequest;
}

export interface CueCueNumberPlayheadNextRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPlayheadPreviousRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPostWaitOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPostWaitRequest?: CueCueNumberPostWaitRequest;
}

export interface CueCueNumberPostWaitElapsedRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPreWaitOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPreWaitRequest?: CueCueNumberPreWaitRequest;
}

export interface CueCueNumberPreWaitElapsedRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPreserveAspectRatioOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberPreserveAspectRatioRequest?: CueCueNumberPreserveAspectRatioRequest;
}

export interface CueCueNumberPreviewRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPruneRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberPruneCommandsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberQListOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberQListRequest?: CueCueNumberQListRequest;
}

export interface CueCueNumberQNumberOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberQNumberRequest?: CueCueNumberQNumberRequest;
}

export interface CueCueNumberQPathOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberQPathRequest?: CueCueNumberQPathRequest;
}

export interface CueCueNumberQlabCommandOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberQlabCommandRequest?: CueCueNumberQlabCommandRequest;
}

export interface CueCueNumberQlabCueNumberOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberQlabCueNumberRequest?: CueCueNumberQlabCueNumberRequest;
}

export interface CueCueNumberQlabCueParametersOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberQlabCueParametersRequest?: CueCueNumberQlabCueParametersRequest;
}

export interface CueCueNumberQuaternionOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberQuaternionRequest?: CueCueNumberQuaternionRequest;
}

export interface CueCueNumberRateOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberRateRequest?: CueCueNumberRateRequest;
}

export interface CueCueNumberRawStringOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberRawStringRequest?: CueCueNumberRawStringRequest;
}

export interface CueCueNumberRemoveLightCommandsMatchingOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberRemoveLightCommandsMatchingRequest?: CueCueNumberRemoveLightCommandsMatchingRequest;
}

export interface CueCueNumberReplaceLightCommandOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberReplaceLightCommandRequest?: CueCueNumberReplaceLightCommandRequest;
}

export interface CueCueNumberResetRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberResetRotationRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberResumeRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberRotateXOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberRotateXRequest?: CueCueNumberRotateXRequest;
}

export interface CueCueNumberRotateYOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberRotateYRequest?: CueCueNumberRotateYRequest;
}

export interface CueCueNumberRotateZOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberRotateZRequest?: CueCueNumberRotateZRequest;
}

export interface CueCueNumberRotationOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberRotationRequest?: CueCueNumberRotationRequest;
}

export interface CueCueNumberRotationTypeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberRotationTypeRequest?: CueCueNumberRotationTypeRequest;
}

export interface CueCueNumberSafeSortRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSafeSortCommandsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberScaleOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberScaleRequest?: CueCueNumberScaleRequest;
}

export interface CueCueNumberScaleXOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberScaleXRequest?: CueCueNumberScaleXRequest;
}

export interface CueCueNumberScaleYOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberScaleYRequest?: CueCueNumberScaleYRequest;
}

export interface CueCueNumberScriptSourceRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSecondTriggerActionOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSecondTriggerActionRequest?: CueCueNumberSecondTriggerActionRequest;
}

export interface CueCueNumberSecondTriggerOnReleaseOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSecondTriggerOnReleaseRequest?: CueCueNumberSecondTriggerOnReleaseRequest;
}

export interface CueCueNumberSecondsOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSecondsRequest?: CueCueNumberSecondsRequest;
}

export interface CueCueNumberSetDefaultLevelsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSetGeometryFromTargetRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSetLevelsFromTargetRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSetLightOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSetLightRequest?: CueCueNumberSetLightRequest;
}

export interface CueCueNumberSetSilentLevelsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSliceMarkerOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkerRequest?: CueCueNumberSliceMarkerRequest;
}

export interface CueCueNumberSliceMarkerIndexOperationRequest {
    cueNumber: string;
    index: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkerIndexRequest?: CueCueNumberSliceMarkerIndexRequest;
}

export interface CueCueNumberSliceMarkerIndexPlayCountOperationRequest {
    cueNumber: string;
    index: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkerIndexPlayCountRequest?: CueCueNumberSliceMarkerIndexPlayCountRequest;
}

export interface CueCueNumberSliceMarkerIndexPlayCountMinusOperationRequest {
    cueNumber: string;
    index: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkerIndexPlayCountMinusRequest?: CueCueNumberSliceMarkerIndexPlayCountMinusRequest;
}

export interface CueCueNumberSliceMarkerIndexPlayCountPlusOperationRequest {
    cueNumber: string;
    index: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkerIndexPlayCountPlusRequest?: CueCueNumberSliceMarkerIndexPlayCountPlusRequest;
}

export interface CueCueNumberSliceMarkerIndexTimeOperationRequest {
    cueNumber: string;
    index: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkerIndexTimeRequest?: CueCueNumberSliceMarkerIndexTimeRequest;
}

export interface CueCueNumberSliceMarkerIndexTimeMinusOperationRequest {
    cueNumber: string;
    index: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkerIndexTimeMinusRequest?: CueCueNumberSliceMarkerIndexTimeMinusRequest;
}

export interface CueCueNumberSliceMarkerIndexTimePlusOperationRequest {
    cueNumber: string;
    index: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkerIndexTimePlusRequest?: CueCueNumberSliceMarkerIndexTimePlusRequest;
}

export interface CueCueNumberSliceMarkersRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSliceMarkersTimeMinusOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkersTimeMinusRequest?: CueCueNumberSliceMarkersTimeMinusRequest;
}

export interface CueCueNumberSliceMarkersTimePlusOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSliceMarkersTimePlusRequest?: CueCueNumberSliceMarkersTimePlusRequest;
}

export interface CueCueNumberSliderLevelOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSliderLevelRequest?: CueCueNumberSliderLevelRequest;
}

export interface CueCueNumberSliderLevelChannelOperationRequest {
    cueNumber: string;
    channel: string;
    expectResponse?: boolean;
    cueCueNumberSliderLevelChannelRequest?: CueCueNumberSliderLevelChannelRequest;
}

export interface CueCueNumberSliderLevelsRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSoloCueInTimeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSoloCueInTimeRequest?: CueCueNumberSoloCueInTimeRequest;
}

export interface CueCueNumberStartRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberStartAndAutoloadNextRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberStartNextCueWhenSliceEndsOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberStartNextCueWhenSliceEndsRequest?: CueCueNumberStartNextCueWhenSliceEndsRequest;
}

export interface CueCueNumberStartTimeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberStartTimeRequest?: CueCueNumberStartTimeRequest;
}

export interface CueCueNumberStatusOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberStatusRequest?: CueCueNumberStatusRequest;
}

export interface CueCueNumberStopRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberStopTargetWhenDoneOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberStopTargetWhenDoneRequest?: CueCueNumberStopTargetWhenDoneRequest;
}

export interface CueCueNumberStopTargetWhenSliceEndsOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberStopTargetWhenSliceEndsRequest?: CueCueNumberStopTargetWhenSliceEndsRequest;
}

export interface CueCueNumberSubframesOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSubframesRequest?: CueCueNumberSubframesRequest;
}

export interface CueCueNumberSurfaceIdRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSurfaceIDRequest?: CueCueNumberSurfaceIDRequest;
}

export interface CueCueNumberSurfaceListRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberSurfaceNameOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberSurfaceNameRequest?: CueCueNumberSurfaceNameRequest;
}

export interface CueCueNumberSurfaceSizeRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberTempCueTargetIdRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberTempCueTargetNumberOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTempCueTargetNumberRequest?: CueCueNumberTempCueTargetNumberRequest;
}

export interface CueCueNumberTempDurationOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTempDurationRequest?: CueCueNumberTempDurationRequest;
}

export interface CueCueNumberTextOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextRequest?: CueCueNumberTextRequest;
}

export interface CueCueNumberTextFormatOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatRequest?: CueCueNumberTextFormatRequest;
}

export interface CueCueNumberTextFormatAlignmentOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatAlignmentRequest?: CueCueNumberTextFormatAlignmentRequest;
}

export interface CueCueNumberTextFormatBackgroundColorOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatBackgroundColorRequest?: CueCueNumberTextFormatBackgroundColorRequest;
}

export interface CueCueNumberTextFormatColorOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatColorRequest?: CueCueNumberTextFormatColorRequest;
}

export interface CueCueNumberTextFormatFontFamilyRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberTextFormatFontFamilyAndStyleOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatFontFamilyAndStyleRequest?: CueCueNumberTextFormatFontFamilyAndStyleRequest;
}

export interface CueCueNumberTextFormatFontNameOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatFontNameRequest?: CueCueNumberTextFormatFontNameRequest;
}

export interface CueCueNumberTextFormatFontSizeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatFontSizeRequest?: CueCueNumberTextFormatFontSizeRequest;
}

export interface CueCueNumberTextFormatFontStyleRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberTextFormatLineSpacingOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatLineSpacingRequest?: CueCueNumberTextFormatLineSpacingRequest;
}

export interface CueCueNumberTextFormatStrikethroughColorOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatStrikethroughColorRequest?: CueCueNumberTextFormatStrikethroughColorRequest;
}

export interface CueCueNumberTextFormatStrikethroughStyleOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatStrikethroughStyleRequest?: CueCueNumberTextFormatStrikethroughStyleRequest;
}

export interface CueCueNumberTextFormatUnderlineColorOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatUnderlineColorRequest?: CueCueNumberTextFormatUnderlineColorRequest;
}

export interface CueCueNumberTextFormatUnderlineStyleOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTextFormatUnderlineStyleRequest?: CueCueNumberTextFormatUnderlineStyleRequest;
}

export interface CueCueNumberTextOutputSizeRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberTimecodeFormatOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTimecodeFormatRequest?: CueCueNumberTimecodeFormatRequest;
}

export interface CueCueNumberTimecodeStringOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTimecodeStringRequest?: CueCueNumberTimecodeStringRequest;
}

export interface CueCueNumberTogglePauseRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberTranslationOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTranslationRequest?: CueCueNumberTranslationRequest;
}

export interface CueCueNumberTranslationXOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTranslationXRequest?: CueCueNumberTranslationXRequest;
}

export interface CueCueNumberTranslationYOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberTranslationYRequest?: CueCueNumberTranslationYRequest;
}

export interface CueCueNumberTypeRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberUdpStringOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberUdpStringRequest?: CueCueNumberUdpStringRequest;
}

export interface CueCueNumberUniqueIdRequest {
    cueNumber: string;
    expectResponse?: boolean;
}

export interface CueCueNumberUpdateLightCommandOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberUpdateLightCommandRequest?: CueCueNumberUpdateLightCommandRequest;
}

export interface CueCueNumberValuesForKeysOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberValuesForKeysRequest?: CueCueNumberValuesForKeysRequest;
}

export interface CueCueNumberValuesForKeysWithArgumentsOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberValuesForKeysWithArgumentsRequest?: CueCueNumberValuesForKeysWithArgumentsRequest;
}

export interface CueCueNumberWillFadeOperationRequest {
    cueNumber: string;
    expectResponse?: boolean;
    cueCueNumberWillFadeRequest?: CueCueNumberWillFadeRequest;
}

export interface CueListsShallowRequest {
    expectResponse?: boolean;
}

export interface CueListsUniqueIDsRequest {
    expectResponse?: boolean;
}

export interface CueListsUniqueIDsShallowRequest {
    expectResponse?: boolean;
}

export interface CueNumberChildrenShallowRequest {
    number: string;
    expectResponse?: boolean;
}

export interface CueNumberChildrenUniqueIDsRequest {
    number: string;
    expectResponse?: boolean;
}

export interface CueNumberChildrenUniqueIDsShallowRequest {
    number: string;
    expectResponse?: boolean;
}

export interface FontFamiliesAndStylesRequest {
    expectResponse?: boolean;
}

export interface FontNamesRequest {
    expectResponse?: boolean;
}

export interface LiveFadePreviewOperationRequest {
    expectResponse?: boolean;
    liveFadePreviewRequest?: LiveFadePreviewRequest;
}

export interface OverrideWindowOperationRequest {
    expectResponse?: boolean;
    overrideWindowRequest?: OverrideWindowRequest;
}

export interface OverridesArtNetEnabledOperationRequest {
    expectResponse?: boolean;
    overridesArtNetEnabledRequest?: OverridesArtNetEnabledRequest;
}

export interface OverridesMidiInputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesMidiInputEnabledRequest?: OverridesMidiInputEnabledRequest;
}

export interface OverridesMidiOutputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesMidiOutputEnabledRequest?: OverridesMidiOutputEnabledRequest;
}

export interface OverridesMscInputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesMscInputEnabledRequest?: OverridesMscInputEnabledRequest;
}

export interface OverridesMscOutputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesMscOutputEnabledRequest?: OverridesMscOutputEnabledRequest;
}

export interface OverridesOscInputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesOscInputEnabledRequest?: OverridesOscInputEnabledRequest;
}

export interface OverridesOscOutputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesOscOutputEnabledRequest?: OverridesOscOutputEnabledRequest;
}

export interface OverridesSysexInputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesSysexInputEnabledRequest?: OverridesSysexInputEnabledRequest;
}

export interface OverridesSysexOutputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesSysexOutputEnabledRequest?: OverridesSysexOutputEnabledRequest;
}

export interface OverridesTimecodeInputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesTimecodeInputEnabledRequest?: OverridesTimecodeInputEnabledRequest;
}

export interface OverridesTimecodeOutputEnabledOperationRequest {
    expectResponse?: boolean;
    overridesTimecodeOutputEnabledRequest?: OverridesTimecodeOutputEnabledRequest;
}

export interface OverridesToggleArtNetRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleMidiInputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleMidiOutputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleMscInputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleMscOutputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleOscInputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleOscOutputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleSysexInputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleSysexOutputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleTimecodeInputRequest {
    expectResponse?: boolean;
}

export interface OverridesToggleTimecodeOutputRequest {
    expectResponse?: boolean;
}

export interface ReplyFormatOperationRequest {
    expectResponse?: boolean;
    replyFormatRequest?: ReplyFormatRequest;
}

export interface RunningCuesShallowRequest {
    expectResponse?: boolean;
}

export interface RunningCuesUniqueIDsRequest {
    expectResponse?: boolean;
}

export interface RunningCuesUniqueIDsShallowRequest {
    expectResponse?: boolean;
}

export interface RunningOrPausedCuesShallowRequest {
    expectResponse?: boolean;
}

export interface RunningOrPausedCuesUniqueIDsRequest {
    expectResponse?: boolean;
}

export interface RunningOrPausedCuesUniqueIDsShallowRequest {
    expectResponse?: boolean;
}

export interface SelectedCuesShallowRequest {
    expectResponse?: boolean;
}

export interface SelectedCuesUniqueIDsRequest {
    expectResponse?: boolean;
}

export interface SelectedCuesUniqueIDsShallowRequest {
    expectResponse?: boolean;
}

export interface SettingsAudioMaxVolumeRequest {
    expectResponse?: boolean;
}

export interface SettingsAudioMinVolumeRequest {
    expectResponse?: boolean;
}

export interface SettingsAudioOutputChannelNamesRequest {
    expectResponse?: boolean;
}

export interface SettingsGeneralMinGoTimeOperationRequest {
    expectResponse?: boolean;
    settingsGeneralMinGoTimeRequest?: SettingsGeneralMinGoTimeRequest;
}

export interface SettingsMicOutputChannelNamesRequest {
    expectResponse?: boolean;
}

export interface SettingsVideoSurfacesRequest {
    expectResponse?: boolean;
}

export interface SettingsVideoSurfacesSurfaceIdRequest {
    surfaceID: string;
    expectResponse?: boolean;
}

export interface SettingsVideoSurfacesSurfaceIdScreenIndexControlPointRequest {
    surfaceID: string;
    screenIndex: string;
    expectResponse?: boolean;
    settingsVideoSurfacesSurfaceIDScreenIndexControlPointRequest?: SettingsVideoSurfacesSurfaceIDScreenIndexControlPointRequest;
}

export interface SettingsVideoSurfacesSurfaceIdScreenIndexEnableGridRequest {
    surfaceID: string;
    screenIndex: string;
    expectResponse?: boolean;
    settingsVideoSurfacesSurfaceIDScreenIndexEnableGridRequest?: SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridRequest;
}

export interface SettingsVideoSurfacesSurfaceIdScreenIndexEnableGuidesRequest {
    surfaceID: string;
    screenIndex: string;
    expectResponse?: boolean;
    settingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesRequest?: SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesRequest;
}

export interface SettingsVideoSurfacesSurfaceIdScreenIndexOriginRequest {
    surfaceID: string;
    screenIndex: string;
    expectResponse?: boolean;
    settingsVideoSurfacesSurfaceIDScreenIndexOriginRequest?: SettingsVideoSurfacesSurfaceIDScreenIndexOriginRequest;
}

export interface SettingsVideoSurfacesSurfaceIdScreenIndexResetControlPointsRequest {
    surfaceID: string;
    screenIndex: string;
    expectResponse?: boolean;
}

export interface TimecodeWindowOperationRequest {
    expectResponse?: boolean;
    timecodeWindowRequest?: TimecodeWindowRequest;
}

export interface ToggleAuditionWindowRequest {
    expectResponse?: boolean;
}

export interface ToggleLiveFadePreviewRequest {
    expectResponse?: boolean;
}

export interface ToggleOverrideWindowRequest {
    expectResponse?: boolean;
}

export interface ToggleTimecodeWindowRequest {
    expectResponse?: boolean;
}

export interface VersionRequest {
    expectResponse?: boolean;
}

export interface WorkingDirectoryOperationRequest {
    expectResponse?: boolean;
    workingDirectoryRequest?: WorkingDirectoryRequest;
}

export interface WorkspaceIdBasePathRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdConnectOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdConnectRequest?: WorkspaceIdConnectRequest;
}

export interface WorkspaceIdCueListsRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardClearRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardModeOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdDashboardModeRequest?: WorkspaceIdDashboardModeRequest;
}

export interface WorkspaceIdDashboardNewCueWithAllRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardNewCueWithChangesRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardNextModeRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardRecordAllToLatestRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardRecordAllToSelectedRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardRedoRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardRevertRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardSetLightOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdDashboardSetLightRequest?: WorkspaceIdDashboardSetLightRequest;
}

export interface WorkspaceIdDashboardUndoRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardUpdateLatestCueRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardUpdateOriginatingCuesRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDashboardUpdateSelectedCuesRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDeleteActiveRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDeleteCueNumberRequest {
    id: string;
    cueNumber: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDeleteIdCueIdRequest {
    id: string;
    cueId: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDeleteSelectedRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDisconnectRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdDoubleGoWindowRemainingRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdFullScreenOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdFullScreenRequest?: WorkspaceIdFullScreenRequest;
}

export interface WorkspaceIdGoOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdGoRequest?: WorkspaceIdGoRequest;
}

export interface WorkspaceIdGoCueNumberRequest {
    id: string;
    cueNumber: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdHardStopRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdLightDashboardOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdLightDashboardRequest?: WorkspaceIdLightDashboardRequest;
}

export interface WorkspaceIdMoveCueIdOperationRequest {
    id: string;
    cueId: string;
    expectResponse?: boolean;
    workspaceIdMoveCueIdRequest?: WorkspaceIdMoveCueIdRequest;
}

export interface WorkspaceIdNewOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdNewRequest?: WorkspaceIdNewRequest;
}

export interface WorkspaceIdPanicRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPanicInTimeOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdPanicInTimeRequest?: WorkspaceIdPanicInTimeRequest;
}

export interface WorkspaceIdPauseRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlaybackPositionCueNumberRequest {
    id: string;
    cueNumber: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlaybackPositionIdCueIdRequest {
    id: string;
    cueId: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlaybackPositionNextRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlaybackPositionNextSequenceRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlaybackPositionPreviousRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlaybackPositionPreviousSequenceRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlayheadCueNumberRequest {
    id: string;
    cueNumber: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlayheadIdCueIdRequest {
    id: string;
    cueId: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlayheadNextRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlayheadNextSequenceRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlayheadPreviousRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdPlayheadPreviousSequenceRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdRedoRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdRenumberOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdRenumberRequest?: WorkspaceIdRenumberRequest;
}

export interface WorkspaceIdResetRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdResumeRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdRunningCuesRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdRunningOrPausedCuesRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdSaveRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdSelectCueNumberRequest {
    id: string;
    cueNumber: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdSelectIdSelectIdRequest {
    id: string;
    selectId: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdSelectNextRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdSelectPreviousRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdSelectedCuesRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdSelectionIsPlayheadOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdSelectionIsPlayheadRequest?: WorkspaceIdSelectionIsPlayheadRequest;
}

export interface WorkspaceIdShowModeOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdShowModeRequest?: WorkspaceIdShowModeRequest;
}

export interface WorkspaceIdStopRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdThumpRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdToggleEditShowModeRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdToggleFullScreenRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdToggleLightDashboardRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdToggleSelectionIsPlayheadRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdUndoRequest {
    id: string;
    expectResponse?: boolean;
}

export interface WorkspaceIdUpdatesOperationRequest {
    id: string;
    expectResponse?: boolean;
    workspaceIdUpdatesRequest?: WorkspaceIdUpdatesRequest;
}

export interface WorkspacesRequest {
    expectResponse?: boolean;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Application methods QLab will respond to the following general commands: /alwaysReply {number} By default, QLab will only send a reply if the method generates a reply to send. However, if number is set to any non-zero number, QLab will send a reply for every OSC message it receives. Messages that would not normally generate a reply will generate one with a JSON string argument that contains: {     \"workspace_id\" : string,     \"address\": \"/invoked/osc/method\",     \"status\": string } The status string will be either ok or error. Note that the data field does not exist in this reply.
     */
    async alwaysReplyRaw(requestParameters: AlwaysReplyOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AlwaysReplyResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/alwaysReply`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AlwaysReplyRequestToJSON(requestParameters.alwaysReplyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlwaysReplyResponseFromJSON(jsonValue));
    }

    /**
     * Application methods QLab will respond to the following general commands: /alwaysReply {number} By default, QLab will only send a reply if the method generates a reply to send. However, if number is set to any non-zero number, QLab will send a reply for every OSC message it receives. Messages that would not normally generate a reply will generate one with a JSON string argument that contains: {     \"workspace_id\" : string,     \"address\": \"/invoked/osc/method\",     \"status\": string } The status string will be either ok or error. Note that the data field does not exist in this reply.
     */
    async alwaysReply(requestParameters: AlwaysReplyOperationRequest = {}, initOverrides?: RequestInit): Promise<AlwaysReplyResponse> {
        const response = await this.alwaysReplyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /auditionWindow {number} Show or hide the Audition Window. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current visibility of the Audition Window.
     */
    async auditionWindowRaw(requestParameters: AuditionWindowOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AuditionWindowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/auditionWindow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuditionWindowRequestToJSON(requestParameters.auditionWindowRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuditionWindowResponseFromJSON(jsonValue));
    }

    /**
     * /auditionWindow {number} Show or hide the Audition Window. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current visibility of the Audition Window.
     */
    async auditionWindow(requestParameters: AuditionWindowOperationRequest = {}, initOverrides?: RequestInit): Promise<AuditionWindowResponse> {
        const response = await this.auditionWindowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/actionElapsed Return the elapsed action (in seconds) of the specified cue.
     */
    async cueCueNumberActionElapsedRaw(requestParameters: CueCueNumberActionElapsedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberActionElapsedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberActionElapsed.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/actionElapsed`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberActionElapsedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/actionElapsed Return the elapsed action (in seconds) of the specified cue.
     */
    async cueCueNumberActionElapsed(requestParameters: CueCueNumberActionElapsedRequest, initOverrides?: RequestInit): Promise<CueCueNumberActionElapsedResponse> {
        const response = await this.cueCueNumberActionElapsedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/addSliceMarker {time} {play_count} Add a slice marker to the specified cue. If time is given, add the marker at that time. If not, add the marker at the current time of the cue. time can be any positive whole or decimal number. If play_count is given, set the play count of the new slice (the slice preceding the new marker) to play_count. If not, set the play count to 1. play_count can be any positive whole number, or -1 to set the slice to infinite loop. Slice markers are zero-indexed, meaning the first marker of a cue is marker 0.
     */
    async cueCueNumberAddSliceMarkerRaw(requestParameters: CueCueNumberAddSliceMarkerOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberAddSliceMarkerResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberAddSliceMarker.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/addSliceMarker`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberAddSliceMarkerRequestToJSON(requestParameters.cueCueNumberAddSliceMarkerRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberAddSliceMarkerResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/addSliceMarker {time} {play_count} Add a slice marker to the specified cue. If time is given, add the marker at that time. If not, add the marker at the current time of the cue. time can be any positive whole or decimal number. If play_count is given, set the play count of the new slice (the slice preceding the new marker) to play_count. If not, set the play count to 1. play_count can be any positive whole number, or -1 to set the slice to infinite loop. Slice markers are zero-indexed, meaning the first marker of a cue is marker 0.
     */
    async cueCueNumberAddSliceMarker(requestParameters: CueCueNumberAddSliceMarkerOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberAddSliceMarkerResponse> {
        const response = await this.cueCueNumberAddSliceMarkerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/allowsEditingDuration Return true if the specified cue has an editable duration, such as an Audio, Video, or Fade cue.
     */
    async cueCueNumberAllowsEditingDurationRaw(requestParameters: CueCueNumberAllowsEditingDurationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberAllowsEditingDurationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberAllowsEditingDuration.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/allowsEditingDuration`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberAllowsEditingDurationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/allowsEditingDuration Return true if the specified cue has an editable duration, such as an Audio, Video, or Fade cue.
     */
    async cueCueNumberAllowsEditingDuration(requestParameters: CueCueNumberAllowsEditingDurationRequest, initOverrides?: RequestInit): Promise<CueCueNumberAllowsEditingDurationResponse> {
        const response = await this.cueCueNumberAllowsEditingDurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/alwaysCollate {number} Get or set the state of the Always collate checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Always collate specified cue.
     */
    async cueCueNumberAlwaysCollateRaw(requestParameters: CueCueNumberAlwaysCollateOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberAlwaysCollateResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberAlwaysCollate.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/alwaysCollate`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberAlwaysCollateRequestToJSON(requestParameters.cueCueNumberAlwaysCollateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberAlwaysCollateResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/alwaysCollate {number} Get or set the state of the Always collate checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Always collate specified cue.
     */
    async cueCueNumberAlwaysCollate(requestParameters: CueCueNumberAlwaysCollateOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberAlwaysCollateResponse> {
        const response = await this.cueCueNumberAlwaysCollateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/armed {number} Get or set the armed state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the armed state of the specified cue.
     */
    async cueCueNumberArmedRaw(requestParameters: CueCueNumberArmedOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberArmedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberArmed.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/armed`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberArmedRequestToJSON(requestParameters.cueCueNumberArmedRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberArmedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/armed {number} Get or set the armed state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the armed state of the specified cue.
     */
    async cueCueNumberArmed(requestParameters: CueCueNumberArmedOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberArmedResponse> {
        const response = await this.cueCueNumberArmedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/autoLoad {number} Get or set the auto-load state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the auto-load state of the specified cue.
     */
    async cueCueNumberAutoLoadRaw(requestParameters: CueCueNumberAutoLoadOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberAutoLoadResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberAutoLoad.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/autoLoad`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberAutoLoadRequestToJSON(requestParameters.cueCueNumberAutoLoadRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberAutoLoadResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/autoLoad {number} Get or set the auto-load state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the auto-load state of the specified cue.
     */
    async cueCueNumberAutoLoad(requestParameters: CueCueNumberAutoLoadOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberAutoLoadResponse> {
        const response = await this.cueCueNumberAutoLoadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/byte1 {number} If number is given, set byte 1 of the MIDI message of the specified cue to number. If not, return byte 1 of the MIDI message of the specified cue. number must be a whole number from 0 to 127.
     */
    async cueCueNumberByte1Raw(requestParameters: CueCueNumberByte1OperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberByte1Response>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberByte1.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/byte1`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberByte1RequestToJSON(requestParameters.cueCueNumberByte1Request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberByte1ResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/byte1 {number} If number is given, set byte 1 of the MIDI message of the specified cue to number. If not, return byte 1 of the MIDI message of the specified cue. number must be a whole number from 0 to 127.
     */
    async cueCueNumberByte1(requestParameters: CueCueNumberByte1OperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberByte1Response> {
        const response = await this.cueCueNumberByte1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/byte2 {number} If number is given, set byte 2 of the MIDI message of the specified cue to number. If not, return byte 2 of the MIDI message of the specified cue. number must be a whole number from 0 to 127.
     */
    async cueCueNumberByte2Raw(requestParameters: CueCueNumberByte2OperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberByte2Response>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberByte2.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/byte2`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberByte2RequestToJSON(requestParameters.cueCueNumberByte2Request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberByte2ResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/byte2 {number} If number is given, set byte 2 of the MIDI message of the specified cue to number. If not, return byte 2 of the MIDI message of the specified cue. number must be a whole number from 0 to 127.
     */
    async cueCueNumberByte2(requestParameters: CueCueNumberByte2OperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberByte2Response> {
        const response = await this.cueCueNumberByte2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/byteCombo {number} If number is given, set both bytes of the MIDI message of the specified cue based on number. If not, return the value of bytes 1 and 2 (as a single number) of the MIDI message of the specified cue. number must be a whole number from 0 to 16383.
     */
    async cueCueNumberByteComboRaw(requestParameters: CueCueNumberByteComboOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberByteComboResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberByteCombo.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/byteCombo`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberByteComboRequestToJSON(requestParameters.cueCueNumberByteComboRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberByteComboResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/byteCombo {number} If number is given, set both bytes of the MIDI message of the specified cue based on number. If not, return the value of bytes 1 and 2 (as a single number) of the MIDI message of the specified cue. number must be a whole number from 0 to 16383.
     */
    async cueCueNumberByteCombo(requestParameters: CueCueNumberByteComboOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberByteComboResponse> {
        const response = await this.cueCueNumberByteComboRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/cameraPatch If number is given, set the camera patch of the specified cue. If not, return the camera patch of the specified cue. number must be a whole number from 1 to 8.
     */
    async cueCueNumberCameraPatchRaw(requestParameters: CueCueNumberCameraPatchRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCameraPatchResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCameraPatch.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/cameraPatch`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCameraPatchResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/cameraPatch If number is given, set the camera patch of the specified cue. If not, return the camera patch of the specified cue. number must be a whole number from 1 to 8.
     */
    async cueCueNumberCameraPatch(requestParameters: CueCueNumberCameraPatchRequest, initOverrides?: RequestInit): Promise<CueCueNumberCameraPatchResponse> {
        const response = await this.cueCueNumberCameraPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/cartColumns /cue/{cue_number}/cartRows Read-only; if the specified cue is a cart, these messages return the number of rows or columns in the cart.
     */
    async cueCueNumberCartColumnsRaw(requestParameters: CueCueNumberCartColumnsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCartColumnsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCartColumns.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/cartColumns`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCartColumnsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/cartColumns /cue/{cue_number}/cartRows Read-only; if the specified cue is a cart, these messages return the number of rows or columns in the cart.
     */
    async cueCueNumberCartColumns(requestParameters: CueCueNumberCartColumnsRequest, initOverrides?: RequestInit): Promise<CueCueNumberCartColumnsResponse> {
        const response = await this.cueCueNumberCartColumnsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/cartPosition Return an array with the row and column numbers for the specified cues position within a cart. A cue that is not contained within a cart will return [0,0].
     */
    async cueCueNumberCartPositionRaw(requestParameters: CueCueNumberCartPositionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCartPositionResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCartPosition.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/cartPosition`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCartPositionResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/cartPosition Return an array with the row and column numbers for the specified cues position within a cart. A cue that is not contained within a cart will return [0,0].
     */
    async cueCueNumberCartPosition(requestParameters: CueCueNumberCartPositionRequest, initOverrides?: RequestInit): Promise<CueCueNumberCartPositionResponse> {
        const response = await this.cueCueNumberCartPositionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/cartColumns /cue/{cue_number}/cartRows Read-only; if the specified cue is a cart, these messages return the number of rows or columns in the cart.
     */
    async cueCueNumberCartRowsRaw(requestParameters: CueCueNumberCartRowsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCartRowsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCartRows.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/cartRows`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCartRowsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/cartColumns /cue/{cue_number}/cartRows Read-only; if the specified cue is a cart, these messages return the number of rows or columns in the cart.
     */
    async cueCueNumberCartRows(requestParameters: CueCueNumberCartRowsRequest, initOverrides?: RequestInit): Promise<CueCueNumberCartRowsResponse> {
        const response = await this.cueCueNumberCartRowsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/channel {number} If number is given, set the MIDI channel of the specified cue to number. If not, return the MIDI channel of the specified cue. number must be a whole number from 1 to 16.
     */
    async cueCueNumberChannelRaw(requestParameters: CueCueNumberChannelOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberChannelResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/channel`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberChannelRequestToJSON(requestParameters.cueCueNumberChannelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberChannelResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/channel {number} If number is given, set the MIDI channel of the specified cue to number. If not, return the MIDI channel of the specified cue. number must be a whole number from 1 to 16.
     */
    async cueCueNumberChannel(requestParameters: CueCueNumberChannelOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberChannelResponse> {
        const response = await this.cueCueNumberChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/channelOffset Read-only; return the input channel offset of the specified cue, as set in the Audio Levels tab of the inspector.
     */
    async cueCueNumberChannelOffsetRaw(requestParameters: CueCueNumberChannelOffsetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberChannelOffsetResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberChannelOffset.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/channelOffset`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberChannelOffsetResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/channelOffset Read-only; return the input channel offset of the specified cue, as set in the Audio Levels tab of the inspector.
     */
    async cueCueNumberChannelOffset(requestParameters: CueCueNumberChannelOffsetRequest, initOverrides?: RequestInit): Promise<CueCueNumberChannelOffsetResponse> {
        const response = await this.cueCueNumberChannelOffsetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/channels {number} If number is given, set the number of input channels used by the specified cue. If not, return the number of input channels used by the specified cue. number can be any positive whole number.
     */
    async cueCueNumberChannelsRaw(requestParameters: CueCueNumberChannelsOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberChannelsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberChannels.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/channels`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberChannelsRequestToJSON(requestParameters.cueCueNumberChannelsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberChannelsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/channels {number} If number is given, set the number of input channels used by the specified cue. If not, return the number of input channels used by the specified cue. number can be any positive whole number.
     */
    async cueCueNumberChannels(requestParameters: CueCueNumberChannelsOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberChannelsResponse> {
        const response = await this.cueCueNumberChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/children Read-only; return a list of the cues contained within the specified Group, list, or cart. Returns the same data as the workspace /cueLists method.
     */
    async cueCueNumberChildrenRaw(requestParameters: CueCueNumberChildrenRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberChildrenResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberChildren.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/children`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberChildrenResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/children Read-only; return a list of the cues contained within the specified Group, list, or cart. Returns the same data as the workspace /cueLists method.
     */
    async cueCueNumberChildren(requestParameters: CueCueNumberChildrenRequest, initOverrides?: RequestInit): Promise<CueCueNumberChildrenResponse> {
        const response = await this.cueCueNumberChildrenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/collateAndStart Collate and start the specified cue.
     */
    async cueCueNumberCollateAndStartRaw(requestParameters: CueCueNumberCollateAndStartRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCollateAndStartResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCollateAndStart.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/collateAndStart`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCollateAndStartResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/collateAndStart Collate and start the specified cue.
     */
    async cueCueNumberCollateAndStart(requestParameters: CueCueNumberCollateAndStartRequest, initOverrides?: RequestInit): Promise<CueCueNumberCollateAndStartResponse> {
        const response = await this.cueCueNumberCollateAndStartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/colorName {string} If string is given, set the color of the specified cue to string. If not, return the pre-wait of the specified cue. Valid colors are none, red, orange, green, blue, and purple. Certain other colors may also be valid
     */
    async cueCueNumberColorNameRaw(requestParameters: CueCueNumberColorNameOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberColorNameResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberColorName.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/colorName`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberColorNameRequestToJSON(requestParameters.cueCueNumberColorNameRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberColorNameResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/colorName {string} If string is given, set the color of the specified cue to string. If not, return the pre-wait of the specified cue. Valid colors are none, red, orange, green, blue, and purple. Certain other colors may also be valid
     */
    async cueCueNumberColorName(requestParameters: CueCueNumberColorNameOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberColorNameResponse> {
        const response = await this.cueCueNumberColorNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/command {number} If number is given, set the MSC command of the specified cue to number. If not, return the MSC command of the specified cue. number must be a whole number from 0 to 127, but only the following values are meaningful: 1  - GO 2  - STOP 3  - RESUME 4  - TIMED_GO 5  - LOAD 6  - SET 7  - FIRE 8  - ALL_OFF 9  - RESTORE 10 - RESET 11 - GO_OFF 16 - GO/JAM_CLOCK 17 - STANDBY_+ 18 - STANDBY_- 19 - SEQUENCE_+ 20 - SEQUENCE_- 21 - START_CLOCK 22 - STOP_CLOCK 23 - ZERO_CLOCK 24 - SET_CLOCK 25 - MTC_CHASE_ON 26 - MTC_CHASE_OFF 27 - OPEN_CUE_LIST 28 - CLOSE_CUE_LIST 29 - OPEN_CUE_PATH 30 - CLOSE_CUE_PATH
     */
    async cueCueNumberCommandRaw(requestParameters: CueCueNumberCommandOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCommandResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCommand.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/command`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberCommandRequestToJSON(requestParameters.cueCueNumberCommandRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCommandResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/command {number} If number is given, set the MSC command of the specified cue to number. If not, return the MSC command of the specified cue. number must be a whole number from 0 to 127, but only the following values are meaningful: 1  - GO 2  - STOP 3  - RESUME 4  - TIMED_GO 5  - LOAD 6  - SET 7  - FIRE 8  - ALL_OFF 9  - RESTORE 10 - RESET 11 - GO_OFF 16 - GO/JAM_CLOCK 17 - STANDBY_+ 18 - STANDBY_- 19 - SEQUENCE_+ 20 - SEQUENCE_- 21 - START_CLOCK 22 - STOP_CLOCK 23 - ZERO_CLOCK 24 - SET_CLOCK 25 - MTC_CHASE_ON 26 - MTC_CHASE_OFF 27 - OPEN_CUE_LIST 28 - CLOSE_CUE_LIST 29 - OPEN_CUE_PATH 30 - CLOSE_CUE_PATH
     */
    async cueCueNumberCommand(requestParameters: CueCueNumberCommandOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberCommandResponse> {
        const response = await this.cueCueNumberCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/commandFormat {number} If number is given, set the MSC command format of the specified cue to number. If not, return the MSC command format of the specified cue. number must be a whole number from 0 to 127, but only the following values are meaningful: 127 - All Types 1   - Lighting (General) 2   - Moving Lights 3   - Color Changers 4   - Strobes 5   - Lasers 6   - Chasers 16  - Sound (General) 17  - Music 18  - CD Players 19  - EPROM Playback 20  - Audio Tape Machines 21  - Intercoms 22  - Amplifiers 23  - Audio Effects Devices 24  - Equalizers 32  - Machinery (General) 33  - Rigging 34  - Flys 35  - Lifts 36  - Turntables 37  - Trusses 38  - Robots 39  - Animation 40  - Floats 41  - Breakaways 42  - Barges 48  - Video (General) 49  - Video Tape Machines 50  - Video Cassette Machines 51  - Video Disc Players 52  - Video Switchers 53  - Video Effects 54  - Video Character Generators 55  - Video Still Stores 56  - Video Monitors 64  - Projection (General) 65  - Film Projectors 66  - Slide Projectors 67  - Video Projectors 68  - Dissolvers 69  - Shutter Controls 80  - Process Control (General) 81  - Hydraulic Oil 82  - H2O 83  - CO2 84  - Compressed Air 85  - Natural Gas 86  - Fog 87  - Smoke 88  - Cracked Haze 96  - Pyrotechnics (General) 97  - Fireworks 98  - Explosions 99  - Flame 100 - Smoke Pots
     */
    async cueCueNumberCommandFormatRaw(requestParameters: CueCueNumberCommandFormatOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCommandFormatResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCommandFormat.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/commandFormat`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberCommandFormatRequestToJSON(requestParameters.cueCueNumberCommandFormatRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCommandFormatResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/commandFormat {number} If number is given, set the MSC command format of the specified cue to number. If not, return the MSC command format of the specified cue. number must be a whole number from 0 to 127, but only the following values are meaningful: 127 - All Types 1   - Lighting (General) 2   - Moving Lights 3   - Color Changers 4   - Strobes 5   - Lasers 6   - Chasers 16  - Sound (General) 17  - Music 18  - CD Players 19  - EPROM Playback 20  - Audio Tape Machines 21  - Intercoms 22  - Amplifiers 23  - Audio Effects Devices 24  - Equalizers 32  - Machinery (General) 33  - Rigging 34  - Flys 35  - Lifts 36  - Turntables 37  - Trusses 38  - Robots 39  - Animation 40  - Floats 41  - Breakaways 42  - Barges 48  - Video (General) 49  - Video Tape Machines 50  - Video Cassette Machines 51  - Video Disc Players 52  - Video Switchers 53  - Video Effects 54  - Video Character Generators 55  - Video Still Stores 56  - Video Monitors 64  - Projection (General) 65  - Film Projectors 66  - Slide Projectors 67  - Video Projectors 68  - Dissolvers 69  - Shutter Controls 80  - Process Control (General) 81  - Hydraulic Oil 82  - H2O 83  - CO2 84  - Compressed Air 85  - Natural Gas 86  - Fog 87  - Smoke 88  - Cracked Haze 96  - Pyrotechnics (General) 97  - Fireworks 98  - Explosions 99  - Flame 100 - Smoke Pots
     */
    async cueCueNumberCommandFormat(requestParameters: CueCueNumberCommandFormatOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberCommandFormatResponse> {
        const response = await this.cueCueNumberCommandFormatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/compileSource Compile the script of the specified cue.
     */
    async cueCueNumberCompileSourceRaw(requestParameters: CueCueNumberCompileSourceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCompileSourceResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCompileSource.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/compileSource`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCompileSourceResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/compileSource Compile the script of the specified cue.
     */
    async cueCueNumberCompileSource(requestParameters: CueCueNumberCompileSourceRequest, initOverrides?: RequestInit): Promise<CueCueNumberCompileSourceResponse> {
        const response = await this.cueCueNumberCompileSourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/continueMode {number} If number is given, set the continue mode of the specified cue to number. If not, return the continue mode of the specified cue. Valid continue modes are: 0 - NO CONTINUE 1 - AUTO CONTINUE 2 - AUTO FOLLOW
     */
    async cueCueNumberContinueModeRaw(requestParameters: CueCueNumberContinueModeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberContinueModeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberContinueMode.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/continueMode`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberContinueModeRequestToJSON(requestParameters.cueCueNumberContinueModeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberContinueModeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/continueMode {number} If number is given, set the continue mode of the specified cue to number. If not, return the continue mode of the specified cue. Valid continue modes are: 0 - NO CONTINUE 1 - AUTO CONTINUE 2 - AUTO FOLLOW
     */
    async cueCueNumberContinueMode(requestParameters: CueCueNumberContinueModeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberContinueModeResponse> {
        const response = await this.cueCueNumberContinueModeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/controlNumber {number} If number is given, set the MSC control number of the specified cue to number. If not, return the MSC control number of the specified cue. number must be a whole number from 0 to 16383.
     */
    async cueCueNumberControlNumberRaw(requestParameters: CueCueNumberControlNumberOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberControlNumberResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberControlNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/controlNumber`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberControlNumberRequestToJSON(requestParameters.cueCueNumberControlNumberRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberControlNumberResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/controlNumber {number} If number is given, set the MSC control number of the specified cue to number. If not, return the MSC control number of the specified cue. number must be a whole number from 0 to 16383.
     */
    async cueCueNumberControlNumber(requestParameters: CueCueNumberControlNumberOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberControlNumberResponse> {
        const response = await this.cueCueNumberControlNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/controlValue {number} If number is given, set the MSC control value of the specified cue to number. If not, return the MSC control value of the specified cue. number must be a whole number from 0 to 16383.
     */
    async cueCueNumberControlValueRaw(requestParameters: CueCueNumberControlValueOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberControlValueResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberControlValue.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/controlValue`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberControlValueRequestToJSON(requestParameters.cueCueNumberControlValueRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberControlValueResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/controlValue {number} If number is given, set the MSC control value of the specified cue to number. If not, return the MSC control value of the specified cue. number must be a whole number from 0 to 16383.
     */
    async cueCueNumberControlValue(requestParameters: CueCueNumberControlValueOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberControlValueResponse> {
        const response = await this.cueCueNumberControlValueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/cueSize Read-only; return the natural size of the cues video frame: {     \"width\": number,     \"height\": number }
     */
    async cueCueNumberCueSizeRaw(requestParameters: CueCueNumberCueSizeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCueSizeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCueSize.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/cueSize`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCueSizeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/cueSize Read-only; return the natural size of the cues video frame: {     \"width\": number,     \"height\": number }
     */
    async cueCueNumberCueSize(requestParameters: CueCueNumberCueSizeRequest, initOverrides?: RequestInit): Promise<CueCueNumberCueSizeResponse> {
        const response = await this.cueCueNumberCueSizeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/cueTargetId {string} If string is given, and if the specified cue can have cue targets, set the target of the specified cue to string. If not, return the cue ID of the target of the specified cue.
     */
    async cueCueNumberCueTargetIdRaw(requestParameters: CueCueNumberCueTargetIdOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCueTargetIdResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCueTargetId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/cueTargetId`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberCueTargetIdRequestToJSON(requestParameters.cueCueNumberCueTargetIdRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCueTargetIdResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/cueTargetId {string} If string is given, and if the specified cue can have cue targets, set the target of the specified cue to string. If not, return the cue ID of the target of the specified cue.
     */
    async cueCueNumberCueTargetId(requestParameters: CueCueNumberCueTargetIdOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberCueTargetIdResponse> {
        const response = await this.cueCueNumberCueTargetIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/cueTargetNumber {string} If string is given, and if the specified cue can have cue targets, set the target of the specified cue to string. If not, return the cue number of the target of the specified cue.
     */
    async cueCueNumberCueTargetNumberRaw(requestParameters: CueCueNumberCueTargetNumberOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCueTargetNumberResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCueTargetNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/cueTargetNumber`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberCueTargetNumberRequestToJSON(requestParameters.cueCueNumberCueTargetNumberRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCueTargetNumberResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/cueTargetNumber {string} If string is given, and if the specified cue can have cue targets, set the target of the specified cue to string. If not, return the cue number of the target of the specified cue.
     */
    async cueCueNumberCueTargetNumber(requestParameters: CueCueNumberCueTargetNumberOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberCueTargetNumberResponse> {
        const response = await this.cueCueNumberCueTargetNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/currentCueTarget Read-only; return the cue ID of the current target of the specified cue.
     */
    async cueCueNumberCurrentCueTargetRaw(requestParameters: CueCueNumberCurrentCueTargetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCurrentCueTargetResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCurrentCueTarget.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/currentCueTarget`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCurrentCueTargetResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/currentCueTarget Read-only; return the cue ID of the current target of the specified cue.
     */
    async cueCueNumberCurrentCueTarget(requestParameters: CueCueNumberCurrentCueTargetRequest, initOverrides?: RequestInit): Promise<CueCueNumberCurrentCueTargetResponse> {
        const response = await this.cueCueNumberCurrentCueTargetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/currentDuration Read-only; return the current duration of the specified cue.
     */
    async cueCueNumberCurrentDurationRaw(requestParameters: CueCueNumberCurrentDurationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCurrentDurationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCurrentDuration.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/currentDuration`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCurrentDurationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/currentDuration Read-only; return the current duration of the specified cue.
     */
    async cueCueNumberCurrentDuration(requestParameters: CueCueNumberCurrentDurationRequest, initOverrides?: RequestInit): Promise<CueCueNumberCurrentDurationResponse> {
        const response = await this.cueCueNumberCurrentDurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/currentFileTime Read-only; if the specified cue has a file target, return the current playback time of the target file in seconds. If the cue is not running, thats 0. If the cue has been playing for ten and a half seconds, and the playback rate of the cue is 1.0, then the currentFileTime is 10.5.
     */
    async cueCueNumberCurrentFileTimeRaw(requestParameters: CueCueNumberCurrentFileTimeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCurrentFileTimeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCurrentFileTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/currentFileTime`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCurrentFileTimeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/currentFileTime Read-only; if the specified cue has a file target, return the current playback time of the target file in seconds. If the cue is not running, thats 0. If the cue has been playing for ten and a half seconds, and the playback rate of the cue is 1.0, then the currentFileTime is 10.5.
     */
    async cueCueNumberCurrentFileTime(requestParameters: CueCueNumberCurrentFileTimeRequest, initOverrides?: RequestInit): Promise<CueCueNumberCurrentFileTimeResponse> {
        const response = await this.cueCueNumberCurrentFileTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/customString {string} If string is given, set the OSC message of the specified cue to string. If not, return the OSC message of the specified cue.
     */
    async cueCueNumberCustomStringRaw(requestParameters: CueCueNumberCustomStringOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberCustomStringResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberCustomString.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/customString`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberCustomStringRequestToJSON(requestParameters.cueCueNumberCustomStringRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberCustomStringResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/customString {string} If string is given, set the OSC message of the specified cue to string. If not, return the OSC message of the specified cue.
     */
    async cueCueNumberCustomString(requestParameters: CueCueNumberCustomStringOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberCustomStringResponse> {
        const response = await this.cueCueNumberCustomStringRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/defaultName Return the default name of the specified cue.
     */
    async cueCueNumberDefaultNameRaw(requestParameters: CueCueNumberDefaultNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDefaultNameResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDefaultName.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/defaultName`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDefaultNameResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/defaultName Return the default name of the specified cue.
     */
    async cueCueNumberDefaultName(requestParameters: CueCueNumberDefaultNameRequest, initOverrides?: RequestInit): Promise<CueCueNumberDefaultNameResponse> {
        const response = await this.cueCueNumberDefaultNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/deleteSliceMarker {index} /cue/{cue_number}/deleteSliceMarker/{index} Delete slice marker index of the specified cue. index can be zero or any positive whole number.
     */
    async cueCueNumberDeleteSliceMarkerRaw(requestParameters: CueCueNumberDeleteSliceMarkerOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDeleteSliceMarkerResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDeleteSliceMarker.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/deleteSliceMarker`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDeleteSliceMarkerRequestToJSON(requestParameters.cueCueNumberDeleteSliceMarkerRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDeleteSliceMarkerResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/deleteSliceMarker {index} /cue/{cue_number}/deleteSliceMarker/{index} Delete slice marker index of the specified cue. index can be zero or any positive whole number.
     */
    async cueCueNumberDeleteSliceMarker(requestParameters: CueCueNumberDeleteSliceMarkerOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDeleteSliceMarkerResponse> {
        const response = await this.cueCueNumberDeleteSliceMarkerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/deleteSliceMarker {index} /cue/{cue_number}/deleteSliceMarker/{index} Delete slice marker index of the specified cue. index can be zero or any positive whole number.
     */
    async cueCueNumberDeleteSliceMarkerIndexRaw(requestParameters: CueCueNumberDeleteSliceMarkerIndexRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDeleteSliceMarkerIndexResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDeleteSliceMarkerIndex.');
        }

        if (requestParameters.index === null || requestParameters.index === undefined) {
            throw new runtime.RequiredError('index','Required parameter requestParameters.index was null or undefined when calling cueCueNumberDeleteSliceMarkerIndex.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/deleteSliceMarker/{index}`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"index"}}`, encodeURIComponent(String(requestParameters.index))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDeleteSliceMarkerIndexResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/deleteSliceMarker {index} /cue/{cue_number}/deleteSliceMarker/{index} Delete slice marker index of the specified cue. index can be zero or any positive whole number.
     */
    async cueCueNumberDeleteSliceMarkerIndex(requestParameters: CueCueNumberDeleteSliceMarkerIndexRequest, initOverrides?: RequestInit): Promise<CueCueNumberDeleteSliceMarkerIndexResponse> {
        const response = await this.cueCueNumberDeleteSliceMarkerIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/deleteSliceMarkers Delete all slice markers of the specified cue.
     */
    async cueCueNumberDeleteSliceMarkersRaw(requestParameters: CueCueNumberDeleteSliceMarkersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDeleteSliceMarkersResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDeleteSliceMarkers.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/deleteSliceMarkers`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDeleteSliceMarkersResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/deleteSliceMarkers Delete all slice markers of the specified cue.
     */
    async cueCueNumberDeleteSliceMarkers(requestParameters: CueCueNumberDeleteSliceMarkersRequest, initOverrides?: RequestInit): Promise<CueCueNumberDeleteSliceMarkersResponse> {
        const response = await this.cueCueNumberDeleteSliceMarkersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/deviceID {number} If number is given, set the outgoing MSC device ID of the specified cue to number. If not, return the outgoing MSC device ID of the specified cue. number must be a whole number from 0 to 127.
     */
    async cueCueNumberDeviceIdRaw(requestParameters: CueCueNumberDeviceIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDeviceIDResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDeviceId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/deviceID`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDeviceIDRequestToJSON(requestParameters.cueCueNumberDeviceIDRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDeviceIDResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/deviceID {number} If number is given, set the outgoing MSC device ID of the specified cue to number. If not, return the outgoing MSC device ID of the specified cue. number must be a whole number from 0 to 127.
     */
    async cueCueNumberDeviceId(requestParameters: CueCueNumberDeviceIdRequest, initOverrides?: RequestInit): Promise<CueCueNumberDeviceIDResponse> {
        const response = await this.cueCueNumberDeviceIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/displayName Return the display name of the specified cue.
     */
    async cueCueNumberDisplayNameRaw(requestParameters: CueCueNumberDisplayNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDisplayNameResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDisplayName.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/displayName`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDisplayNameResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/displayName Return the display name of the specified cue.
     */
    async cueCueNumberDisplayName(requestParameters: CueCueNumberDisplayNameRequest, initOverrides?: RequestInit): Promise<CueCueNumberDisplayNameResponse> {
        const response = await this.cueCueNumberDisplayNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/doEffect {number} Get or set the state of the Apply effects checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Apply effects checkbox of the specified cue.
     */
    async cueCueNumberDoEffectRaw(requestParameters: CueCueNumberDoEffectOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDoEffectResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDoEffect.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/doEffect`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDoEffectRequestToJSON(requestParameters.cueCueNumberDoEffectRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDoEffectResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/doEffect {number} Get or set the state of the Apply effects checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Apply effects checkbox of the specified cue.
     */
    async cueCueNumberDoEffect(requestParameters: CueCueNumberDoEffectOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDoEffectResponse> {
        const response = await this.cueCueNumberDoEffectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/doFade {number} Get or set the state of the MIDI fade checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the MIDI fade checkbox of the specified cue.
     */
    async cueCueNumberDoFadeRaw(requestParameters: CueCueNumberDoFadeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDoFadeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDoFade.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/doFade`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDoFadeRequestToJSON(requestParameters.cueCueNumberDoFadeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDoFadeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/doFade {number} Get or set the state of the MIDI fade checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the MIDI fade checkbox of the specified cue.
     */
    async cueCueNumberDoFade(requestParameters: CueCueNumberDoFadeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDoFadeResponse> {
        const response = await this.cueCueNumberDoFadeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoOpacityRaw(requestParameters: CueCueNumberDoOpacityOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDoOpacityResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDoOpacity.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/doOpacity`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDoOpacityRequestToJSON(requestParameters.cueCueNumberDoOpacityRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDoOpacityResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoOpacity(requestParameters: CueCueNumberDoOpacityOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDoOpacityResponse> {
        const response = await this.cueCueNumberDoOpacityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/doPitchShift {number} Get or set the state of the pitch shift checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the pitch shift checkbox of the specified cue.
     */
    async cueCueNumberDoPitchShiftRaw(requestParameters: CueCueNumberDoPitchShiftOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDoPitchShiftResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDoPitchShift.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/doPitchShift`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDoPitchShiftRequestToJSON(requestParameters.cueCueNumberDoPitchShiftRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDoPitchShiftResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/doPitchShift {number} Get or set the state of the pitch shift checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the pitch shift checkbox of the specified cue.
     */
    async cueCueNumberDoPitchShift(requestParameters: CueCueNumberDoPitchShiftOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDoPitchShiftResponse> {
        const response = await this.cueCueNumberDoPitchShiftRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoRateRaw(requestParameters: CueCueNumberDoRateOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDoRateResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDoRate.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/doRate`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDoRateRequestToJSON(requestParameters.cueCueNumberDoRateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDoRateResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoRate(requestParameters: CueCueNumberDoRateOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDoRateResponse> {
        const response = await this.cueCueNumberDoRateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoRotationRaw(requestParameters: CueCueNumberDoRotationOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDoRotationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDoRotation.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/doRotation`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDoRotationRequestToJSON(requestParameters.cueCueNumberDoRotationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDoRotationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoRotation(requestParameters: CueCueNumberDoRotationOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDoRotationResponse> {
        const response = await this.cueCueNumberDoRotationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoScaleRaw(requestParameters: CueCueNumberDoScaleOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDoScaleResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDoScale.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/doScale`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDoScaleRequestToJSON(requestParameters.cueCueNumberDoScaleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDoScaleResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoScale(requestParameters: CueCueNumberDoScaleOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDoScaleResponse> {
        const response = await this.cueCueNumberDoScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoTranslationRaw(requestParameters: CueCueNumberDoTranslationOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDoTranslationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDoTranslation.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/doTranslation`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDoTranslationRequestToJSON(requestParameters.cueCueNumberDoTranslationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDoTranslationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/doOpacity {number} /cue/{cue_number}/doRate {number} /cue/{cue_number}/doRotation {number} /cue/{cue_number}/doScale {number} /cue/{cue_number}/doTranslation {number} Get or set the state of the geometry parameter checkboxes of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the relevant geometry parameter checkbox of the specified cue.
     */
    async cueCueNumberDoTranslation(requestParameters: CueCueNumberDoTranslationOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDoTranslationResponse> {
        const response = await this.cueCueNumberDoTranslationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/duckLevel {number} If number is given, set the duck (or boost) level of the specified cue to number. If not, return the duck or boost level of the specified cue.
     */
    async cueCueNumberDuckLevelRaw(requestParameters: CueCueNumberDuckLevelOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDuckLevelResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDuckLevel.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/duckLevel`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDuckLevelRequestToJSON(requestParameters.cueCueNumberDuckLevelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDuckLevelResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/duckLevel {number} If number is given, set the duck (or boost) level of the specified cue to number. If not, return the duck or boost level of the specified cue.
     */
    async cueCueNumberDuckLevel(requestParameters: CueCueNumberDuckLevelOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDuckLevelResponse> {
        const response = await this.cueCueNumberDuckLevelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/duckOthers {number} Get or set the state of the Duck audio of other cues checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Duck audio of other cues checkbox of the specified cue.
     */
    async cueCueNumberDuckOthersRaw(requestParameters: CueCueNumberDuckOthersOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDuckOthersResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDuckOthers.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/duckOthers`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDuckOthersRequestToJSON(requestParameters.cueCueNumberDuckOthersRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDuckOthersResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/duckOthers {number} Get or set the state of the Duck audio of other cues checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Duck audio of other cues checkbox of the specified cue.
     */
    async cueCueNumberDuckOthers(requestParameters: CueCueNumberDuckOthersOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDuckOthersResponse> {
        const response = await this.cueCueNumberDuckOthersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/duckTime {number} If number is given, set the Duck audio of other cues time of the specified cue to number. If not, return the Duck audio of other cues time of the specified cue.
     */
    async cueCueNumberDuckTimeRaw(requestParameters: CueCueNumberDuckTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDuckTimeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDuckTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/duckTime`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDuckTimeRequestToJSON(requestParameters.cueCueNumberDuckTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDuckTimeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/duckTime {number} If number is given, set the Duck audio of other cues time of the specified cue to number. If not, return the Duck audio of other cues time of the specified cue.
     */
    async cueCueNumberDuckTime(requestParameters: CueCueNumberDuckTimeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDuckTimeResponse> {
        const response = await this.cueCueNumberDuckTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/duration {number} If number is given, and the selected cue has an editable duration, set the duration of the specified cue to number. If not, return the duration of the specified cue.
     */
    async cueCueNumberDurationRaw(requestParameters: CueCueNumberDurationOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberDurationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberDuration.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/duration`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberDurationRequestToJSON(requestParameters.cueCueNumberDurationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberDurationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/duration {number} If number is given, and the selected cue has an editable duration, set the duration of the specified cue to number. If not, return the duration of the specified cue.
     */
    async cueCueNumberDuration(requestParameters: CueCueNumberDurationOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberDurationResponse> {
        const response = await this.cueCueNumberDurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/effectIndex {number} If number is given, set the video effect used for the specified cue. If not, return the index number of the video effect used for the specified cue. number can be any of the following: 1  - Color Controls 2  - Exposure 3  - Gamma 4  - Sepia Monochrome 5  - Min Max Invert 6  - White point 7  - Box / Disc / Gaussian Blurs 8  - Motion Blur 9  - Sharpen Luminance 10 - Unsharp Mask 11 - Zoom Blur 12 - Pixellation 13 - Screen 14 - Bloom and Gloom 15 - CMYK Halftone 16 - Color Posterize 17 - Crystallize and Pointillize 18 - Edge Work 19 - Kaleidoscope 20 - Median and Comic Effect 21 - Noise Reduction 22 - Circle Splash / Hole Distortion 23 - Pinch / Bump Distortion 24 - Torus / Lens Distortion 25 - Twirl / Circular Wrap / Vortex 26 - Glass Lozenge 27 - Op Tile 28 - Perspective Tile 29 - Quad Tiles 30 - Reflected Tiles 31 - Rotated Tiles 32 - Titles Note: /effectIndex replaces /effect which worked in earlier versions of QLab 4, but which was removed for boring technical reasons.
     */
    async cueCueNumberEffectIndexRaw(requestParameters: CueCueNumberEffectIndexOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberEffectIndexResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberEffectIndex.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/effectIndex`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberEffectIndexRequestToJSON(requestParameters.cueCueNumberEffectIndexRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberEffectIndexResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/effectIndex {number} If number is given, set the video effect used for the specified cue. If not, return the index number of the video effect used for the specified cue. number can be any of the following: 1  - Color Controls 2  - Exposure 3  - Gamma 4  - Sepia Monochrome 5  - Min Max Invert 6  - White point 7  - Box / Disc / Gaussian Blurs 8  - Motion Blur 9  - Sharpen Luminance 10 - Unsharp Mask 11 - Zoom Blur 12 - Pixellation 13 - Screen 14 - Bloom and Gloom 15 - CMYK Halftone 16 - Color Posterize 17 - Crystallize and Pointillize 18 - Edge Work 19 - Kaleidoscope 20 - Median and Comic Effect 21 - Noise Reduction 22 - Circle Splash / Hole Distortion 23 - Pinch / Bump Distortion 24 - Torus / Lens Distortion 25 - Twirl / Circular Wrap / Vortex 26 - Glass Lozenge 27 - Op Tile 28 - Perspective Tile 29 - Quad Tiles 30 - Reflected Tiles 31 - Rotated Tiles 32 - Titles Note: /effectIndex replaces /effect which worked in earlier versions of QLab 4, but which was removed for boring technical reasons.
     */
    async cueCueNumberEffectIndex(requestParameters: CueCueNumberEffectIndexOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberEffectIndexResponse> {
        const response = await this.cueCueNumberEffectIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/effectSet {parameter} {value} /cue/{cue_number}/liveEffectSet {parameter} {value} If value is given, set the specified video effects parameter to value. If not, return the value of the specified parameter. parameter must be a string, and must match the name of a parameter of the video effect currently in use for the specified cue. For example, if the specified cue is using the Color Controls video effect, then parameter could be Brightness, Contrast, Hue Angle, or Saturation. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberEffectSetRaw(requestParameters: CueCueNumberEffectSetOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberEffectSetResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberEffectSet.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/effectSet`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberEffectSetRequestToJSON(requestParameters.cueCueNumberEffectSetRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberEffectSetResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/effectSet {parameter} {value} /cue/{cue_number}/liveEffectSet {parameter} {value} If value is given, set the specified video effects parameter to value. If not, return the value of the specified parameter. parameter must be a string, and must match the name of a parameter of the video effect currently in use for the specified cue. For example, if the specified cue is using the Color Controls video effect, then parameter could be Brightness, Contrast, Hue Angle, or Saturation. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberEffectSet(requestParameters: CueCueNumberEffectSetOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberEffectSetResponse> {
        const response = await this.cueCueNumberEffectSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/endTime {number} If number is given, set the end time of the specified cue to number seconds. If not, return the end time of the specified cue. number can be any whole or decimal number greater than or equal to zero.
     */
    async cueCueNumberEndTimeRaw(requestParameters: CueCueNumberEndTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberEndTimeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberEndTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/endTime`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberEndTimeRequestToJSON(requestParameters.cueCueNumberEndTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberEndTimeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/endTime {number} If number is given, set the end time of the specified cue to number seconds. If not, return the end time of the specified cue. number can be any whole or decimal number greater than or equal to zero.
     */
    async cueCueNumberEndTime(requestParameters: CueCueNumberEndTimeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberEndTimeResponse> {
        const response = await this.cueCueNumberEndTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/endValue {number} If number is given, set the fade ending value of the MIDI message of the specified cue to number. If not, return the fade ending value of the MIDI message of the specified cue. number must be a whole number from 0 to 127, unless the message type of the specified cue is pitch bend, in which case number must be a whole number between 0 and 16383.
     */
    async cueCueNumberEndValueRaw(requestParameters: CueCueNumberEndValueOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberEndValueResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberEndValue.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/endValue`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberEndValueRequestToJSON(requestParameters.cueCueNumberEndValueRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberEndValueResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/endValue {number} If number is given, set the fade ending value of the MIDI message of the specified cue to number. If not, return the fade ending value of the MIDI message of the specified cue. number must be a whole number from 0 to 127, unless the message type of the specified cue is pitch bend, in which case number must be a whole number between 0 and 16383.
     */
    async cueCueNumberEndValue(requestParameters: CueCueNumberEndValueOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberEndValueResponse> {
        const response = await this.cueCueNumberEndValueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/fadeAndStopOthers {number} If number is given, set the Fade and stop mode of the specified cue to number. If not, return the Fade and stop mode of the specified cue. Mode 0 is equivalent to the Fade and stop checkbox being unchecked. Valid modes are: 0 - none 1 - peers 2 - list or cart 3 - all
     */
    async cueCueNumberFadeAndStopOthersRaw(requestParameters: CueCueNumberFadeAndStopOthersOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberFadeAndStopOthersResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberFadeAndStopOthers.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/fadeAndStopOthers`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberFadeAndStopOthersRequestToJSON(requestParameters.cueCueNumberFadeAndStopOthersRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberFadeAndStopOthersResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/fadeAndStopOthers {number} If number is given, set the Fade and stop mode of the specified cue to number. If not, return the Fade and stop mode of the specified cue. Mode 0 is equivalent to the Fade and stop checkbox being unchecked. Valid modes are: 0 - none 1 - peers 2 - list or cart 3 - all
     */
    async cueCueNumberFadeAndStopOthers(requestParameters: CueCueNumberFadeAndStopOthersOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberFadeAndStopOthersResponse> {
        const response = await this.cueCueNumberFadeAndStopOthersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/fadeAndStopOthersTime {number} If number is given, set the Fade and stop others time of the specified cue to number. If not, return the Fade and stop others time of the specified cue.
     */
    async cueCueNumberFadeAndStopOthersTimeRaw(requestParameters: CueCueNumberFadeAndStopOthersTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberFadeAndStopOthersTimeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberFadeAndStopOthersTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/fadeAndStopOthersTime`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberFadeAndStopOthersTimeRequestToJSON(requestParameters.cueCueNumberFadeAndStopOthersTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberFadeAndStopOthersTimeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/fadeAndStopOthersTime {number} If number is given, set the Fade and stop others time of the specified cue to number. If not, return the Fade and stop others time of the specified cue.
     */
    async cueCueNumberFadeAndStopOthersTime(requestParameters: CueCueNumberFadeAndStopOthersTimeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberFadeAndStopOthersTimeResponse> {
        const response = await this.cueCueNumberFadeAndStopOthersTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/fileTarget {string} If string is given, and if the specified cue can have file targets, set the target of the specified cue to string. If not, return the target of the specified cue. You can provide a target using any of three kinds of paths:  Full paths, e.g. /Volumes/MyDisk/path/to/some/file.wav Paths beginning with a tilde, e.g. ~/path/to some/file.mov Relative paths, e.g. this/is/a/relative/path.mid  Paths beginning with a tilde (~) will be expanded; the tilde signifies relative to the users home directory. Relative paths will be interpreted according to the current working directory. Use QLabs /workingDirectory method to set or get the current working directory.
     */
    async cueCueNumberFileTargetRaw(requestParameters: CueCueNumberFileTargetOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberFileTargetResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberFileTarget.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/fileTarget`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberFileTargetRequestToJSON(requestParameters.cueCueNumberFileTargetRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberFileTargetResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/fileTarget {string} If string is given, and if the specified cue can have file targets, set the target of the specified cue to string. If not, return the target of the specified cue. You can provide a target using any of three kinds of paths:  Full paths, e.g. /Volumes/MyDisk/path/to/some/file.wav Paths beginning with a tilde, e.g. ~/path/to some/file.mov Relative paths, e.g. this/is/a/relative/path.mid  Paths beginning with a tilde (~) will be expanded; the tilde signifies relative to the users home directory. Relative paths will be interpreted according to the current working directory. Use QLabs /workingDirectory method to set or get the current working directory.
     */
    async cueCueNumberFileTarget(requestParameters: CueCueNumberFileTargetOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberFileTargetResponse> {
        const response = await this.cueCueNumberFileTargetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/fixedWidth {number} If number is given, and is greater than 0, set the fixed width of the specified cue to number. If number equals 0, set the width of the specified cue to automatic. If no number is given, return the width of the specified cue. number can be any positive whole or decimal number.
     */
    async cueCueNumberFixedWidthRaw(requestParameters: CueCueNumberFixedWidthOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberFixedWidthResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberFixedWidth.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/fixedWidth`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberFixedWidthRequestToJSON(requestParameters.cueCueNumberFixedWidthRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberFixedWidthResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/fixedWidth {number} If number is given, and is greater than 0, set the fixed width of the specified cue to number. If number equals 0, set the width of the specified cue to automatic. If no number is given, return the width of the specified cue. number can be any positive whole or decimal number.
     */
    async cueCueNumberFixedWidth(requestParameters: CueCueNumberFixedWidthOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberFixedWidthResponse> {
        const response = await this.cueCueNumberFixedWidthRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/flagged {number} Get or set the flagged state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the flagged state of the specified cue.
     */
    async cueCueNumberFlaggedRaw(requestParameters: CueCueNumberFlaggedOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberFlaggedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberFlagged.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/flagged`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberFlaggedRequestToJSON(requestParameters.cueCueNumberFlaggedRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberFlaggedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/flagged {number} Get or set the flagged state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the flagged state of the specified cue.
     */
    async cueCueNumberFlagged(requestParameters: CueCueNumberFlaggedOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberFlaggedResponse> {
        const response = await this.cueCueNumberFlaggedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberFramesRaw(requestParameters: CueCueNumberFramesOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberFramesResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberFrames.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/frames`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberFramesRequestToJSON(requestParameters.cueCueNumberFramesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberFramesResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberFrames(requestParameters: CueCueNumberFramesOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberFramesResponse> {
        const response = await this.cueCueNumberFramesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/fullScreen {number} /cue/{cue_number}/fullSurface {number} Get or set the full-surface state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the full-surface state of the specified cue.
     */
    async cueCueNumberFullScreenRaw(requestParameters: CueCueNumberFullScreenOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberFullScreenResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberFullScreen.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/fullScreen`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberFullScreenRequestToJSON(requestParameters.cueCueNumberFullScreenRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberFullScreenResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/fullScreen {number} /cue/{cue_number}/fullSurface {number} Get or set the full-surface state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the full-surface state of the specified cue.
     */
    async cueCueNumberFullScreen(requestParameters: CueCueNumberFullScreenOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberFullScreenResponse> {
        const response = await this.cueCueNumberFullScreenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/fullScreen {number} /cue/{cue_number}/fullSurface {number} Get or set the full-surface state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the full-surface state of the specified cue.
     */
    async cueCueNumberFullSurfaceRaw(requestParameters: CueCueNumberFullSurfaceOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberFullSurfaceResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberFullSurface.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/fullSurface`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberFullSurfaceRequestToJSON(requestParameters.cueCueNumberFullSurfaceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberFullSurfaceResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/fullScreen {number} /cue/{cue_number}/fullSurface {number} Get or set the full-surface state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the full-surface state of the specified cue.
     */
    async cueCueNumberFullSurface(requestParameters: CueCueNumberFullSurfaceOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberFullSurfaceResponse> {
        const response = await this.cueCueNumberFullSurfaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/gang {inChannel} {outChannel} {gang} /cue/{cue_number}/gang/{inChannel}/{outChannel} {gang} Get or set a single crosspoint gang. inChannel is an integer from 0 to 24. outChannel is either an integer from 0 to 64, or a string (the cue output name). gang is an optional text string. When present it is the gang to set. If no gang is given, return the gang of the specified crosspoint.
     */
    async cueCueNumberGangRaw(requestParameters: CueCueNumberGangOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberGangResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberGang.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/gang`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberGangRequestToJSON(requestParameters.cueCueNumberGangRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberGangResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/gang {inChannel} {outChannel} {gang} /cue/{cue_number}/gang/{inChannel}/{outChannel} {gang} Get or set a single crosspoint gang. inChannel is an integer from 0 to 24. outChannel is either an integer from 0 to 64, or a string (the cue output name). gang is an optional text string. When present it is the gang to set. If no gang is given, return the gang of the specified crosspoint.
     */
    async cueCueNumberGang(requestParameters: CueCueNumberGangOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberGangResponse> {
        const response = await this.cueCueNumberGangRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/gang {inChannel} {outChannel} {gang} /cue/{cue_number}/gang/{inChannel}/{outChannel} {gang} Get or set a single crosspoint gang. inChannel is an integer from 0 to 24. outChannel is either an integer from 0 to 64, or a string (the cue output name). gang is an optional text string. When present it is the gang to set. If no gang is given, return the gang of the specified crosspoint.
     */
    async cueCueNumberGangInChannelOutChannelRaw(requestParameters: CueCueNumberGangInChannelOutChannelOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberGangInChannelOutChannelResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberGangInChannelOutChannel.');
        }

        if (requestParameters.inChannel === null || requestParameters.inChannel === undefined) {
            throw new runtime.RequiredError('inChannel','Required parameter requestParameters.inChannel was null or undefined when calling cueCueNumberGangInChannelOutChannel.');
        }

        if (requestParameters.outChannel === null || requestParameters.outChannel === undefined) {
            throw new runtime.RequiredError('outChannel','Required parameter requestParameters.outChannel was null or undefined when calling cueCueNumberGangInChannelOutChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/gang/{inChannel}/{outChannel}`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"inChannel"}}`, encodeURIComponent(String(requestParameters.inChannel))).replace(`{${"outChannel"}}`, encodeURIComponent(String(requestParameters.outChannel))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberGangInChannelOutChannelRequestToJSON(requestParameters.cueCueNumberGangInChannelOutChannelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberGangInChannelOutChannelResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/gang {inChannel} {outChannel} {gang} /cue/{cue_number}/gang/{inChannel}/{outChannel} {gang} Get or set a single crosspoint gang. inChannel is an integer from 0 to 24. outChannel is either an integer from 0 to 64, or a string (the cue output name). gang is an optional text string. When present it is the gang to set. If no gang is given, return the gang of the specified crosspoint.
     */
    async cueCueNumberGangInChannelOutChannel(requestParameters: CueCueNumberGangInChannelOutChannelOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberGangInChannelOutChannelResponse> {
        const response = await this.cueCueNumberGangInChannelOutChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/geoMode {number} If number is given, set the geometry fade mode of the specified cue. Mode 0 is absolute fade, mode 1 is relative fade. If number is not given, return the geometry fade mode of the specified cue.
     */
    async cueCueNumberGeoModeRaw(requestParameters: CueCueNumberGeoModeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberGeoModeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberGeoMode.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/geoMode`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberGeoModeRequestToJSON(requestParameters.cueCueNumberGeoModeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberGeoModeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/geoMode {number} If number is given, set the geometry fade mode of the specified cue. Mode 0 is absolute fade, mode 1 is relative fade. If number is not given, return the geometry fade mode of the specified cue.
     */
    async cueCueNumberGeoMode(requestParameters: CueCueNumberGeoModeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberGeoModeResponse> {
        const response = await this.cueCueNumberGeoModeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/go If the specified cue is a cue list, then tell that cue list to GO. This GO respects the current playback position for that list, as well as double go protection for the workspace.
     */
    async cueCueNumberGoRaw(requestParameters: CueCueNumberGoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberGoResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberGo.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/go`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberGoResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/go If the specified cue is a cue list, then tell that cue list to GO. This GO respects the current playback position for that list, as well as double go protection for the workspace.
     */
    async cueCueNumberGo(requestParameters: CueCueNumberGoRequest, initOverrides?: RequestInit): Promise<CueCueNumberGoResponse> {
        const response = await this.cueCueNumberGoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hardPause Pause the specified cue without allowing AudioUnit effects to decay naturally. If the specified cue is not playing, this command has no effect.
     */
    async cueCueNumberHardPauseRaw(requestParameters: CueCueNumberHardPauseRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberHardPauseResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberHardPause.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/hardPause`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberHardPauseResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hardPause Pause the specified cue without allowing AudioUnit effects to decay naturally. If the specified cue is not playing, this command has no effect.
     */
    async cueCueNumberHardPause(requestParameters: CueCueNumberHardPauseRequest, initOverrides?: RequestInit): Promise<CueCueNumberHardPauseResponse> {
        const response = await this.cueCueNumberHardPauseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hardStop HardStop the specified cue. If the specified cue is not playing, this command has no effect. HardStopped cues stop immediately; if the cue has an Audio Effect which ordinarily decays after stopping, such as a reverb, the Audio Effect is also stopped immediately.
     */
    async cueCueNumberHardStopRaw(requestParameters: CueCueNumberHardStopRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberHardStopResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberHardStop.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/hardStop`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberHardStopResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hardStop HardStop the specified cue. If the specified cue is not playing, this command has no effect. HardStopped cues stop immediately; if the cue has an Audio Effect which ordinarily decays after stopping, such as a reverb, the Audio Effect is also stopped immediately.
     */
    async cueCueNumberHardStop(requestParameters: CueCueNumberHardStopRequest, initOverrides?: RequestInit): Promise<CueCueNumberHardStopResponse> {
        const response = await this.cueCueNumberHardStopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hasCueTargets Read-only; return true if the specified cue is able to target another cue, such as a Fade or Stop cue.
     */
    async cueCueNumberHasCueTargetsRaw(requestParameters: CueCueNumberHasCueTargetsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberHasCueTargetsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberHasCueTargets.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/hasCueTargets`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberHasCueTargetsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hasCueTargets Read-only; return true if the specified cue is able to target another cue, such as a Fade or Stop cue.
     */
    async cueCueNumberHasCueTargets(requestParameters: CueCueNumberHasCueTargetsRequest, initOverrides?: RequestInit): Promise<CueCueNumberHasCueTargetsResponse> {
        const response = await this.cueCueNumberHasCueTargetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hasFileTargets Read-only; return true if the specified cue is able to target a file, such as an Audio or Video cue.
     */
    async cueCueNumberHasFileTargetsRaw(requestParameters: CueCueNumberHasFileTargetsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberHasFileTargetsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberHasFileTargets.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/hasFileTargets`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberHasFileTargetsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hasFileTargets Read-only; return true if the specified cue is able to target a file, such as an Audio or Video cue.
     */
    async cueCueNumberHasFileTargets(requestParameters: CueCueNumberHasFileTargetsRequest, initOverrides?: RequestInit): Promise<CueCueNumberHasFileTargetsResponse> {
        const response = await this.cueCueNumberHasFileTargetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/holdLastFrame {number} Get or set the state of the hold last frame checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the hold last frame specified cue.
     */
    async cueCueNumberHoldLastFrameRaw(requestParameters: CueCueNumberHoldLastFrameOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberHoldLastFrameResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberHoldLastFrame.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/holdLastFrame`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberHoldLastFrameRequestToJSON(requestParameters.cueCueNumberHoldLastFrameRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberHoldLastFrameResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/holdLastFrame {number} Get or set the state of the hold last frame checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the hold last frame specified cue.
     */
    async cueCueNumberHoldLastFrame(requestParameters: CueCueNumberHoldLastFrameOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberHoldLastFrameResponse> {
        const response = await this.cueCueNumberHoldLastFrameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberHoursRaw(requestParameters: CueCueNumberHoursOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberHoursResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberHours.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/hours`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberHoursRequestToJSON(requestParameters.cueCueNumberHoursRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberHoursResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberHours(requestParameters: CueCueNumberHoursOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberHoursResponse> {
        const response = await this.cueCueNumberHoursRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/infiniteLoop {number} Get or set the infinite loop state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the infinite loop state of the specified cue.
     */
    async cueCueNumberInfiniteLoopRaw(requestParameters: CueCueNumberInfiniteLoopOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberInfiniteLoopResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberInfiniteLoop.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/infiniteLoop`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberInfiniteLoopRequestToJSON(requestParameters.cueCueNumberInfiniteLoopRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberInfiniteLoopResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/infiniteLoop {number} Get or set the infinite loop state of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the infinite loop state of the specified cue.
     */
    async cueCueNumberInfiniteLoop(requestParameters: CueCueNumberInfiniteLoopOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberInfiniteLoopResponse> {
        const response = await this.cueCueNumberInfiniteLoopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/isActionRunning Read-only; return true if the action of the specified cue (not the pre-wait or post-wait) is running.
     */
    async cueCueNumberIsActionRunningRaw(requestParameters: CueCueNumberIsActionRunningRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberIsActionRunningResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberIsActionRunning.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/isActionRunning`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberIsActionRunningResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/isActionRunning Read-only; return true if the action of the specified cue (not the pre-wait or post-wait) is running.
     */
    async cueCueNumberIsActionRunning(requestParameters: CueCueNumberIsActionRunningRequest, initOverrides?: RequestInit): Promise<CueCueNumberIsActionRunningResponse> {
        const response = await this.cueCueNumberIsActionRunningRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/isBroken Read-only; return true if the specified cue is broken.
     */
    async cueCueNumberIsBrokenRaw(requestParameters: CueCueNumberIsBrokenRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberIsBrokenResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberIsBroken.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/isBroken`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberIsBrokenResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/isBroken Read-only; return true if the specified cue is broken.
     */
    async cueCueNumberIsBroken(requestParameters: CueCueNumberIsBrokenRequest, initOverrides?: RequestInit): Promise<CueCueNumberIsBrokenResponse> {
        const response = await this.cueCueNumberIsBrokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/isLoaded Read-only; return true if the specified cue is loaded.
     */
    async cueCueNumberIsLoadedRaw(requestParameters: CueCueNumberIsLoadedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberIsLoadedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberIsLoaded.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/isLoaded`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberIsLoadedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/isLoaded Read-only; return true if the specified cue is loaded.
     */
    async cueCueNumberIsLoaded(requestParameters: CueCueNumberIsLoadedRequest, initOverrides?: RequestInit): Promise<CueCueNumberIsLoadedResponse> {
        const response = await this.cueCueNumberIsLoadedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/isOverridden Read-only; return true if the specified cues output is currently suppressed by an override control.
     */
    async cueCueNumberIsOverriddenRaw(requestParameters: CueCueNumberIsOverriddenRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberIsOverriddenResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberIsOverridden.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/isOverridden`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberIsOverriddenResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/isOverridden Read-only; return true if the specified cues output is currently suppressed by an override control.
     */
    async cueCueNumberIsOverridden(requestParameters: CueCueNumberIsOverriddenRequest, initOverrides?: RequestInit): Promise<CueCueNumberIsOverriddenResponse> {
        const response = await this.cueCueNumberIsOverriddenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/isPanicking Read-only; return true if the specified cue is panicking.
     */
    async cueCueNumberIsPanickingRaw(requestParameters: CueCueNumberIsPanickingRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberIsPanickingResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberIsPanicking.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/isPanicking`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberIsPanickingResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/isPanicking Read-only; return true if the specified cue is panicking.
     */
    async cueCueNumberIsPanicking(requestParameters: CueCueNumberIsPanickingRequest, initOverrides?: RequestInit): Promise<CueCueNumberIsPanickingResponse> {
        const response = await this.cueCueNumberIsPanickingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/isPaused Read-only; return true if the specified cue is paused.
     */
    async cueCueNumberIsPausedRaw(requestParameters: CueCueNumberIsPausedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberIsPausedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberIsPaused.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/isPaused`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberIsPausedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/isPaused Read-only; return true if the specified cue is paused.
     */
    async cueCueNumberIsPaused(requestParameters: CueCueNumberIsPausedRequest, initOverrides?: RequestInit): Promise<CueCueNumberIsPausedResponse> {
        const response = await this.cueCueNumberIsPausedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/isRunning Read-only; return true if the specified cue is running.
     */
    async cueCueNumberIsRunningRaw(requestParameters: CueCueNumberIsRunningRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberIsRunningResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberIsRunning.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/isRunning`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberIsRunningResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/isRunning Read-only; return true if the specified cue is running.
     */
    async cueCueNumberIsRunning(requestParameters: CueCueNumberIsRunningRequest, initOverrides?: RequestInit): Promise<CueCueNumberIsRunningResponse> {
        const response = await this.cueCueNumberIsRunningRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/isTailingOut Read-only; return true if the specified cue has an AudioUnit which is decaying.
     */
    async cueCueNumberIsTailingOutRaw(requestParameters: CueCueNumberIsTailingOutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberIsTailingOutResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberIsTailingOut.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/isTailingOut`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberIsTailingOutResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/isTailingOut Read-only; return true if the specified cue has an AudioUnit which is decaying.
     */
    async cueCueNumberIsTailingOut(requestParameters: CueCueNumberIsTailingOutRequest, initOverrides?: RequestInit): Promise<CueCueNumberIsTailingOutResponse> {
        const response = await this.cueCueNumberIsTailingOutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/lastSliceInfiniteLoop {number} If number is given, and is any positive whole number, set the last slice of the specified cue to loop infinitely. If number is 0, then set the last slice of the specified cue to not loop. If number is not given, return the infinite loop state of the last slice of the specified cue.
     */
    async cueCueNumberLastSliceInfiniteLoopRaw(requestParameters: CueCueNumberLastSliceInfiniteLoopOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLastSliceInfiniteLoopResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLastSliceInfiniteLoop.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/lastSliceInfiniteLoop`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLastSliceInfiniteLoopRequestToJSON(requestParameters.cueCueNumberLastSliceInfiniteLoopRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLastSliceInfiniteLoopResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/lastSliceInfiniteLoop {number} If number is given, and is any positive whole number, set the last slice of the specified cue to loop infinitely. If number is 0, then set the last slice of the specified cue to not loop. If number is not given, return the infinite loop state of the last slice of the specified cue.
     */
    async cueCueNumberLastSliceInfiniteLoop(requestParameters: CueCueNumberLastSliceInfiniteLoopOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLastSliceInfiniteLoopResponse> {
        const response = await this.cueCueNumberLastSliceInfiniteLoopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/lastSlicePlayCount {play_count} If play_count is given, set the play count of the last slice of the specified cue to play_count. Otherwise, return the play count of the last slice of the specified cue. play_count can be any positive whole number, or -1 to set the slice to infinite loop.
     */
    async cueCueNumberLastSlicePlayCountRaw(requestParameters: CueCueNumberLastSlicePlayCountOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLastSlicePlayCountResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLastSlicePlayCount.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/lastSlicePlayCount`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLastSlicePlayCountRequestToJSON(requestParameters.cueCueNumberLastSlicePlayCountRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLastSlicePlayCountResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/lastSlicePlayCount {play_count} If play_count is given, set the play count of the last slice of the specified cue to play_count. Otherwise, return the play count of the last slice of the specified cue. play_count can be any positive whole number, or -1 to set the slice to infinite loop.
     */
    async cueCueNumberLastSlicePlayCount(requestParameters: CueCueNumberLastSlicePlayCountOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLastSlicePlayCountResponse> {
        const response = await this.cueCueNumberLastSlicePlayCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/layer {number} If number is given, set the layer of the specified cue to number. If not, return the layer of the specified cue. number can be any positive whole number from 0 to 1000. Layer 0 is the bottom layer and layer 1000 is the top layer. A number between 0 and 1000, inclusive.
     */
    async cueCueNumberLayerRaw(requestParameters: CueCueNumberLayerOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLayerResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLayer.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/layer`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLayerRequestToJSON(requestParameters.cueCueNumberLayerRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLayerResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/layer {number} If number is given, set the layer of the specified cue to number. If not, return the layer of the specified cue. number can be any positive whole number from 0 to 1000. Layer 0 is the bottom layer and layer 1000 is the top layer. A number between 0 and 1000, inclusive.
     */
    async cueCueNumberLayer(requestParameters: CueCueNumberLayerOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLayerResponse> {
        const response = await this.cueCueNumberLayerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/level {inChannel} {outChannel} {decibel} /cue/{cue_number}/level/{inChannel}/{outChannel} {decibel} Get or set a single crosspoint volume level. inChannel is an integer from 0 to 24. 0 is the master column. outChannel is either an integer from 0 to 64, or a string (the cue output name). 0 is the master row. decibel is an optional whole or decimal number. When present it is the decibel value to set. If decibel is sent as a string (e.g. -inf) QLab will use the minimum decibel value set in workspace settings. If no decibel is given, return the volume level of the specified crosspoint.
     */
    async cueCueNumberLevelRaw(requestParameters: CueCueNumberLevelOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLevelResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLevel.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/level`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLevelRequestToJSON(requestParameters.cueCueNumberLevelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLevelResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/level {inChannel} {outChannel} {decibel} /cue/{cue_number}/level/{inChannel}/{outChannel} {decibel} Get or set a single crosspoint volume level. inChannel is an integer from 0 to 24. 0 is the master column. outChannel is either an integer from 0 to 64, or a string (the cue output name). 0 is the master row. decibel is an optional whole or decimal number. When present it is the decibel value to set. If decibel is sent as a string (e.g. -inf) QLab will use the minimum decibel value set in workspace settings. If no decibel is given, return the volume level of the specified crosspoint.
     */
    async cueCueNumberLevel(requestParameters: CueCueNumberLevelOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLevelResponse> {
        const response = await this.cueCueNumberLevelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/level {inChannel} {outChannel} {decibel} /cue/{cue_number}/level/{inChannel}/{outChannel} {decibel} Get or set a single crosspoint volume level. inChannel is an integer from 0 to 24. 0 is the master column. outChannel is either an integer from 0 to 64, or a string (the cue output name). 0 is the master row. decibel is an optional whole or decimal number. When present it is the decibel value to set. If decibel is sent as a string (e.g. -inf) QLab will use the minimum decibel value set in workspace settings. If no decibel is given, return the volume level of the specified crosspoint.
     */
    async cueCueNumberLevelInChannelOutChannelRaw(requestParameters: CueCueNumberLevelInChannelOutChannelOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLevelInChannelOutChannelResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLevelInChannelOutChannel.');
        }

        if (requestParameters.inChannel === null || requestParameters.inChannel === undefined) {
            throw new runtime.RequiredError('inChannel','Required parameter requestParameters.inChannel was null or undefined when calling cueCueNumberLevelInChannelOutChannel.');
        }

        if (requestParameters.outChannel === null || requestParameters.outChannel === undefined) {
            throw new runtime.RequiredError('outChannel','Required parameter requestParameters.outChannel was null or undefined when calling cueCueNumberLevelInChannelOutChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/level/{inChannel}/{outChannel}`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"inChannel"}}`, encodeURIComponent(String(requestParameters.inChannel))).replace(`{${"outChannel"}}`, encodeURIComponent(String(requestParameters.outChannel))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLevelInChannelOutChannelRequestToJSON(requestParameters.cueCueNumberLevelInChannelOutChannelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLevelInChannelOutChannelResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/level {inChannel} {outChannel} {decibel} /cue/{cue_number}/level/{inChannel}/{outChannel} {decibel} Get or set a single crosspoint volume level. inChannel is an integer from 0 to 24. 0 is the master column. outChannel is either an integer from 0 to 64, or a string (the cue output name). 0 is the master row. decibel is an optional whole or decimal number. When present it is the decibel value to set. If decibel is sent as a string (e.g. -inf) QLab will use the minimum decibel value set in workspace settings. If no decibel is given, return the volume level of the specified crosspoint.
     */
    async cueCueNumberLevelInChannelOutChannel(requestParameters: CueCueNumberLevelInChannelOutChannelOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLevelInChannelOutChannelResponse> {
        const response = await this.cueCueNumberLevelInChannelOutChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/levels Read-only; return all the audio levels currently available in the specified cues inspector. The levels are returned as an array of arrays, like so: [row0Array, row1Array, row2Array, ...] Row 0 of /levels is equivalent to the results of the /sliderLevels method.
     */
    async cueCueNumberLevelsRaw(requestParameters: CueCueNumberLevelsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLevelsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLevels.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/levels`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLevelsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/levels Read-only; return all the audio levels currently available in the specified cues inspector. The levels are returned as an array of arrays, like so: [row0Array, row1Array, row2Array, ...] Row 0 of /levels is equivalent to the results of the /sliderLevels method.
     */
    async cueCueNumberLevels(requestParameters: CueCueNumberLevelsRequest, initOverrides?: RequestInit): Promise<CueCueNumberLevelsResponse> {
        const response = await this.cueCueNumberLevelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/lightCommandText {string} If string is given, set the full command text of the specified cue to string. If not, return the full command text of the specified cue.
     */
    async cueCueNumberLightCommandTextRaw(requestParameters: CueCueNumberLightCommandTextOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLightCommandTextResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLightCommandText.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/lightCommandText`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLightCommandTextRequestToJSON(requestParameters.cueCueNumberLightCommandTextRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLightCommandTextResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/lightCommandText {string} If string is given, set the full command text of the specified cue to string. If not, return the full command text of the specified cue.
     */
    async cueCueNumberLightCommandText(requestParameters: CueCueNumberLightCommandTextOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLightCommandTextResponse> {
        const response = await this.cueCueNumberLightCommandTextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/listName Return the list name of the specified cue. The list name is the name that is displayed in the cue list, which can be either the default name, a manually set display name, or nothing.
     */
    async cueCueNumberListNameRaw(requestParameters: CueCueNumberListNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberListNameResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberListName.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/listName`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberListNameResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/listName Return the list name of the specified cue. The list name is the name that is displayed in the cue list, which can be either the default name, a manually set display name, or nothing.
     */
    async cueCueNumberListName(requestParameters: CueCueNumberListNameRequest, initOverrides?: RequestInit): Promise<CueCueNumberListNameResponse> {
        const response = await this.cueCueNumberListNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/liveAverageLevel/{outputChannel} {low} {high} Read-only; return the RMS level of outputChannel. low and high are optional values to re-scale the output of this method. For example, sending the message /cue/1/liveAverageLevel/1 0 100 will return a 0 if the level of output 1 is silent, and 100 if the level of output 1 is as loud as is possible.
     */
    async cueCueNumberLiveAverageLevelOutputChannelRaw(requestParameters: CueCueNumberLiveAverageLevelOutputChannelOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveAverageLevelOutputChannelResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveAverageLevelOutputChannel.');
        }

        if (requestParameters.outputChannel === null || requestParameters.outputChannel === undefined) {
            throw new runtime.RequiredError('outputChannel','Required parameter requestParameters.outputChannel was null or undefined when calling cueCueNumberLiveAverageLevelOutputChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveAverageLevel/{outputChannel}`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"outputChannel"}}`, encodeURIComponent(String(requestParameters.outputChannel))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveAverageLevelOutputChannelRequestToJSON(requestParameters.cueCueNumberLiveAverageLevelOutputChannelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveAverageLevelOutputChannelResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/liveAverageLevel/{outputChannel} {low} {high} Read-only; return the RMS level of outputChannel. low and high are optional values to re-scale the output of this method. For example, sending the message /cue/1/liveAverageLevel/1 0 100 will return a 0 if the level of output 1 is silent, and 100 if the level of output 1 is as loud as is possible.
     */
    async cueCueNumberLiveAverageLevelOutputChannel(requestParameters: CueCueNumberLiveAverageLevelOutputChannelOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveAverageLevelOutputChannelResponse> {
        const response = await this.cueCueNumberLiveAverageLevelOutputChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/effectSet {parameter} {value} /cue/{cue_number}/liveEffectSet {parameter} {value} If value is given, set the specified video effects parameter to value. If not, return the value of the specified parameter. parameter must be a string, and must match the name of a parameter of the video effect currently in use for the specified cue. For example, if the specified cue is using the Color Controls video effect, then parameter could be Brightness, Contrast, Hue Angle, or Saturation. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveEffectSetRaw(requestParameters: CueCueNumberLiveEffectSetOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveEffectSetResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveEffectSet.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveEffectSet`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveEffectSetRequestToJSON(requestParameters.cueCueNumberLiveEffectSetRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveEffectSetResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/effectSet {parameter} {value} /cue/{cue_number}/liveEffectSet {parameter} {value} If value is given, set the specified video effects parameter to value. If not, return the value of the specified parameter. parameter must be a string, and must match the name of a parameter of the video effect currently in use for the specified cue. For example, if the specified cue is using the Color Controls video effect, then parameter could be Brightness, Contrast, Hue Angle, or Saturation. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveEffectSet(requestParameters: CueCueNumberLiveEffectSetOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveEffectSetResponse> {
        const response = await this.cueCueNumberLiveEffectSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/liveRate {number} If number is given, set the rate of the specified cue to number. If not, return the rate of the specified cue. number can be any positive whole or decimal number from 0.03 to 33.0. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRateRaw(requestParameters: CueCueNumberLiveRateOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveRateResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveRate.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveRate`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveRateRequestToJSON(requestParameters.cueCueNumberLiveRateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveRateResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/liveRate {number} If number is given, set the rate of the specified cue to number. If not, return the rate of the specified cue. number can be any positive whole or decimal number from 0.03 to 33.0. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRate(requestParameters: CueCueNumberLiveRateOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveRateResponse> {
        const response = await this.cueCueNumberLiveRateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationXRaw(requestParameters: CueCueNumberLiveRotationXOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveRotationXResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveRotationX.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveRotation/x`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveRotationXRequestToJSON(requestParameters.cueCueNumberLiveRotationXRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveRotationXResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationX(requestParameters: CueCueNumberLiveRotationXOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveRotationXResponse> {
        const response = await this.cueCueNumberLiveRotationXRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationXaxisRaw(requestParameters: CueCueNumberLiveRotationXaxisOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveRotationXaxisResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveRotationXaxis.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveRotation/Xaxis`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveRotationXaxisRequestToJSON(requestParameters.cueCueNumberLiveRotationXaxisRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveRotationXaxisResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationXaxis(requestParameters: CueCueNumberLiveRotationXaxisOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveRotationXaxisResponse> {
        const response = await this.cueCueNumberLiveRotationXaxisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationYRaw(requestParameters: CueCueNumberLiveRotationYOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveRotationYResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveRotationY.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveRotation/y`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveRotationYRequestToJSON(requestParameters.cueCueNumberLiveRotationYRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveRotationYResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationY(requestParameters: CueCueNumberLiveRotationYOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveRotationYResponse> {
        const response = await this.cueCueNumberLiveRotationYRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationYaxisRaw(requestParameters: CueCueNumberLiveRotationYaxisOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveRotationYaxisResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveRotationYaxis.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveRotation/Yaxis`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveRotationYaxisRequestToJSON(requestParameters.cueCueNumberLiveRotationYaxisRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveRotationYaxisResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationYaxis(requestParameters: CueCueNumberLiveRotationYaxisOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveRotationYaxisResponse> {
        const response = await this.cueCueNumberLiveRotationYaxisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationZRaw(requestParameters: CueCueNumberLiveRotationZOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveRotationZResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveRotationZ.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveRotation/z`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveRotationZRequestToJSON(requestParameters.cueCueNumberLiveRotationZRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveRotationZResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationZ(requestParameters: CueCueNumberLiveRotationZOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveRotationZResponse> {
        const response = await this.cueCueNumberLiveRotationZRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationZaxisRaw(requestParameters: CueCueNumberLiveRotationZaxisOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveRotationZaxisResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveRotationZaxis.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveRotation/Zaxis`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveRotationZaxisRequestToJSON(requestParameters.cueCueNumberLiveRotationZaxisRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveRotationZaxisResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/liveRotation/Xaxis {number} /cue/{cue_number}/liveRotation/Yaxis {number} /cue/{cue_number}/liveRotation/Zaxis {number} /cue/{cue_number}/liveRotation/x {number} /cue/{cue_number}/liveRotation/y {number} /cue/{cue_number}/liveRotation/z {number} Rotate the specified cue by number degrees in the X, Y, or Z axis. These are equivalent to using a Fade cue in single-axis mode to rotate the specified cue. These live methods have no non-live counterparts. They operate on the active, live value of a running cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveRotationZaxis(requestParameters: CueCueNumberLiveRotationZaxisOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveRotationZaxisResponse> {
        const response = await this.cueCueNumberLiveRotationZaxisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/scale {x} {y} /cue/{cue_number}/liveScale {x} {y} If x and y are given, set the scale of the specified cue to (x,y). If not, return the current scale of the specified cue. x and y can be any decimal numbers. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveScaleRaw(requestParameters: CueCueNumberLiveScaleOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveScaleResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveScale.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveScale`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveScaleRequestToJSON(requestParameters.cueCueNumberLiveScaleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveScaleResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/scale {x} {y} /cue/{cue_number}/liveScale {x} {y} If x and y are given, set the scale of the specified cue to (x,y). If not, return the current scale of the specified cue. x and y can be any decimal numbers. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveScale(requestParameters: CueCueNumberLiveScaleOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveScaleResponse> {
        const response = await this.cueCueNumberLiveScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/scaleX {number} /cue/{cue_number}/liveScaleX {number} If number is given, set the X-axis scale of the specified cue to number. If not, return the X-axis scale of the specified cue. number can be any decimal number. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveScaleXRaw(requestParameters: CueCueNumberLiveScaleXOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveScaleXResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveScaleX.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveScaleX`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveScaleXRequestToJSON(requestParameters.cueCueNumberLiveScaleXRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveScaleXResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/scaleX {number} /cue/{cue_number}/liveScaleX {number} If number is given, set the X-axis scale of the specified cue to number. If not, return the X-axis scale of the specified cue. number can be any decimal number. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveScaleX(requestParameters: CueCueNumberLiveScaleXOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveScaleXResponse> {
        const response = await this.cueCueNumberLiveScaleXRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/scaleY {number} /cue/{cue_number}/liveScaleY {number} If number is given, set the Y-axis scale of the specified cue to number. If not, return the Y-axis scale of the specified cue. number can be any decimal number. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveScaleYRaw(requestParameters: CueCueNumberLiveScaleYOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveScaleYResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveScaleY.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveScaleY`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveScaleYRequestToJSON(requestParameters.cueCueNumberLiveScaleYRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveScaleYResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/scaleY {number} /cue/{cue_number}/liveScaleY {number} If number is given, set the Y-axis scale of the specified cue to number. If not, return the Y-axis scale of the specified cue. number can be any decimal number. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveScaleY(requestParameters: CueCueNumberLiveScaleYOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveScaleYResponse> {
        const response = await this.cueCueNumberLiveScaleYRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text {string} /cue/{cue_number}/liveText {string} If string is given, set the text of the specified cue to string. If not, return the text of the specified cue. When setting text, the formatting will match the first character of the existing text. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTextRaw(requestParameters: CueCueNumberLiveTextOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveTextResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveText.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveText`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveTextRequestToJSON(requestParameters.cueCueNumberLiveTextRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveTextResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text {string} /cue/{cue_number}/liveText {string} If string is given, set the text of the specified cue to string. If not, return the text of the specified cue. When setting text, the formatting will match the first character of the existing text. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveText(requestParameters: CueCueNumberLiveTextOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveTextResponse> {
        const response = await this.cueCueNumberLiveTextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/outputSize /cue/{cue_number}/liveText/outputSize Read-only; return a two-item array containing the width and height of the text or liveText of the specified cue. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTextOutputSizeRaw(requestParameters: CueCueNumberLiveTextOutputSizeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveTextOutputSizeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveTextOutputSize.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/liveText/outputSize`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveTextOutputSizeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/outputSize /cue/{cue_number}/liveText/outputSize Read-only; return a two-item array containing the width and height of the text or liveText of the specified cue. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTextOutputSize(requestParameters: CueCueNumberLiveTextOutputSizeRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveTextOutputSizeResponse> {
        const response = await this.cueCueNumberLiveTextOutputSizeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/translation {x} {y} /cue/{cue_number}/liveTranslation {x} {y} If x and y are given, set the translation of the specified cue to (x,y). If not, return the current translation of the specified cue. x and y can be any decimal numbers. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTranslationRaw(requestParameters: CueCueNumberLiveTranslationOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveTranslationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveTranslation.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveTranslation`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveTranslationRequestToJSON(requestParameters.cueCueNumberLiveTranslationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveTranslationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/translation {x} {y} /cue/{cue_number}/liveTranslation {x} {y} If x and y are given, set the translation of the specified cue to (x,y). If not, return the current translation of the specified cue. x and y can be any decimal numbers. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTranslation(requestParameters: CueCueNumberLiveTranslationOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveTranslationResponse> {
        const response = await this.cueCueNumberLiveTranslationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/translationX {number} /cue/{cue_number}/liveTranslationX {number} If number is given, set the X-axis translation of the specified cue to number. If not, return the X-axis translation of the specified cue. number can be any decimal number. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTranslationXRaw(requestParameters: CueCueNumberLiveTranslationXOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveTranslationXResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveTranslationX.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveTranslationX`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveTranslationXRequestToJSON(requestParameters.cueCueNumberLiveTranslationXRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveTranslationXResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/translationX {number} /cue/{cue_number}/liveTranslationX {number} If number is given, set the X-axis translation of the specified cue to number. If not, return the X-axis translation of the specified cue. number can be any decimal number. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTranslationX(requestParameters: CueCueNumberLiveTranslationXOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveTranslationXResponse> {
        const response = await this.cueCueNumberLiveTranslationXRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/translationY {number} /cue/{cue_number}/liveTranslationY {number} If number is given, set the Y-axis translation of the specified cue to number. If not, return the Y-axis translation of the specified cue. number can be any decimal number. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTranslationYRaw(requestParameters: CueCueNumberLiveTranslationYOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLiveTranslationYResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLiveTranslationY.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/liveTranslationY`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLiveTranslationYRequestToJSON(requestParameters.cueCueNumberLiveTranslationYRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLiveTranslationYResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/translationY {number} /cue/{cue_number}/liveTranslationY {number} If number is given, set the Y-axis translation of the specified cue to number. If not, return the Y-axis translation of the specified cue. number can be any decimal number. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberLiveTranslationY(requestParameters: CueCueNumberLiveTranslationYOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLiveTranslationYResponse> {
        const response = await this.cueCueNumberLiveTranslationYRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/load Load the specified cue.
     */
    async cueCueNumberLoadRaw(requestParameters: CueCueNumberLoadRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLoadResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLoad.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/load`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLoadResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/load Load the specified cue.
     */
    async cueCueNumberLoad(requestParameters: CueCueNumberLoadRequest, initOverrides?: RequestInit): Promise<CueCueNumberLoadResponse> {
        const response = await this.cueCueNumberLoadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/loadActionAt {number} If number is given, load the specified cue to number seconds. QLab will automatically add the pre-wait of the specified cue to number in order to load the cue to the correct time. If no number is given, this command is equivalent to load.
     */
    async cueCueNumberLoadActionAtRaw(requestParameters: CueCueNumberLoadActionAtOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLoadActionAtResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLoadActionAt.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/loadActionAt`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLoadActionAtRequestToJSON(requestParameters.cueCueNumberLoadActionAtRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLoadActionAtResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/loadActionAt {number} If number is given, load the specified cue to number seconds. QLab will automatically add the pre-wait of the specified cue to number in order to load the cue to the correct time. If no number is given, this command is equivalent to load.
     */
    async cueCueNumberLoadActionAt(requestParameters: CueCueNumberLoadActionAtOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLoadActionAtResponse> {
        const response = await this.cueCueNumberLoadActionAtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/loadAndSetPlayhead Move the playhead to the specified cue and load that cue.
     */
    async cueCueNumberLoadAndSetPlayheadRaw(requestParameters: CueCueNumberLoadAndSetPlayheadRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLoadAndSetPlayheadResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLoadAndSetPlayhead.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/loadAndSetPlayhead`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLoadAndSetPlayheadResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/loadAndSetPlayhead Move the playhead to the specified cue and load that cue.
     */
    async cueCueNumberLoadAndSetPlayhead(requestParameters: CueCueNumberLoadAndSetPlayheadRequest, initOverrides?: RequestInit): Promise<CueCueNumberLoadAndSetPlayheadResponse> {
        const response = await this.cueCueNumberLoadAndSetPlayheadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/loadAt {number} If number is given, load the specified cue to number seconds. If not, this command is equivalent to load.
     */
    async cueCueNumberLoadAtRaw(requestParameters: CueCueNumberLoadAtOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLoadAtResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLoadAt.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/loadAt`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLoadAtRequestToJSON(requestParameters.cueCueNumberLoadAtRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLoadAtResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/loadAt {number} If number is given, load the specified cue to number seconds. If not, this command is equivalent to load.
     */
    async cueCueNumberLoadAt(requestParameters: CueCueNumberLoadAtOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLoadAtResponse> {
        const response = await this.cueCueNumberLoadAtRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/lockFadeToCue {number} Get or set the state of the Lock fade to start/end checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Lock fade to start/end checkbox of the specified cue.
     */
    async cueCueNumberLockFadeToCueRaw(requestParameters: CueCueNumberLockFadeToCueOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberLockFadeToCueResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberLockFadeToCue.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/lockFadeToCue`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberLockFadeToCueRequestToJSON(requestParameters.cueCueNumberLockFadeToCueRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberLockFadeToCueResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/lockFadeToCue {number} Get or set the state of the Lock fade to start/end checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Lock fade to start/end checkbox of the specified cue.
     */
    async cueCueNumberLockFadeToCue(requestParameters: CueCueNumberLockFadeToCueOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberLockFadeToCueResponse> {
        const response = await this.cueCueNumberLockFadeToCueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/macro {number} If number is given, set the MSC macro of the specified cue to number. If not, return the MSC macro of the specified cue. number must be a whole number from 0 to 127.
     */
    async cueCueNumberMacroRaw(requestParameters: CueCueNumberMacroOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberMacroResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberMacro.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/macro`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberMacroRequestToJSON(requestParameters.cueCueNumberMacroRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberMacroResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/macro {number} If number is given, set the MSC macro of the specified cue to number. If not, return the MSC macro of the specified cue. number must be a whole number from 0 to 127.
     */
    async cueCueNumberMacro(requestParameters: CueCueNumberMacroOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberMacroResponse> {
        const response = await this.cueCueNumberMacroRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/maxTimeInCueSequence Return the maximum time required to complete the cue sequence starting at the specified cue, as used e.g. for the load to time slider. Any infinite loops within the sequence are only counted once.
     */
    async cueCueNumberMaxTimeInCueSequenceRaw(requestParameters: CueCueNumberMaxTimeInCueSequenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberMaxTimeInCueSequenceResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberMaxTimeInCueSequence.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/maxTimeInCueSequence`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberMaxTimeInCueSequenceResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/maxTimeInCueSequence Return the maximum time required to complete the cue sequence starting at the specified cue, as used e.g. for the load to time slider. Any infinite loops within the sequence are only counted once.
     */
    async cueCueNumberMaxTimeInCueSequence(requestParameters: CueCueNumberMaxTimeInCueSequenceRequest, initOverrides?: RequestInit): Promise<CueCueNumberMaxTimeInCueSequenceResponse> {
        const response = await this.cueCueNumberMaxTimeInCueSequenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/messageType {number} If number is given, set the message type of the specified cue to number. If not, return the message type of the specified cue. Valid message types are: 1 - MIDI Voice Message (\"Musical MIDI\") 2 - MIDI Show Control Message (MSC) 3 - MIDI SysEx Message
     */
    async cueCueNumberMessageTypeRaw(requestParameters: CueCueNumberMessageTypeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberMessageTypeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberMessageType.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/messageType`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberMessageTypeRequestToJSON(requestParameters.cueCueNumberMessageTypeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberMessageTypeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/messageType {number} If number is given, set the message type of the specified cue to number. If not, return the message type of the specified cue. Valid message types are: 1 - MIDI Voice Message (\"Musical MIDI\") 2 - MIDI Show Control Message (MSC) 3 - MIDI SysEx Message
     */
    async cueCueNumberMessageType(requestParameters: CueCueNumberMessageTypeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberMessageTypeResponse> {
        const response = await this.cueCueNumberMessageTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberMinutesRaw(requestParameters: CueCueNumberMinutesOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberMinutesResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberMinutes.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/minutes`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberMinutesRequestToJSON(requestParameters.cueCueNumberMinutesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberMinutesResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberMinutes(requestParameters: CueCueNumberMinutesOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberMinutesResponse> {
        const response = await this.cueCueNumberMinutesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/mode {number} If number is given, set the fade mode of the specified cue. Mode 0 is absolute fade, mode 1 is relative fade. If number is not given, return the fade mode of the specified cue.
     */
    async cueCueNumberModeRaw(requestParameters: CueCueNumberModeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberModeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberMode.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/mode`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberModeRequestToJSON(requestParameters.cueCueNumberModeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberModeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/mode {number} If number is given, set the fade mode of the specified cue. Mode 0 is absolute fade, mode 1 is relative fade. If number is not given, return the fade mode of the specified cue.
     */
    async cueCueNumberMode(requestParameters: CueCueNumberModeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberModeResponse> {
        const response = await this.cueCueNumberModeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/moveCartCue/{child} {row} {column} If the specified cue is a cart, then move child cue child to position row, column within the cart. child can be the cue number or cue ID of the child cue. row and column must be valid for the specified cart cue.
     */
    async cueCueNumberMoveCartCueChildRaw(requestParameters: CueCueNumberMoveCartCueChildOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberMoveCartCueChildResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberMoveCartCueChild.');
        }

        if (requestParameters.child === null || requestParameters.child === undefined) {
            throw new runtime.RequiredError('child','Required parameter requestParameters.child was null or undefined when calling cueCueNumberMoveCartCueChild.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/moveCartCue/{child}`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"child"}}`, encodeURIComponent(String(requestParameters.child))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberMoveCartCueChildRequestToJSON(requestParameters.cueCueNumberMoveCartCueChildRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberMoveCartCueChildResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/moveCartCue/{child} {row} {column} If the specified cue is a cart, then move child cue child to position row, column within the cart. child can be the cue number or cue ID of the child cue. row and column must be valid for the specified cart cue.
     */
    async cueCueNumberMoveCartCueChild(requestParameters: CueCueNumberMoveCartCueChildOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberMoveCartCueChildResponse> {
        const response = await this.cueCueNumberMoveCartCueChildRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/name {string} If string is given, set the name of the specified cue to string. If not, return the name of the specified cue.
     */
    async cueCueNumberNameRaw(requestParameters: CueCueNumberNameOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberNameResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberName.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/name`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberNameRequestToJSON(requestParameters.cueCueNumberNameRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberNameResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/name {string} If string is given, set the name of the specified cue to string. If not, return the name of the specified cue.
     */
    async cueCueNumberName(requestParameters: CueCueNumberNameOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberNameResponse> {
        const response = await this.cueCueNumberNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/notes {string} If string is given, set the notes of the specified cue to string. If not, return the notes of the specified cue.
     */
    async cueCueNumberNotesRaw(requestParameters: CueCueNumberNotesOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberNotesResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberNotes.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/notes`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberNotesRequestToJSON(requestParameters.cueCueNumberNotesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberNotesResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/notes {string} If string is given, set the notes of the specified cue to string. If not, return the notes of the specified cue.
     */
    async cueCueNumberNotes(requestParameters: CueCueNumberNotesOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberNotesResponse> {
        const response = await this.cueCueNumberNotesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/numChannelsIn Read-only; return the number of input channels in the specified cue.
     */
    async cueCueNumberNumChannelsInRaw(requestParameters: CueCueNumberNumChannelsInRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberNumChannelsInResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberNumChannelsIn.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/numChannelsIn`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberNumChannelsInResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/numChannelsIn Read-only; return the number of input channels in the specified cue.
     */
    async cueCueNumberNumChannelsIn(requestParameters: CueCueNumberNumChannelsInRequest, initOverrides?: RequestInit): Promise<CueCueNumberNumChannelsInResponse> {
        const response = await this.cueCueNumberNumChannelsInRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/number {string} If string is given, set the cue number of the specified cue to string. If not, return the cue number of the specified cue.
     */
    async cueCueNumberNumberRaw(requestParameters: CueCueNumberNumberOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberNumberResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/number`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberNumberRequestToJSON(requestParameters.cueCueNumberNumberRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberNumberResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/number {string} If string is given, set the cue number of the specified cue to string. If not, return the cue number of the specified cue.
     */
    async cueCueNumberNumber(requestParameters: CueCueNumberNumberOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberNumberResponse> {
        const response = await this.cueCueNumberNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/opacity {number} If number is given, set the opacity of the specified cue to number. If not, return the opacity of the specified cue. number can be any decimal number between 0 and 1.
     */
    async cueCueNumberOpacityRaw(requestParameters: CueCueNumberOpacityOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberOpacityResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberOpacity.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/opacity`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberOpacityRequestToJSON(requestParameters.cueCueNumberOpacityRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberOpacityResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/opacity {number} If number is given, set the opacity of the specified cue to number. If not, return the opacity of the specified cue. number can be any decimal number between 0 and 1.
     */
    async cueCueNumberOpacity(requestParameters: CueCueNumberOpacityOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberOpacityResponse> {
        const response = await this.cueCueNumberOpacityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/origin {x} {y} Set the anchor point of the specified cue to (x,y). x and y can be any decimal numbers.
     */
    async cueCueNumberOriginRaw(requestParameters: CueCueNumberOriginOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberOriginResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberOrigin.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/origin`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberOriginRequestToJSON(requestParameters.cueCueNumberOriginRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberOriginResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/origin {x} {y} Set the anchor point of the specified cue to (x,y). x and y can be any decimal numbers.
     */
    async cueCueNumberOrigin(requestParameters: CueCueNumberOriginOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberOriginResponse> {
        const response = await this.cueCueNumberOriginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/originX {number} If number is given, set the X-axis anchor point of the specified cue to number. If not, return the X-axis anchor point of the specified cue. number can be any decimal number.
     */
    async cueCueNumberOriginXRaw(requestParameters: CueCueNumberOriginXOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberOriginXResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberOriginX.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/originX`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberOriginXRequestToJSON(requestParameters.cueCueNumberOriginXRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberOriginXResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/originX {number} If number is given, set the X-axis anchor point of the specified cue to number. If not, return the X-axis anchor point of the specified cue. number can be any decimal number.
     */
    async cueCueNumberOriginX(requestParameters: CueCueNumberOriginXOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberOriginXResponse> {
        const response = await this.cueCueNumberOriginXRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/originY {number} If number is given, set the Y-axis anchor point of the specified cue to number. If not, return the Y-axis anchor point of the specified cue. number can be any decimal number.
     */
    async cueCueNumberOriginYRaw(requestParameters: CueCueNumberOriginYOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberOriginYResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberOriginY.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/originY`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberOriginYRequestToJSON(requestParameters.cueCueNumberOriginYRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberOriginYResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/originY {number} If number is given, set the Y-axis anchor point of the specified cue to number. If not, return the Y-axis anchor point of the specified cue. number can be any decimal number.
     */
    async cueCueNumberOriginY(requestParameters: CueCueNumberOriginYOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberOriginYResponse> {
        const response = await this.cueCueNumberOriginYRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/panic Panic the specified cue. Panicked cues fade out and stop over the panic duration specified in the General section of Workspace Settings.
     */
    async cueCueNumberPanicRaw(requestParameters: CueCueNumberPanicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPanicResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPanic.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/panic`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPanicResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/panic Panic the specified cue. Panicked cues fade out and stop over the panic duration specified in the General section of Workspace Settings.
     */
    async cueCueNumberPanic(requestParameters: CueCueNumberPanicRequest, initOverrides?: RequestInit): Promise<CueCueNumberPanicResponse> {
        const response = await this.cueCueNumberPanicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/panicInTime {number} Panic the specified cue, using number for the panic duration instead of the panic duration specified in Workspace Settings.
     */
    async cueCueNumberPanicInTimeRaw(requestParameters: CueCueNumberPanicInTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPanicInTimeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPanicInTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/panicInTime`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPanicInTimeRequestToJSON(requestParameters.cueCueNumberPanicInTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPanicInTimeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/panicInTime {number} Panic the specified cue, using number for the panic duration instead of the panic duration specified in Workspace Settings.
     */
    async cueCueNumberPanicInTime(requestParameters: CueCueNumberPanicInTimeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPanicInTimeResponse> {
        const response = await this.cueCueNumberPanicInTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/parent Read-only; return the cue ID of the parent of the specified cue. If the specified cue is inside a Group, then the Group is the parent. Otherwise, the cue list or cue cart that contains the cue is the parent.
     */
    async cueCueNumberParentRaw(requestParameters: CueCueNumberParentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberParentResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberParent.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/parent`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberParentResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/parent Read-only; return the cue ID of the parent of the specified cue. If the specified cue is inside a Group, then the Group is the parent. Otherwise, the cue list or cue cart that contains the cue is the parent.
     */
    async cueCueNumberParent(requestParameters: CueCueNumberParentRequest, initOverrides?: RequestInit): Promise<CueCueNumberParentResponse> {
        const response = await this.cueCueNumberParentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/patch {number} If number is given, set the patch of the specified cue. If not, return the patch of the specified cue. number must be a whole number from 1 to 8.
     */
    async cueCueNumberPatchRaw(requestParameters: CueCueNumberPatchOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPatchResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPatch.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/patch`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPatchRequestToJSON(requestParameters.cueCueNumberPatchRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPatchResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/patch {number} If number is given, set the patch of the specified cue. If not, return the patch of the specified cue. number must be a whole number from 1 to 8.
     */
    async cueCueNumberPatch(requestParameters: CueCueNumberPatchOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPatchResponse> {
        const response = await this.cueCueNumberPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/patchList Read-only; return a list of audio patches defined for this workspace: [     {         \"patchNumber\": integer,         \"patchName\": string     } ]
     */
    async cueCueNumberPatchListRaw(requestParameters: CueCueNumberPatchListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPatchListResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPatchList.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/patchList`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPatchListResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/patchList Read-only; return a list of audio patches defined for this workspace: [     {         \"patchNumber\": integer,         \"patchName\": string     } ]
     */
    async cueCueNumberPatchList(requestParameters: CueCueNumberPatchListRequest, initOverrides?: RequestInit): Promise<CueCueNumberPatchListResponse> {
        const response = await this.cueCueNumberPatchListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/pause Pause the specified cue, allowing any AudioUnit effects on the cue to decay naturally. If the specified cue is not playing, this command has no effect.
     */
    async cueCueNumberPauseRaw(requestParameters: CueCueNumberPauseRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPauseResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPause.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/pause`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPauseResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/pause Pause the specified cue, allowing any AudioUnit effects on the cue to decay naturally. If the specified cue is not playing, this command has no effect.
     */
    async cueCueNumberPause(requestParameters: CueCueNumberPauseRequest, initOverrides?: RequestInit): Promise<CueCueNumberPauseResponse> {
        const response = await this.cueCueNumberPauseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/percentActionElapsed Return the elapsed action (as a percentage of the total action) of the specified cue.
     */
    async cueCueNumberPercentActionElapsedRaw(requestParameters: CueCueNumberPercentActionElapsedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPercentActionElapsedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPercentActionElapsed.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/percentActionElapsed`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPercentActionElapsedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/percentActionElapsed Return the elapsed action (as a percentage of the total action) of the specified cue.
     */
    async cueCueNumberPercentActionElapsed(requestParameters: CueCueNumberPercentActionElapsedRequest, initOverrides?: RequestInit): Promise<CueCueNumberPercentActionElapsedResponse> {
        const response = await this.cueCueNumberPercentActionElapsedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/percentPostWaitElapsed Return the elapsed post-wait time (as a percentage of the total post-wait time) of the specified cue.
     */
    async cueCueNumberPercentPostWaitElapsedRaw(requestParameters: CueCueNumberPercentPostWaitElapsedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPercentPostWaitElapsedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPercentPostWaitElapsed.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/percentPostWaitElapsed`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPercentPostWaitElapsedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/percentPostWaitElapsed Return the elapsed post-wait time (as a percentage of the total post-wait time) of the specified cue.
     */
    async cueCueNumberPercentPostWaitElapsed(requestParameters: CueCueNumberPercentPostWaitElapsedRequest, initOverrides?: RequestInit): Promise<CueCueNumberPercentPostWaitElapsedResponse> {
        const response = await this.cueCueNumberPercentPostWaitElapsedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/percentPreWaitElapsed Return the elapsed pre-wait time (as a percentage of the total pre-wait time) of the specified cue.
     */
    async cueCueNumberPercentPreWaitElapsedRaw(requestParameters: CueCueNumberPercentPreWaitElapsedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPercentPreWaitElapsedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPercentPreWaitElapsed.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/percentPreWaitElapsed`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPercentPreWaitElapsedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/percentPreWaitElapsed Return the elapsed pre-wait time (as a percentage of the total pre-wait time) of the specified cue.
     */
    async cueCueNumberPercentPreWaitElapsed(requestParameters: CueCueNumberPercentPreWaitElapsedRequest, initOverrides?: RequestInit): Promise<CueCueNumberPercentPreWaitElapsedResponse> {
        const response = await this.cueCueNumberPercentPreWaitElapsedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/playCount {number} If number is given, set the play count (number of times to loop) of the specified cue to number. If not, return the play count of the specified cue. number can be any whole number greater than zero.
     */
    async cueCueNumberPlayCountRaw(requestParameters: CueCueNumberPlayCountOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPlayCountResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPlayCount.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/playCount`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPlayCountRequestToJSON(requestParameters.cueCueNumberPlayCountRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPlayCountResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/playCount {number} If number is given, set the play count (number of times to loop) of the specified cue to number. If not, return the play count of the specified cue. number can be any whole number greater than zero.
     */
    async cueCueNumberPlayCount(requestParameters: CueCueNumberPlayCountOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPlayCountResponse> {
        const response = await this.cueCueNumberPlayCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/playhead {string} /cue/{cue_number}/playbackPosition {string} If the specified cue is a cue list, set the playhead (playback position) to cue string. If string is not specified, return the cue number of the standing-by cue, or none if there is no cue standing by.
     */
    async cueCueNumberPlaybackPositionRaw(requestParameters: CueCueNumberPlaybackPositionOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPlaybackPositionResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPlaybackPosition.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/playbackPosition`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPlaybackPositionRequestToJSON(requestParameters.cueCueNumberPlaybackPositionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPlaybackPositionResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/playhead {string} /cue/{cue_number}/playbackPosition {string} If the specified cue is a cue list, set the playhead (playback position) to cue string. If string is not specified, return the cue number of the standing-by cue, or none if there is no cue standing by.
     */
    async cueCueNumberPlaybackPosition(requestParameters: CueCueNumberPlaybackPositionOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPlaybackPositionResponse> {
        const response = await this.cueCueNumberPlaybackPositionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/playheadId {string} /cue/{cue_number}/playbackPositionId {string} If the specified cue is a cue list, set the playhead (playback position) to the cue ID string. If string is none, unset the playhead. If string is not specified, return the cue ID of the standing-by cue, or none if there is no cue standing by.
     */
    async cueCueNumberPlaybackPositionIdRaw(requestParameters: CueCueNumberPlaybackPositionIdOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPlaybackPositionIdResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPlaybackPositionId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/playbackPositionId`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPlaybackPositionIdRequestToJSON(requestParameters.cueCueNumberPlaybackPositionIdRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPlaybackPositionIdResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/playheadId {string} /cue/{cue_number}/playbackPositionId {string} If the specified cue is a cue list, set the playhead (playback position) to the cue ID string. If string is none, unset the playhead. If string is not specified, return the cue ID of the standing-by cue, or none if there is no cue standing by.
     */
    async cueCueNumberPlaybackPositionId(requestParameters: CueCueNumberPlaybackPositionIdOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPlaybackPositionIdResponse> {
        const response = await this.cueCueNumberPlaybackPositionIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/playhead {string} /cue/{cue_number}/playbackPosition {string} If the specified cue is a cue list, set the playhead (playback position) to cue string. If string is not specified, return the cue number of the standing-by cue, or none if there is no cue standing by.
     */
    async cueCueNumberPlayheadRaw(requestParameters: CueCueNumberPlayheadOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPlayheadResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPlayhead.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/playhead`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPlayheadRequestToJSON(requestParameters.cueCueNumberPlayheadRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPlayheadResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/playhead {string} /cue/{cue_number}/playbackPosition {string} If the specified cue is a cue list, set the playhead (playback position) to cue string. If string is not specified, return the cue number of the standing-by cue, or none if there is no cue standing by.
     */
    async cueCueNumberPlayhead(requestParameters: CueCueNumberPlayheadOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPlayheadResponse> {
        const response = await this.cueCueNumberPlayheadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/playheadId {string} /cue/{cue_number}/playbackPositionId {string} If the specified cue is a cue list, set the playhead (playback position) to the cue ID string. If string is none, unset the playhead. If string is not specified, return the cue ID of the standing-by cue, or none if there is no cue standing by.
     */
    async cueCueNumberPlayheadIdRaw(requestParameters: CueCueNumberPlayheadIdOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPlayheadIdResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPlayheadId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/playheadId`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPlayheadIdRequestToJSON(requestParameters.cueCueNumberPlayheadIdRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPlayheadIdResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/playheadId {string} /cue/{cue_number}/playbackPositionId {string} If the specified cue is a cue list, set the playhead (playback position) to the cue ID string. If string is none, unset the playhead. If string is not specified, return the cue ID of the standing-by cue, or none if there is no cue standing by.
     */
    async cueCueNumberPlayheadId(requestParameters: CueCueNumberPlayheadIdOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPlayheadIdResponse> {
        const response = await this.cueCueNumberPlayheadIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/playhead/next If the specified cue is a cue list, move the playhead (playback position) to the next cue.
     */
    async cueCueNumberPlayheadNextRaw(requestParameters: CueCueNumberPlayheadNextRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPlayheadNextResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPlayheadNext.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/playhead/next`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPlayheadNextResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/playhead/next If the specified cue is a cue list, move the playhead (playback position) to the next cue.
     */
    async cueCueNumberPlayheadNext(requestParameters: CueCueNumberPlayheadNextRequest, initOverrides?: RequestInit): Promise<CueCueNumberPlayheadNextResponse> {
        const response = await this.cueCueNumberPlayheadNextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/playhead/previous If the specified cue is a cue list, move the playhead (playback position) to the previous cue.
     */
    async cueCueNumberPlayheadPreviousRaw(requestParameters: CueCueNumberPlayheadPreviousRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPlayheadPreviousResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPlayheadPrevious.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/playhead/previous`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPlayheadPreviousResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/playhead/previous If the specified cue is a cue list, move the playhead (playback position) to the previous cue.
     */
    async cueCueNumberPlayheadPrevious(requestParameters: CueCueNumberPlayheadPreviousRequest, initOverrides?: RequestInit): Promise<CueCueNumberPlayheadPreviousResponse> {
        const response = await this.cueCueNumberPlayheadPreviousRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/postWait {number} If number is given, set the post-wait of the specified cue to number. If not, return the post-wait of the specified cue.
     */
    async cueCueNumberPostWaitRaw(requestParameters: CueCueNumberPostWaitOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPostWaitResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPostWait.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/postWait`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPostWaitRequestToJSON(requestParameters.cueCueNumberPostWaitRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPostWaitResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/postWait {number} If number is given, set the post-wait of the specified cue to number. If not, return the post-wait of the specified cue.
     */
    async cueCueNumberPostWait(requestParameters: CueCueNumberPostWaitOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPostWaitResponse> {
        const response = await this.cueCueNumberPostWaitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/postWaitElapsed Return the elapsed post-wait time (in seconds) of the specified cue.
     */
    async cueCueNumberPostWaitElapsedRaw(requestParameters: CueCueNumberPostWaitElapsedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPostWaitElapsedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPostWaitElapsed.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/postWaitElapsed`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPostWaitElapsedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/postWaitElapsed Return the elapsed post-wait time (in seconds) of the specified cue.
     */
    async cueCueNumberPostWaitElapsed(requestParameters: CueCueNumberPostWaitElapsedRequest, initOverrides?: RequestInit): Promise<CueCueNumberPostWaitElapsedResponse> {
        const response = await this.cueCueNumberPostWaitElapsedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/preWait {number} If number is given, set the pre-wait of the specified cue to number. If not, return the pre-wait of the specified cue.
     */
    async cueCueNumberPreWaitRaw(requestParameters: CueCueNumberPreWaitOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPreWaitResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPreWait.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/preWait`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPreWaitRequestToJSON(requestParameters.cueCueNumberPreWaitRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPreWaitResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/preWait {number} If number is given, set the pre-wait of the specified cue to number. If not, return the pre-wait of the specified cue.
     */
    async cueCueNumberPreWait(requestParameters: CueCueNumberPreWaitOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPreWaitResponse> {
        const response = await this.cueCueNumberPreWaitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/preWaitElapsed Return the elapsed pre-wait time (in seconds) of the specified cue.
     */
    async cueCueNumberPreWaitElapsedRaw(requestParameters: CueCueNumberPreWaitElapsedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPreWaitElapsedResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPreWaitElapsed.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/preWaitElapsed`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPreWaitElapsedResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/preWaitElapsed Return the elapsed pre-wait time (in seconds) of the specified cue.
     */
    async cueCueNumberPreWaitElapsed(requestParameters: CueCueNumberPreWaitElapsedRequest, initOverrides?: RequestInit): Promise<CueCueNumberPreWaitElapsedResponse> {
        const response = await this.cueCueNumberPreWaitElapsedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/preserveAspectRatio {number} Get or set the state of the Preserve aspect ratio checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Preserve aspect ratio checkbox of the specified cue.
     */
    async cueCueNumberPreserveAspectRatioRaw(requestParameters: CueCueNumberPreserveAspectRatioOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPreserveAspectRatioResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPreserveAspectRatio.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/preserveAspectRatio`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberPreserveAspectRatioRequestToJSON(requestParameters.cueCueNumberPreserveAspectRatioRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPreserveAspectRatioResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/preserveAspectRatio {number} Get or set the state of the Preserve aspect ratio checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Preserve aspect ratio checkbox of the specified cue.
     */
    async cueCueNumberPreserveAspectRatio(requestParameters: CueCueNumberPreserveAspectRatioOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberPreserveAspectRatioResponse> {
        const response = await this.cueCueNumberPreserveAspectRatioRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/preview Preview the specified cue. Previewing a cue starts it, skipping over its pre-wait time, and does not advance the playhead. Also, if the cue has an auto-follow or auto-continue, the followed or continued cue is not triggered.
     */
    async cueCueNumberPreviewRaw(requestParameters: CueCueNumberPreviewRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPreviewResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPreview.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/preview`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPreviewResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/preview Preview the specified cue. Previewing a cue starts it, skipping over its pre-wait time, and does not advance the playhead. Also, if the cue has an auto-follow or auto-continue, the followed or continued cue is not triggered.
     */
    async cueCueNumberPreview(requestParameters: CueCueNumberPreviewRequest, initOverrides?: RequestInit): Promise<CueCueNumberPreviewResponse> {
        const response = await this.cueCueNumberPreviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/prune /cue/{cue_number}/pruneCommands Prune the command text of the specified cue. Pruning removes any commands which have no effect. These two commands are equivalent.
     */
    async cueCueNumberPruneRaw(requestParameters: CueCueNumberPruneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPruneResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPrune.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/prune`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPruneResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/prune /cue/{cue_number}/pruneCommands Prune the command text of the specified cue. Pruning removes any commands which have no effect. These two commands are equivalent.
     */
    async cueCueNumberPrune(requestParameters: CueCueNumberPruneRequest, initOverrides?: RequestInit): Promise<CueCueNumberPruneResponse> {
        const response = await this.cueCueNumberPruneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/prune /cue/{cue_number}/pruneCommands Prune the command text of the specified cue. Pruning removes any commands which have no effect. These two commands are equivalent.
     */
    async cueCueNumberPruneCommandsRaw(requestParameters: CueCueNumberPruneCommandsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberPruneCommandsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberPruneCommands.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/pruneCommands`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberPruneCommandsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/prune /cue/{cue_number}/pruneCommands Prune the command text of the specified cue. Pruning removes any commands which have no effect. These two commands are equivalent.
     */
    async cueCueNumberPruneCommands(requestParameters: CueCueNumberPruneCommandsRequest, initOverrides?: RequestInit): Promise<CueCueNumberPruneCommandsResponse> {
        const response = await this.cueCueNumberPruneCommandsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/qList {string} If number is given, set the outgoing MSC cue list number of the specified cue to number. If not, return the outgoing MSC cue list number of the specified cue.
     */
    async cueCueNumberQListRaw(requestParameters: CueCueNumberQListOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberQListResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberQList.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/qList`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberQListRequestToJSON(requestParameters.cueCueNumberQListRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberQListResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/qList {string} If number is given, set the outgoing MSC cue list number of the specified cue to number. If not, return the outgoing MSC cue list number of the specified cue.
     */
    async cueCueNumberQList(requestParameters: CueCueNumberQListOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberQListResponse> {
        const response = await this.cueCueNumberQListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/qNumber {string} If number is given, set the outgoing MSC cue number of the specified cue to number. If not, return the outgoing MSC cue number of the specified cue.
     */
    async cueCueNumberQNumberRaw(requestParameters: CueCueNumberQNumberOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberQNumberResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberQNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/qNumber`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberQNumberRequestToJSON(requestParameters.cueCueNumberQNumberRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberQNumberResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/qNumber {string} If number is given, set the outgoing MSC cue number of the specified cue to number. If not, return the outgoing MSC cue number of the specified cue.
     */
    async cueCueNumberQNumber(requestParameters: CueCueNumberQNumberOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberQNumberResponse> {
        const response = await this.cueCueNumberQNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/qPath {string} If number is given, set the outgoing MSC cue path number of the specified cue to number. If not, return the outgoing MSC cue path number of the specified cue.
     */
    async cueCueNumberQPathRaw(requestParameters: CueCueNumberQPathOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberQPathResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberQPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/qPath`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberQPathRequestToJSON(requestParameters.cueCueNumberQPathRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberQPathResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/qPath {string} If number is given, set the outgoing MSC cue path number of the specified cue to number. If not, return the outgoing MSC cue path number of the specified cue.
     */
    async cueCueNumberQPath(requestParameters: CueCueNumberQPathOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberQPathResponse> {
        const response = await this.cueCueNumberQPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/qlabCommand {number} If number is given, set the QLab command of the specified cue to number. If not, return the message type of the specified cue. Valid QLab commands are: 1  - start 2  - stop 3  - hardStop 4  - pause 5  - resume 6  - togglePause 7  - load 8  - preview 9  - reset 10 - panic 11 - number 12 - name 13 - notes 14 - cueTargetNumber 15 - preWait 16 - duration 17 - postWait 18 - continueMode 19 - flagged 20 - armed 21 - colorName
     */
    async cueCueNumberQlabCommandRaw(requestParameters: CueCueNumberQlabCommandOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberQlabCommandResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberQlabCommand.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/qlabCommand`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberQlabCommandRequestToJSON(requestParameters.cueCueNumberQlabCommandRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberQlabCommandResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/qlabCommand {number} If number is given, set the QLab command of the specified cue to number. If not, return the message type of the specified cue. Valid QLab commands are: 1  - start 2  - stop 3  - hardStop 4  - pause 5  - resume 6  - togglePause 7  - load 8  - preview 9  - reset 10 - panic 11 - number 12 - name 13 - notes 14 - cueTargetNumber 15 - preWait 16 - duration 17 - postWait 18 - continueMode 19 - flagged 20 - armed 21 - colorName
     */
    async cueCueNumberQlabCommand(requestParameters: CueCueNumberQlabCommandOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberQlabCommandResponse> {
        const response = await this.cueCueNumberQlabCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/qlabCueNumber {string} If string is given, set the target cue number for the command of the specified cue to string. If not, return the target cue number of the command of the specified cue.
     */
    async cueCueNumberQlabCueNumberRaw(requestParameters: CueCueNumberQlabCueNumberOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberQlabCueNumberResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberQlabCueNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/qlabCueNumber`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberQlabCueNumberRequestToJSON(requestParameters.cueCueNumberQlabCueNumberRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberQlabCueNumberResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/qlabCueNumber {string} If string is given, set the target cue number for the command of the specified cue to string. If not, return the target cue number of the command of the specified cue.
     */
    async cueCueNumberQlabCueNumber(requestParameters: CueCueNumberQlabCueNumberOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberQlabCueNumberResponse> {
        const response = await this.cueCueNumberQlabCueNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/qlabCueParameters {string} If string is given, set the parameters for the command of the specified cue to string. If not, return the parameters of the command of the specified cue.
     */
    async cueCueNumberQlabCueParametersRaw(requestParameters: CueCueNumberQlabCueParametersOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberQlabCueParametersResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberQlabCueParameters.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/qlabCueParameters`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberQlabCueParametersRequestToJSON(requestParameters.cueCueNumberQlabCueParametersRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberQlabCueParametersResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/qlabCueParameters {string} If string is given, set the parameters for the command of the specified cue to string. If not, return the parameters of the command of the specified cue.
     */
    async cueCueNumberQlabCueParameters(requestParameters: CueCueNumberQlabCueParametersOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberQlabCueParametersResponse> {
        const response = await this.cueCueNumberQlabCueParametersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/quaternion {number number number number} If four numbers are given, set the rotation of the specified cue. If not, return an array of four numbers representing the cues rotation as a quaternion. number can be any decimal number. Caution: you need to understand quaternion math to make any meaningful use of this method. Quaternion math is really hard. Good luck!
     */
    async cueCueNumberQuaternionRaw(requestParameters: CueCueNumberQuaternionOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberQuaternionResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberQuaternion.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/quaternion`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberQuaternionRequestToJSON(requestParameters.cueCueNumberQuaternionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberQuaternionResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/quaternion {number number number number} If four numbers are given, set the rotation of the specified cue. If not, return an array of four numbers representing the cues rotation as a quaternion. number can be any decimal number. Caution: you need to understand quaternion math to make any meaningful use of this method. Quaternion math is really hard. Good luck!
     */
    async cueCueNumberQuaternion(requestParameters: CueCueNumberQuaternionOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberQuaternionResponse> {
        const response = await this.cueCueNumberQuaternionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/rate {number} If number is given, set the rate of the specified cue. If not, return the rate of the specified cue.
     */
    async cueCueNumberRateRaw(requestParameters: CueCueNumberRateOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberRateResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberRate.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/rate`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberRateRequestToJSON(requestParameters.cueCueNumberRateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberRateResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/rate {number} If number is given, set the rate of the specified cue. If not, return the rate of the specified cue.
     */
    async cueCueNumberRate(requestParameters: CueCueNumberRateOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberRateResponse> {
        const response = await this.cueCueNumberRateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/rawString {string} If string is given, set the MIDI SysEx of the specified cue to string. If not, return the MIDI SysEx string of the specified cue. string must be a valid SysEx string, formatted in hexadecimal, and omitting the starting F0 and ending F7.
     */
    async cueCueNumberRawStringRaw(requestParameters: CueCueNumberRawStringOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberRawStringResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberRawString.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/rawString`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberRawStringRequestToJSON(requestParameters.cueCueNumberRawStringRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberRawStringResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/rawString {string} If string is given, set the MIDI SysEx of the specified cue to string. If not, return the MIDI SysEx string of the specified cue. string must be a valid SysEx string, formatted in hexadecimal, and omitting the starting F0 and ending F7.
     */
    async cueCueNumberRawString(requestParameters: CueCueNumberRawStringOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberRawStringResponse> {
        const response = await this.cueCueNumberRawStringRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/removeLightCommandsMatching {string} If the specified cue contains a command that matches string, remove that command. Otherwise, do nothing.
     */
    async cueCueNumberRemoveLightCommandsMatchingRaw(requestParameters: CueCueNumberRemoveLightCommandsMatchingOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberRemoveLightCommandsMatchingResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberRemoveLightCommandsMatching.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/removeLightCommandsMatching`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberRemoveLightCommandsMatchingRequestToJSON(requestParameters.cueCueNumberRemoveLightCommandsMatchingRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberRemoveLightCommandsMatchingResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/removeLightCommandsMatching {string} If the specified cue contains a command that matches string, remove that command. Otherwise, do nothing.
     */
    async cueCueNumberRemoveLightCommandsMatching(requestParameters: CueCueNumberRemoveLightCommandsMatchingOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberRemoveLightCommandsMatchingResponse> {
        const response = await this.cueCueNumberRemoveLightCommandsMatchingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/replaceLightCommand {old_command} {new_command} If the specified cue contains a light command matching old_command, replace that command with new_command. Both old_command and new_command must be strings which are valid light commands. This method replaces /updateLightCommand starting in QLab 4.4.
     */
    async cueCueNumberReplaceLightCommandRaw(requestParameters: CueCueNumberReplaceLightCommandOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberReplaceLightCommandResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberReplaceLightCommand.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/replaceLightCommand`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberReplaceLightCommandRequestToJSON(requestParameters.cueCueNumberReplaceLightCommandRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberReplaceLightCommandResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/replaceLightCommand {old_command} {new_command} If the specified cue contains a light command matching old_command, replace that command with new_command. Both old_command and new_command must be strings which are valid light commands. This method replaces /updateLightCommand starting in QLab 4.4.
     */
    async cueCueNumberReplaceLightCommand(requestParameters: CueCueNumberReplaceLightCommandOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberReplaceLightCommandResponse> {
        const response = await this.cueCueNumberReplaceLightCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/reset Reset the specified cue. Resetting a cue returns any temporary changes (such as those caused by a live OSC method) to be reverted.
     */
    async cueCueNumberResetRaw(requestParameters: CueCueNumberResetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberResetResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberReset.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/reset`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberResetResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/reset Reset the specified cue. Resetting a cue returns any temporary changes (such as those caused by a live OSC method) to be reverted.
     */
    async cueCueNumberReset(requestParameters: CueCueNumberResetRequest, initOverrides?: RequestInit): Promise<CueCueNumberResetResponse> {
        const response = await this.cueCueNumberResetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/resetRotation Reset the rotation of the specified cue. If the specified cue is using single-axis rotation, this has no visible effect; use /rotation instead.
     */
    async cueCueNumberResetRotationRaw(requestParameters: CueCueNumberResetRotationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberResetRotationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberResetRotation.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/resetRotation`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberResetRotationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/resetRotation Reset the rotation of the specified cue. If the specified cue is using single-axis rotation, this has no visible effect; use /rotation instead.
     */
    async cueCueNumberResetRotation(requestParameters: CueCueNumberResetRotationRequest, initOverrides?: RequestInit): Promise<CueCueNumberResetRotationResponse> {
        const response = await this.cueCueNumberResetRotationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/resume Resume the specified cue. If the specified cue is not paused, this command has no effect.
     */
    async cueCueNumberResumeRaw(requestParameters: CueCueNumberResumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberResumeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberResume.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/resume`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberResumeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/resume Resume the specified cue. If the specified cue is not paused, this command has no effect.
     */
    async cueCueNumberResume(requestParameters: CueCueNumberResumeRequest, initOverrides?: RequestInit): Promise<CueCueNumberResumeResponse> {
        const response = await this.cueCueNumberResumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/rotateX {number} /cue/{cue_number}/rotateY {number} /cue/{cue_number}/rotateZ {number} If the specified cue is using 3D orientation, add number to the current quaternion rotation of the specified cue. number can be any decimal number. If the specified cue is using single-axis rotation, this method has no effect; use /rotation instead.
     */
    async cueCueNumberRotateXRaw(requestParameters: CueCueNumberRotateXOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberRotateXResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberRotateX.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/rotateX`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberRotateXRequestToJSON(requestParameters.cueCueNumberRotateXRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberRotateXResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/rotateX {number} /cue/{cue_number}/rotateY {number} /cue/{cue_number}/rotateZ {number} If the specified cue is using 3D orientation, add number to the current quaternion rotation of the specified cue. number can be any decimal number. If the specified cue is using single-axis rotation, this method has no effect; use /rotation instead.
     */
    async cueCueNumberRotateX(requestParameters: CueCueNumberRotateXOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberRotateXResponse> {
        const response = await this.cueCueNumberRotateXRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/rotateX {number} /cue/{cue_number}/rotateY {number} /cue/{cue_number}/rotateZ {number} If the specified cue is using 3D orientation, add number to the current quaternion rotation of the specified cue. number can be any decimal number. If the specified cue is using single-axis rotation, this method has no effect; use /rotation instead.
     */
    async cueCueNumberRotateYRaw(requestParameters: CueCueNumberRotateYOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberRotateYResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberRotateY.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/rotateY`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberRotateYRequestToJSON(requestParameters.cueCueNumberRotateYRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberRotateYResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/rotateX {number} /cue/{cue_number}/rotateY {number} /cue/{cue_number}/rotateZ {number} If the specified cue is using 3D orientation, add number to the current quaternion rotation of the specified cue. number can be any decimal number. If the specified cue is using single-axis rotation, this method has no effect; use /rotation instead.
     */
    async cueCueNumberRotateY(requestParameters: CueCueNumberRotateYOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberRotateYResponse> {
        const response = await this.cueCueNumberRotateYRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/rotateX {number} /cue/{cue_number}/rotateY {number} /cue/{cue_number}/rotateZ {number} If the specified cue is using 3D orientation, add number to the current quaternion rotation of the specified cue. number can be any decimal number. If the specified cue is using single-axis rotation, this method has no effect; use /rotation instead.
     */
    async cueCueNumberRotateZRaw(requestParameters: CueCueNumberRotateZOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberRotateZResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberRotateZ.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/rotateZ`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberRotateZRequestToJSON(requestParameters.cueCueNumberRotateZRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberRotateZResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/rotateX {number} /cue/{cue_number}/rotateY {number} /cue/{cue_number}/rotateZ {number} If the specified cue is using 3D orientation, add number to the current quaternion rotation of the specified cue. number can be any decimal number. If the specified cue is using single-axis rotation, this method has no effect; use /rotation instead.
     */
    async cueCueNumberRotateZ(requestParameters: CueCueNumberRotateZOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberRotateZResponse> {
        const response = await this.cueCueNumberRotateZRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/rotation {number} If number is given, and if the specified cue is using single-axis rotation, set the rotation in degrees to number. If no number is given, return the current rotation of the specified cue. For 3D orientation, use /quaternion or /rotate{N}.
     */
    async cueCueNumberRotationRaw(requestParameters: CueCueNumberRotationOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberRotationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberRotation.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/rotation`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberRotationRequestToJSON(requestParameters.cueCueNumberRotationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberRotationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/rotation {number} If number is given, and if the specified cue is using single-axis rotation, set the rotation in degrees to number. If no number is given, return the current rotation of the specified cue. For 3D orientation, use /quaternion or /rotate{N}.
     */
    async cueCueNumberRotation(requestParameters: CueCueNumberRotationOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberRotationResponse> {
        const response = await this.cueCueNumberRotationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/rotationType {number} If number is given, set the rotation type of the specified cue to number. If not, return the rotation type of the specified cue. Valid rotation types are: 0 - 3D orientation 1 - X rotation 2 - Y rotation 3 - Z rotation
     */
    async cueCueNumberRotationTypeRaw(requestParameters: CueCueNumberRotationTypeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberRotationTypeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberRotationType.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/rotationType`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberRotationTypeRequestToJSON(requestParameters.cueCueNumberRotationTypeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberRotationTypeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/rotationType {number} If number is given, set the rotation type of the specified cue to number. If not, return the rotation type of the specified cue. Valid rotation types are: 0 - 3D orientation 1 - X rotation 2 - Y rotation 3 - Z rotation
     */
    async cueCueNumberRotationType(requestParameters: CueCueNumberRotationTypeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberRotationTypeResponse> {
        const response = await this.cueCueNumberRotationTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/safeSort /cue/{cue_number}/safeSortCommands Lexically (alphabetically) sort the command text of the specified cue, as long as sorting doesnt change the cues output. These two commands are equivalent.
     */
    async cueCueNumberSafeSortRaw(requestParameters: CueCueNumberSafeSortRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSafeSortResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSafeSort.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/safeSort`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSafeSortResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/safeSort /cue/{cue_number}/safeSortCommands Lexically (alphabetically) sort the command text of the specified cue, as long as sorting doesnt change the cues output. These two commands are equivalent.
     */
    async cueCueNumberSafeSort(requestParameters: CueCueNumberSafeSortRequest, initOverrides?: RequestInit): Promise<CueCueNumberSafeSortResponse> {
        const response = await this.cueCueNumberSafeSortRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/safeSort /cue/{cue_number}/safeSortCommands Lexically (alphabetically) sort the command text of the specified cue, as long as sorting doesnt change the cues output. These two commands are equivalent.
     */
    async cueCueNumberSafeSortCommandsRaw(requestParameters: CueCueNumberSafeSortCommandsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSafeSortCommandsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSafeSortCommands.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/safeSortCommands`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSafeSortCommandsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/safeSort /cue/{cue_number}/safeSortCommands Lexically (alphabetically) sort the command text of the specified cue, as long as sorting doesnt change the cues output. These two commands are equivalent.
     */
    async cueCueNumberSafeSortCommands(requestParameters: CueCueNumberSafeSortCommandsRequest, initOverrides?: RequestInit): Promise<CueCueNumberSafeSortCommandsResponse> {
        const response = await this.cueCueNumberSafeSortCommandsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/scale {x} {y} If x and y are given, set the scale of the specified cue to (x,y). If not, return the current scale of the specified cue. x and y can be any decimal numbers.
     */
    async cueCueNumberScaleRaw(requestParameters: CueCueNumberScaleOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberScaleResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberScale.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/scale`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberScaleRequestToJSON(requestParameters.cueCueNumberScaleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberScaleResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/scale {x} {y} If x and y are given, set the scale of the specified cue to (x,y). If not, return the current scale of the specified cue. x and y can be any decimal numbers.
     */
    async cueCueNumberScale(requestParameters: CueCueNumberScaleOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberScaleResponse> {
        const response = await this.cueCueNumberScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/scaleX {number} If number is given, set the X-axis scale of the specified cue to number. If not, return the X-axis scale of the specified cue. number can be any decimal number.
     */
    async cueCueNumberScaleXRaw(requestParameters: CueCueNumberScaleXOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberScaleXResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberScaleX.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/scaleX`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberScaleXRequestToJSON(requestParameters.cueCueNumberScaleXRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberScaleXResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/scaleX {number} If number is given, set the X-axis scale of the specified cue to number. If not, return the X-axis scale of the specified cue. number can be any decimal number.
     */
    async cueCueNumberScaleX(requestParameters: CueCueNumberScaleXOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberScaleXResponse> {
        const response = await this.cueCueNumberScaleXRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/scaleY {number} If number is given, set the Y-axis scale of the specified cue to number. If not, return the Y-axis scale of the specified cue. number can be any decimal number.
     */
    async cueCueNumberScaleYRaw(requestParameters: CueCueNumberScaleYOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberScaleYResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberScaleY.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/scaleY`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberScaleYRequestToJSON(requestParameters.cueCueNumberScaleYRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberScaleYResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/scaleY {number} If number is given, set the Y-axis scale of the specified cue to number. If not, return the Y-axis scale of the specified cue. number can be any decimal number.
     */
    async cueCueNumberScaleY(requestParameters: CueCueNumberScaleYOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberScaleYResponse> {
        const response = await this.cueCueNumberScaleYRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/scriptSource Read-only; return the contents of the script of the specified cue.
     */
    async cueCueNumberScriptSourceRaw(requestParameters: CueCueNumberScriptSourceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberScriptSourceResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberScriptSource.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/scriptSource`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberScriptSourceResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/scriptSource Read-only; return the contents of the script of the specified cue.
     */
    async cueCueNumberScriptSource(requestParameters: CueCueNumberScriptSourceRequest, initOverrides?: RequestInit): Promise<CueCueNumberScriptSourceResponse> {
        const response = await this.cueCueNumberScriptSourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/secondTriggerAction {number} If number is given, set the second trigger action of the specified cue to number. If not, return the second trigger action of the specified cue. Valid actions are: 0 - does nothing 1 - panics 2 - stops 3 - hard stops 4 - hard stops & restarts
     */
    async cueCueNumberSecondTriggerActionRaw(requestParameters: CueCueNumberSecondTriggerActionOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSecondTriggerActionResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSecondTriggerAction.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/secondTriggerAction`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSecondTriggerActionRequestToJSON(requestParameters.cueCueNumberSecondTriggerActionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSecondTriggerActionResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/secondTriggerAction {number} If number is given, set the second trigger action of the specified cue to number. If not, return the second trigger action of the specified cue. Valid actions are: 0 - does nothing 1 - panics 2 - stops 3 - hard stops 4 - hard stops & restarts
     */
    async cueCueNumberSecondTriggerAction(requestParameters: CueCueNumberSecondTriggerActionOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSecondTriggerActionResponse> {
        const response = await this.cueCueNumberSecondTriggerActionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/secondTriggerOnRelease {number} Get or set the state of the Second trigger on release checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Second trigger on release checkbox of the specified cue.
     */
    async cueCueNumberSecondTriggerOnReleaseRaw(requestParameters: CueCueNumberSecondTriggerOnReleaseOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSecondTriggerOnReleaseResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSecondTriggerOnRelease.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/secondTriggerOnRelease`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSecondTriggerOnReleaseRequestToJSON(requestParameters.cueCueNumberSecondTriggerOnReleaseRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSecondTriggerOnReleaseResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/secondTriggerOnRelease {number} Get or set the state of the Second trigger on release checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Second trigger on release checkbox of the specified cue.
     */
    async cueCueNumberSecondTriggerOnRelease(requestParameters: CueCueNumberSecondTriggerOnReleaseOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSecondTriggerOnReleaseResponse> {
        const response = await this.cueCueNumberSecondTriggerOnReleaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberSecondsRaw(requestParameters: CueCueNumberSecondsOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSecondsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSeconds.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/seconds`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSecondsRequestToJSON(requestParameters.cueCueNumberSecondsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSecondsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberSeconds(requestParameters: CueCueNumberSecondsOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSecondsResponse> {
        const response = await this.cueCueNumberSecondsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/setDefaultLevels Set the audio levels of the specified cue to the workspace default levels.
     */
    async cueCueNumberSetDefaultLevelsRaw(requestParameters: CueCueNumberSetDefaultLevelsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSetDefaultLevelsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSetDefaultLevels.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/setDefaultLevels`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSetDefaultLevelsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/setDefaultLevels Set the audio levels of the specified cue to the workspace default levels.
     */
    async cueCueNumberSetDefaultLevels(requestParameters: CueCueNumberSetDefaultLevelsRequest, initOverrides?: RequestInit): Promise<CueCueNumberSetDefaultLevelsResponse> {
        const response = await this.cueCueNumberSetDefaultLevelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/setGeometryFromTarget Set the geometry of the specified cue to the geometry of its target cue. If the target cue has no geometry then this command has no effect.
     */
    async cueCueNumberSetGeometryFromTargetRaw(requestParameters: CueCueNumberSetGeometryFromTargetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSetGeometryFromTargetResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSetGeometryFromTarget.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/setGeometryFromTarget`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSetGeometryFromTargetResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/setGeometryFromTarget Set the geometry of the specified cue to the geometry of its target cue. If the target cue has no geometry then this command has no effect.
     */
    async cueCueNumberSetGeometryFromTarget(requestParameters: CueCueNumberSetGeometryFromTargetRequest, initOverrides?: RequestInit): Promise<CueCueNumberSetGeometryFromTargetResponse> {
        const response = await this.cueCueNumberSetGeometryFromTargetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/setLevelsFromTarget Set the audio levels, trim, and gangs of the specified cue to match those of its target. If the target cue has no audio levels then this command has no effect.
     */
    async cueCueNumberSetLevelsFromTargetRaw(requestParameters: CueCueNumberSetLevelsFromTargetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSetLevelsFromTargetResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSetLevelsFromTarget.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/setLevelsFromTarget`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSetLevelsFromTargetResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/setLevelsFromTarget Set the audio levels, trim, and gangs of the specified cue to match those of its target. If the target cue has no audio levels then this command has no effect.
     */
    async cueCueNumberSetLevelsFromTarget(requestParameters: CueCueNumberSetLevelsFromTargetRequest, initOverrides?: RequestInit): Promise<CueCueNumberSetLevelsFromTargetResponse> {
        const response = await this.cueCueNumberSetLevelsFromTargetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/setLight {string} {setting} Add a command to the specified cue in the form string = setting. string can be the name of an instrument or group, with or without a parameter. setting must be an acceptable value for the specified parameter of the specified instrument or group.
     */
    async cueCueNumberSetLightRaw(requestParameters: CueCueNumberSetLightOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSetLightResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSetLight.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/setLight`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSetLightRequestToJSON(requestParameters.cueCueNumberSetLightRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSetLightResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/setLight {string} {setting} Add a command to the specified cue in the form string = setting. string can be the name of an instrument or group, with or without a parameter. setting must be an acceptable value for the specified parameter of the specified instrument or group.
     */
    async cueCueNumberSetLight(requestParameters: CueCueNumberSetLightOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSetLightResponse> {
        const response = await this.cueCueNumberSetLightRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/setSilentLevels Set the audio levels of the specified cue to silent.
     */
    async cueCueNumberSetSilentLevelsRaw(requestParameters: CueCueNumberSetSilentLevelsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSetSilentLevelsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSetSilentLevels.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/setSilentLevels`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSetSilentLevelsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/setSilentLevels Set the audio levels of the specified cue to silent.
     */
    async cueCueNumberSetSilentLevels(requestParameters: CueCueNumberSetSilentLevelsRequest, initOverrides?: RequestInit): Promise<CueCueNumberSetSilentLevelsResponse> {
        const response = await this.cueCueNumberSetSilentLevelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarker {index} {time} {play_count} /cue/{cue_number}/sliceMarker/{index} {time} {play_count} Set the marker time and play count of slice index of the specified cue. time can be any positive whole or decimal number. play_count can be any positive whole number, or -1 to set the slice to infinite loop.
     */
    async cueCueNumberSliceMarkerRaw(requestParameters: CueCueNumberSliceMarkerOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkerResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarker.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarker`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkerRequestToJSON(requestParameters.cueCueNumberSliceMarkerRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkerResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarker {index} {time} {play_count} /cue/{cue_number}/sliceMarker/{index} {time} {play_count} Set the marker time and play count of slice index of the specified cue. time can be any positive whole or decimal number. play_count can be any positive whole number, or -1 to set the slice to infinite loop.
     */
    async cueCueNumberSliceMarker(requestParameters: CueCueNumberSliceMarkerOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkerResponse> {
        const response = await this.cueCueNumberSliceMarkerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarker {index} {time} {play_count} /cue/{cue_number}/sliceMarker/{index} {time} {play_count} Set the marker time and play count of slice index of the specified cue. time can be any positive whole or decimal number. play_count can be any positive whole number, or -1 to set the slice to infinite loop.
     */
    async cueCueNumberSliceMarkerIndexRaw(requestParameters: CueCueNumberSliceMarkerIndexOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkerIndexResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkerIndex.');
        }

        if (requestParameters.index === null || requestParameters.index === undefined) {
            throw new runtime.RequiredError('index','Required parameter requestParameters.index was null or undefined when calling cueCueNumberSliceMarkerIndex.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarker/{index}`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"index"}}`, encodeURIComponent(String(requestParameters.index))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkerIndexRequestToJSON(requestParameters.cueCueNumberSliceMarkerIndexRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkerIndexResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarker {index} {time} {play_count} /cue/{cue_number}/sliceMarker/{index} {time} {play_count} Set the marker time and play count of slice index of the specified cue. time can be any positive whole or decimal number. play_count can be any positive whole number, or -1 to set the slice to infinite loop.
     */
    async cueCueNumberSliceMarkerIndex(requestParameters: CueCueNumberSliceMarkerIndexOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkerIndexResponse> {
        const response = await this.cueCueNumberSliceMarkerIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/playCount {play_count} Set the play count of slice index of the specified cue. play_count can be any positive whole number, or -1 to set the slice to infinite loop.
     */
    async cueCueNumberSliceMarkerIndexPlayCountRaw(requestParameters: CueCueNumberSliceMarkerIndexPlayCountOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkerIndexPlayCountResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkerIndexPlayCount.');
        }

        if (requestParameters.index === null || requestParameters.index === undefined) {
            throw new runtime.RequiredError('index','Required parameter requestParameters.index was null or undefined when calling cueCueNumberSliceMarkerIndexPlayCount.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarker/{index}/playCount`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"index"}}`, encodeURIComponent(String(requestParameters.index))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkerIndexPlayCountRequestToJSON(requestParameters.cueCueNumberSliceMarkerIndexPlayCountRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkerIndexPlayCountResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/playCount {play_count} Set the play count of slice index of the specified cue. play_count can be any positive whole number, or -1 to set the slice to infinite loop.
     */
    async cueCueNumberSliceMarkerIndexPlayCount(requestParameters: CueCueNumberSliceMarkerIndexPlayCountOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkerIndexPlayCountResponse> {
        const response = await this.cueCueNumberSliceMarkerIndexPlayCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/playCount/+ {delta} /cue/{cue_number}/sliceMarker/{index}/playCount/- {delta} Add or subtract delta to/from the play count of slice index in the specified cue. delta can be any positive whole number.
     */
    async cueCueNumberSliceMarkerIndexPlayCountMinusRaw(requestParameters: CueCueNumberSliceMarkerIndexPlayCountMinusOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkerIndexPlayCountMinusResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkerIndexPlayCountMinus.');
        }

        if (requestParameters.index === null || requestParameters.index === undefined) {
            throw new runtime.RequiredError('index','Required parameter requestParameters.index was null or undefined when calling cueCueNumberSliceMarkerIndexPlayCountMinus.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarker/{index}/playCount/-`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"index"}}`, encodeURIComponent(String(requestParameters.index))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkerIndexPlayCountMinusRequestToJSON(requestParameters.cueCueNumberSliceMarkerIndexPlayCountMinusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkerIndexPlayCountMinusResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/playCount/+ {delta} /cue/{cue_number}/sliceMarker/{index}/playCount/- {delta} Add or subtract delta to/from the play count of slice index in the specified cue. delta can be any positive whole number.
     */
    async cueCueNumberSliceMarkerIndexPlayCountMinus(requestParameters: CueCueNumberSliceMarkerIndexPlayCountMinusOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkerIndexPlayCountMinusResponse> {
        const response = await this.cueCueNumberSliceMarkerIndexPlayCountMinusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/playCount/+ {delta} /cue/{cue_number}/sliceMarker/{index}/playCount/- {delta} Add or subtract delta to/from the play count of slice index in the specified cue. delta can be any positive whole number.
     */
    async cueCueNumberSliceMarkerIndexPlayCountPlusRaw(requestParameters: CueCueNumberSliceMarkerIndexPlayCountPlusOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkerIndexPlayCountPlusResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkerIndexPlayCountPlus.');
        }

        if (requestParameters.index === null || requestParameters.index === undefined) {
            throw new runtime.RequiredError('index','Required parameter requestParameters.index was null or undefined when calling cueCueNumberSliceMarkerIndexPlayCountPlus.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarker/{index}/playCount/+`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"index"}}`, encodeURIComponent(String(requestParameters.index))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkerIndexPlayCountPlusRequestToJSON(requestParameters.cueCueNumberSliceMarkerIndexPlayCountPlusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkerIndexPlayCountPlusResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/playCount/+ {delta} /cue/{cue_number}/sliceMarker/{index}/playCount/- {delta} Add or subtract delta to/from the play count of slice index in the specified cue. delta can be any positive whole number.
     */
    async cueCueNumberSliceMarkerIndexPlayCountPlus(requestParameters: CueCueNumberSliceMarkerIndexPlayCountPlusOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkerIndexPlayCountPlusResponse> {
        const response = await this.cueCueNumberSliceMarkerIndexPlayCountPlusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/time {time} Set the marker time of slice index of the specified cue. time can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkerIndexTimeRaw(requestParameters: CueCueNumberSliceMarkerIndexTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkerIndexTimeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkerIndexTime.');
        }

        if (requestParameters.index === null || requestParameters.index === undefined) {
            throw new runtime.RequiredError('index','Required parameter requestParameters.index was null or undefined when calling cueCueNumberSliceMarkerIndexTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarker/{index}/time`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"index"}}`, encodeURIComponent(String(requestParameters.index))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkerIndexTimeRequestToJSON(requestParameters.cueCueNumberSliceMarkerIndexTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkerIndexTimeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/time {time} Set the marker time of slice index of the specified cue. time can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkerIndexTime(requestParameters: CueCueNumberSliceMarkerIndexTimeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkerIndexTimeResponse> {
        const response = await this.cueCueNumberSliceMarkerIndexTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/time/+ {delta} /cue/{cue_number}/sliceMarker/{index}/time/- {delta} Add or subtract delta to/from the marker time of slice index in the specified cue. delta can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkerIndexTimeMinusRaw(requestParameters: CueCueNumberSliceMarkerIndexTimeMinusOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkerIndexTimeMinusResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkerIndexTimeMinus.');
        }

        if (requestParameters.index === null || requestParameters.index === undefined) {
            throw new runtime.RequiredError('index','Required parameter requestParameters.index was null or undefined when calling cueCueNumberSliceMarkerIndexTimeMinus.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarker/{index}/time/-`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"index"}}`, encodeURIComponent(String(requestParameters.index))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkerIndexTimeMinusRequestToJSON(requestParameters.cueCueNumberSliceMarkerIndexTimeMinusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkerIndexTimeMinusResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/time/+ {delta} /cue/{cue_number}/sliceMarker/{index}/time/- {delta} Add or subtract delta to/from the marker time of slice index in the specified cue. delta can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkerIndexTimeMinus(requestParameters: CueCueNumberSliceMarkerIndexTimeMinusOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkerIndexTimeMinusResponse> {
        const response = await this.cueCueNumberSliceMarkerIndexTimeMinusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/time/+ {delta} /cue/{cue_number}/sliceMarker/{index}/time/- {delta} Add or subtract delta to/from the marker time of slice index in the specified cue. delta can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkerIndexTimePlusRaw(requestParameters: CueCueNumberSliceMarkerIndexTimePlusOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkerIndexTimePlusResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkerIndexTimePlus.');
        }

        if (requestParameters.index === null || requestParameters.index === undefined) {
            throw new runtime.RequiredError('index','Required parameter requestParameters.index was null or undefined when calling cueCueNumberSliceMarkerIndexTimePlus.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarker/{index}/time/+`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"index"}}`, encodeURIComponent(String(requestParameters.index))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkerIndexTimePlusRequestToJSON(requestParameters.cueCueNumberSliceMarkerIndexTimePlusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkerIndexTimePlusResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarker/{index}/time/+ {delta} /cue/{cue_number}/sliceMarker/{index}/time/- {delta} Add or subtract delta to/from the marker time of slice index in the specified cue. delta can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkerIndexTimePlus(requestParameters: CueCueNumberSliceMarkerIndexTimePlusOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkerIndexTimePlusResponse> {
        const response = await this.cueCueNumberSliceMarkerIndexTimePlusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarkers Read-only; return a JSON dictionary (or array of dictionaries) listing the marker time and play count of all slices of the specified cue: {     \"time\": number,     \"playCount\": number } Note: slices end with slice markers. Therefore, time corresponds to the end time of the slice whose playCount is being reported. 
     */
    async cueCueNumberSliceMarkersRaw(requestParameters: CueCueNumberSliceMarkersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkersResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkers.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarkers`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkersResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarkers Read-only; return a JSON dictionary (or array of dictionaries) listing the marker time and play count of all slices of the specified cue: {     \"time\": number,     \"playCount\": number } Note: slices end with slice markers. Therefore, time corresponds to the end time of the slice whose playCount is being reported. 
     */
    async cueCueNumberSliceMarkers(requestParameters: CueCueNumberSliceMarkersRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkersResponse> {
        const response = await this.cueCueNumberSliceMarkersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarkers/time/+ {delta} /cue/{cue_number}/sliceMarkers/time/- {delta} Add or subtract delta to/from the marker time of all slices in the specified cue. delta can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkersTimeMinusRaw(requestParameters: CueCueNumberSliceMarkersTimeMinusOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkersTimeMinusResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkersTimeMinus.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarkers/time/-`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkersTimeMinusRequestToJSON(requestParameters.cueCueNumberSliceMarkersTimeMinusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkersTimeMinusResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarkers/time/+ {delta} /cue/{cue_number}/sliceMarkers/time/- {delta} Add or subtract delta to/from the marker time of all slices in the specified cue. delta can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkersTimeMinus(requestParameters: CueCueNumberSliceMarkersTimeMinusOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkersTimeMinusResponse> {
        const response = await this.cueCueNumberSliceMarkersTimeMinusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliceMarkers/time/+ {delta} /cue/{cue_number}/sliceMarkers/time/- {delta} Add or subtract delta to/from the marker time of all slices in the specified cue. delta can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkersTimePlusRaw(requestParameters: CueCueNumberSliceMarkersTimePlusOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliceMarkersTimePlusResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliceMarkersTimePlus.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliceMarkers/time/+`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliceMarkersTimePlusRequestToJSON(requestParameters.cueCueNumberSliceMarkersTimePlusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliceMarkersTimePlusResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliceMarkers/time/+ {delta} /cue/{cue_number}/sliceMarkers/time/- {delta} Add or subtract delta to/from the marker time of all slices in the specified cue. delta can be any positive whole or decimal number.
     */
    async cueCueNumberSliceMarkersTimePlus(requestParameters: CueCueNumberSliceMarkersTimePlusOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliceMarkersTimePlusResponse> {
        const response = await this.cueCueNumberSliceMarkersTimePlusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliderLevel {channel} {decibel} /cue/{cue_number}/sliderLevel/{channel} {decibel} Get or set a single output slider volume level. channel is either an integer from 0 to 64, or a string (the cue output name). 0 is the cue master slider. decibel is an optional whole or decimal number. When present it is the decibel value to set. If decibel is sent as a string (e.g. -inf) QLab will use the minimum decibel value set in workspace settings. If no decibel is given, return the volume level of the specified output slider.
     */
    async cueCueNumberSliderLevelRaw(requestParameters: CueCueNumberSliderLevelOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliderLevelResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliderLevel.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliderLevel`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliderLevelRequestToJSON(requestParameters.cueCueNumberSliderLevelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliderLevelResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliderLevel {channel} {decibel} /cue/{cue_number}/sliderLevel/{channel} {decibel} Get or set a single output slider volume level. channel is either an integer from 0 to 64, or a string (the cue output name). 0 is the cue master slider. decibel is an optional whole or decimal number. When present it is the decibel value to set. If decibel is sent as a string (e.g. -inf) QLab will use the minimum decibel value set in workspace settings. If no decibel is given, return the volume level of the specified output slider.
     */
    async cueCueNumberSliderLevel(requestParameters: CueCueNumberSliderLevelOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliderLevelResponse> {
        const response = await this.cueCueNumberSliderLevelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliderLevel {channel} {decibel} /cue/{cue_number}/sliderLevel/{channel} {decibel} Get or set a single output slider volume level. channel is either an integer from 0 to 64, or a string (the cue output name). 0 is the cue master slider. decibel is an optional whole or decimal number. When present it is the decibel value to set. If decibel is sent as a string (e.g. -inf) QLab will use the minimum decibel value set in workspace settings. If no decibel is given, return the volume level of the specified output slider.
     */
    async cueCueNumberSliderLevelChannelRaw(requestParameters: CueCueNumberSliderLevelChannelOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliderLevelChannelResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliderLevelChannel.');
        }

        if (requestParameters.channel === null || requestParameters.channel === undefined) {
            throw new runtime.RequiredError('channel','Required parameter requestParameters.channel was null or undefined when calling cueCueNumberSliderLevelChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/sliderLevel/{channel}`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))).replace(`{${"channel"}}`, encodeURIComponent(String(requestParameters.channel))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSliderLevelChannelRequestToJSON(requestParameters.cueCueNumberSliderLevelChannelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliderLevelChannelResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliderLevel {channel} {decibel} /cue/{cue_number}/sliderLevel/{channel} {decibel} Get or set a single output slider volume level. channel is either an integer from 0 to 64, or a string (the cue output name). 0 is the cue master slider. decibel is an optional whole or decimal number. When present it is the decibel value to set. If decibel is sent as a string (e.g. -inf) QLab will use the minimum decibel value set in workspace settings. If no decibel is given, return the volume level of the specified output slider.
     */
    async cueCueNumberSliderLevelChannel(requestParameters: CueCueNumberSliderLevelChannelOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliderLevelChannelResponse> {
        const response = await this.cueCueNumberSliderLevelChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/sliderLevels Read-only; return an array of the output levels of the specified cue, including the cue master. The array is therefore 65 numbers.
     */
    async cueCueNumberSliderLevelsRaw(requestParameters: CueCueNumberSliderLevelsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSliderLevelsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSliderLevels.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/sliderLevels`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSliderLevelsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/sliderLevels Read-only; return an array of the output levels of the specified cue, including the cue master. The array is therefore 65 numbers.
     */
    async cueCueNumberSliderLevels(requestParameters: CueCueNumberSliderLevelsRequest, initOverrides?: RequestInit): Promise<CueCueNumberSliderLevelsResponse> {
        const response = await this.cueCueNumberSliderLevelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/soloCueInTime {number} Fade and stop all other cues in the same cue list as the specified cue over number seconds. number is required, and can be any positive whole or decimal number.
     */
    async cueCueNumberSoloCueInTimeRaw(requestParameters: CueCueNumberSoloCueInTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSoloCueInTimeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSoloCueInTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/soloCueInTime`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSoloCueInTimeRequestToJSON(requestParameters.cueCueNumberSoloCueInTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSoloCueInTimeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/soloCueInTime {number} Fade and stop all other cues in the same cue list as the specified cue over number seconds. number is required, and can be any positive whole or decimal number.
     */
    async cueCueNumberSoloCueInTime(requestParameters: CueCueNumberSoloCueInTimeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSoloCueInTimeResponse> {
        const response = await this.cueCueNumberSoloCueInTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/start Start the specified cue.
     */
    async cueCueNumberStartRaw(requestParameters: CueCueNumberStartRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberStartResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberStart.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/start`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberStartResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/start Start the specified cue.
     */
    async cueCueNumberStart(requestParameters: CueCueNumberStartRequest, initOverrides?: RequestInit): Promise<CueCueNumberStartResponse> {
        const response = await this.cueCueNumberStartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/startAndAutoloadNext Start the specified cue and load the following cue or cue sequence if that cue or cue sequence is set to auto-load.
     */
    async cueCueNumberStartAndAutoloadNextRaw(requestParameters: CueCueNumberStartAndAutoloadNextRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberStartAndAutoloadNextResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberStartAndAutoloadNext.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/startAndAutoloadNext`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberStartAndAutoloadNextResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/startAndAutoloadNext Start the specified cue and load the following cue or cue sequence if that cue or cue sequence is set to auto-load.
     */
    async cueCueNumberStartAndAutoloadNext(requestParameters: CueCueNumberStartAndAutoloadNextRequest, initOverrides?: RequestInit): Promise<CueCueNumberStartAndAutoloadNextResponse> {
        const response = await this.cueCueNumberStartAndAutoloadNextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/startNextCueWhenSliceEnds {number} Get or set the state of the Start next cue when slice ends checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Start next cue when slice ends checkbox of the specified cue.
     */
    async cueCueNumberStartNextCueWhenSliceEndsRaw(requestParameters: CueCueNumberStartNextCueWhenSliceEndsOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberStartNextCueWhenSliceEndsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberStartNextCueWhenSliceEnds.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/startNextCueWhenSliceEnds`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberStartNextCueWhenSliceEndsRequestToJSON(requestParameters.cueCueNumberStartNextCueWhenSliceEndsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberStartNextCueWhenSliceEndsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/startNextCueWhenSliceEnds {number} Get or set the state of the Start next cue when slice ends checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Start next cue when slice ends checkbox of the specified cue.
     */
    async cueCueNumberStartNextCueWhenSliceEnds(requestParameters: CueCueNumberStartNextCueWhenSliceEndsOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberStartNextCueWhenSliceEndsResponse> {
        const response = await this.cueCueNumberStartNextCueWhenSliceEndsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/startTime {number} If number is given, set the start time of the specified cue to number seconds. If not, return the start time of the specified cue. number can be any whole or decimal number greater than or equal to zero.
     */
    async cueCueNumberStartTimeRaw(requestParameters: CueCueNumberStartTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberStartTimeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberStartTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/startTime`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberStartTimeRequestToJSON(requestParameters.cueCueNumberStartTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberStartTimeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/startTime {number} If number is given, set the start time of the specified cue to number seconds. If not, return the start time of the specified cue. number can be any whole or decimal number greater than or equal to zero.
     */
    async cueCueNumberStartTime(requestParameters: CueCueNumberStartTimeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberStartTimeResponse> {
        const response = await this.cueCueNumberStartTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/status {number} If number is given, set the MIDI message type of the specified cue to number. If not, return the MIDI message type of the specified cue. Valid message types are: 0 - Note Off 1 - Note On 2 - Key Pressure (Aftertouch) 3 - Control Change 4 - Program Change 5 - Channel Pressure Change 6 - Pitch Bend Change
     */
    async cueCueNumberStatusRaw(requestParameters: CueCueNumberStatusOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberStatusResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/status`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberStatusRequestToJSON(requestParameters.cueCueNumberStatusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberStatusResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/status {number} If number is given, set the MIDI message type of the specified cue to number. If not, return the MIDI message type of the specified cue. Valid message types are: 0 - Note Off 1 - Note On 2 - Key Pressure (Aftertouch) 3 - Control Change 4 - Program Change 5 - Channel Pressure Change 6 - Pitch Bend Change
     */
    async cueCueNumberStatus(requestParameters: CueCueNumberStatusOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberStatusResponse> {
        const response = await this.cueCueNumberStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/stop Stop the specified cue. If the specified cue is not playing, this command has no effect.
     */
    async cueCueNumberStopRaw(requestParameters: CueCueNumberStopRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberStopResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberStop.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/stop`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberStopResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/stop Stop the specified cue. If the specified cue is not playing, this command has no effect.
     */
    async cueCueNumberStop(requestParameters: CueCueNumberStopRequest, initOverrides?: RequestInit): Promise<CueCueNumberStopResponse> {
        const response = await this.cueCueNumberStopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/stopTargetWhenDone {number} Get or set the state of the Stop target when done checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Stop target when done checkbox of the specified cue.
     */
    async cueCueNumberStopTargetWhenDoneRaw(requestParameters: CueCueNumberStopTargetWhenDoneOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberStopTargetWhenDoneResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberStopTargetWhenDone.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/stopTargetWhenDone`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberStopTargetWhenDoneRequestToJSON(requestParameters.cueCueNumberStopTargetWhenDoneRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberStopTargetWhenDoneResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/stopTargetWhenDone {number} Get or set the state of the Stop target when done checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Stop target when done checkbox of the specified cue.
     */
    async cueCueNumberStopTargetWhenDone(requestParameters: CueCueNumberStopTargetWhenDoneOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberStopTargetWhenDoneResponse> {
        const response = await this.cueCueNumberStopTargetWhenDoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/stopTargetWhenSliceEnds {number} Get or set the state of the Stop target when slice ends checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Stop target when slice ends checkbox of the specified cue.
     */
    async cueCueNumberStopTargetWhenSliceEndsRaw(requestParameters: CueCueNumberStopTargetWhenSliceEndsOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberStopTargetWhenSliceEndsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberStopTargetWhenSliceEnds.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/stopTargetWhenSliceEnds`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberStopTargetWhenSliceEndsRequestToJSON(requestParameters.cueCueNumberStopTargetWhenSliceEndsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberStopTargetWhenSliceEndsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/stopTargetWhenSliceEnds {number} Get or set the state of the Stop target when slice ends checkbox of the specified cue. number is interpreted as a boolean; 0 equals false, any other number equals true. If no number is given, return the state of the Stop target when slice ends checkbox of the specified cue.
     */
    async cueCueNumberStopTargetWhenSliceEnds(requestParameters: CueCueNumberStopTargetWhenSliceEndsOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberStopTargetWhenSliceEndsResponse> {
        const response = await this.cueCueNumberStopTargetWhenSliceEndsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberSubframesRaw(requestParameters: CueCueNumberSubframesOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSubframesResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSubframes.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/subframes`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSubframesRequestToJSON(requestParameters.cueCueNumberSubframesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSubframesResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/hours {number} /cue/{cue_number}/minutes {number} /cue/{cue_number}/seconds {number} /cue/{cue_number}/frames {number} /cue/{cue_number}/subframes {number} If number is given, set the appropriate section of the MSC timecode of the specified cue to number. If not, return the appropriate section of MSC timecode hours of the specified cue.
     */
    async cueCueNumberSubframes(requestParameters: CueCueNumberSubframesOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSubframesResponse> {
        const response = await this.cueCueNumberSubframesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/surfaceID {number} If number is given, set the surface of the specified cue. If not, return the surface ID of the surface of the specified cue.
     */
    async cueCueNumberSurfaceIdRaw(requestParameters: CueCueNumberSurfaceIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSurfaceIDResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSurfaceId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/surfaceID`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSurfaceIDRequestToJSON(requestParameters.cueCueNumberSurfaceIDRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSurfaceIDResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/surfaceID {number} If number is given, set the surface of the specified cue. If not, return the surface ID of the surface of the specified cue.
     */
    async cueCueNumberSurfaceId(requestParameters: CueCueNumberSurfaceIdRequest, initOverrides?: RequestInit): Promise<CueCueNumberSurfaceIDResponse> {
        const response = await this.cueCueNumberSurfaceIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/surfaceList Read-only; return a list of surfaces defined for this workspace: [     {         \"surfaceName\": string,         \"surfaceID\": number     } ]
     */
    async cueCueNumberSurfaceListRaw(requestParameters: CueCueNumberSurfaceListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSurfaceListResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSurfaceList.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/surfaceList`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSurfaceListResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/surfaceList Read-only; return a list of surfaces defined for this workspace: [     {         \"surfaceName\": string,         \"surfaceID\": number     } ]
     */
    async cueCueNumberSurfaceList(requestParameters: CueCueNumberSurfaceListRequest, initOverrides?: RequestInit): Promise<CueCueNumberSurfaceListResponse> {
        const response = await this.cueCueNumberSurfaceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/surfaceName {string} If string is given, assign the specific cue to surface string. If not, return the name of the surface to which the specified cue is assigned. string must be the name of a surface in this workspace.
     */
    async cueCueNumberSurfaceNameRaw(requestParameters: CueCueNumberSurfaceNameOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSurfaceNameResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSurfaceName.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/surfaceName`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberSurfaceNameRequestToJSON(requestParameters.cueCueNumberSurfaceNameRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSurfaceNameResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/surfaceName {string} If string is given, assign the specific cue to surface string. If not, return the name of the surface to which the specified cue is assigned. string must be the name of a surface in this workspace.
     */
    async cueCueNumberSurfaceName(requestParameters: CueCueNumberSurfaceNameOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberSurfaceNameResponse> {
        const response = await this.cueCueNumberSurfaceNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/surfaceSize Read-only; returns the size of the cues display surface: {     \"width\": number,     \"height\": number }
     */
    async cueCueNumberSurfaceSizeRaw(requestParameters: CueCueNumberSurfaceSizeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberSurfaceSizeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberSurfaceSize.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/surfaceSize`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberSurfaceSizeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/surfaceSize Read-only; returns the size of the cues display surface: {     \"width\": number,     \"height\": number }
     */
    async cueCueNumberSurfaceSize(requestParameters: CueCueNumberSurfaceSizeRequest, initOverrides?: RequestInit): Promise<CueCueNumberSurfaceSizeResponse> {
        const response = await this.cueCueNumberSurfaceSizeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/tempCueTargetId This works exactly the same as /tempCueTargetNumber, but uses the cue ID of the target instead of the cue number.
     */
    async cueCueNumberTempCueTargetIdRaw(requestParameters: CueCueNumberTempCueTargetIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTempCueTargetIdResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTempCueTargetId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/tempCueTargetId`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTempCueTargetIdResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/tempCueTargetId This works exactly the same as /tempCueTargetNumber, but uses the cue ID of the target instead of the cue number.
     */
    async cueCueNumberTempCueTargetId(requestParameters: CueCueNumberTempCueTargetIdRequest, initOverrides?: RequestInit): Promise<CueCueNumberTempCueTargetIdResponse> {
        const response = await this.cueCueNumberTempCueTargetIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/tempCueTargetNumber {string} If string is given, and if the specified cue can have cue targets, temporarily set the target of the specified cue to string. The specified cue will revert to its previous target if it is reset, if the workspace is reset, or if the workspace is closed and reopened. If string is not given, and the specified cue has a temporary target, return the cue number of that temporary target.
     */
    async cueCueNumberTempCueTargetNumberRaw(requestParameters: CueCueNumberTempCueTargetNumberOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTempCueTargetNumberResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTempCueTargetNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/tempCueTargetNumber`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTempCueTargetNumberRequestToJSON(requestParameters.cueCueNumberTempCueTargetNumberRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTempCueTargetNumberResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/tempCueTargetNumber {string} If string is given, and if the specified cue can have cue targets, temporarily set the target of the specified cue to string. The specified cue will revert to its previous target if it is reset, if the workspace is reset, or if the workspace is closed and reopened. If string is not given, and the specified cue has a temporary target, return the cue number of that temporary target.
     */
    async cueCueNumberTempCueTargetNumber(requestParameters: CueCueNumberTempCueTargetNumberOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTempCueTargetNumberResponse> {
        const response = await this.cueCueNumberTempCueTargetNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/tempDuration {number} If number is given, and if the specified cue has a duration, temporarily set the duration of the specified cue to number. The specified cue will revert to its previous duration if it is reset, if the workspace is reset, or if the workspace is closed and reopened. If number is not given, and if the specified cue has a temporary duration, return that temporary duration.
     */
    async cueCueNumberTempDurationRaw(requestParameters: CueCueNumberTempDurationOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTempDurationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTempDuration.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/tempDuration`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTempDurationRequestToJSON(requestParameters.cueCueNumberTempDurationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTempDurationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/tempDuration {number} If number is given, and if the specified cue has a duration, temporarily set the duration of the specified cue to number. The specified cue will revert to its previous duration if it is reset, if the workspace is reset, or if the workspace is closed and reopened. If number is not given, and if the specified cue has a temporary duration, return that temporary duration.
     */
    async cueCueNumberTempDuration(requestParameters: CueCueNumberTempDurationOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTempDurationResponse> {
        const response = await this.cueCueNumberTempDurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text {string} /cue/{cue_number}/liveText {string} If string is given, set the text of the specified cue to string. If not, return the text of the specified cue. When setting text, the formatting will match the first character of the existing text. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberTextRaw(requestParameters: CueCueNumberTextOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberText.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextRequestToJSON(requestParameters.cueCueNumberTextRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text {string} /cue/{cue_number}/liveText {string} If string is given, set the text of the specified cue to string. If not, return the text of the specified cue. When setting text, the formatting will match the first character of the existing text. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberText(requestParameters: CueCueNumberTextOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextResponse> {
        const response = await this.cueCueNumberTextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format {json_string} If json_string is given, this command can be used to set the formatting of one or more substrings of the specified cue. For example: [   {     \"fontFamily\": string,     \"fontStyle\": string,     \"fontName\": string,     \"fontSize\": number,     \"lineSpacing\": number,     \"color\": array of numbers representing RGBA percentage values,     \"range\": optional array of numbers/percent strings representing a substring at [index, length]   },   { ... },   { ... } ] If json_string is not given, return an array of JSON dictionaries describing each substring in the text of the specified cue. A substring, in this case, is defined as a subset of the text with uniform format attributes. If the entire text string is uniformly formatted, the array will have only one dictionary.
     */
    async cueCueNumberTextFormatRaw(requestParameters: CueCueNumberTextFormatOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormat.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatRequestToJSON(requestParameters.cueCueNumberTextFormatRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format {json_string} If json_string is given, this command can be used to set the formatting of one or more substrings of the specified cue. For example: [   {     \"fontFamily\": string,     \"fontStyle\": string,     \"fontName\": string,     \"fontSize\": number,     \"lineSpacing\": number,     \"color\": array of numbers representing RGBA percentage values,     \"range\": optional array of numbers/percent strings representing a substring at [index, length]   },   { ... },   { ... } ] If json_string is not given, return an array of JSON dictionaries describing each substring in the text of the specified cue. A substring, in this case, is defined as a subset of the text with uniform format attributes. If the entire text string is uniformly formatted, the array will have only one dictionary.
     */
    async cueCueNumberTextFormat(requestParameters: CueCueNumberTextFormatOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatResponse> {
        const response = await this.cueCueNumberTextFormatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/alignment {alignment} If alignment is given, set the text alignment of the specified cue to alignment. If not, return the alignment of the specified cue. alignment may be left, center, right, or justify.
     */
    async cueCueNumberTextFormatAlignmentRaw(requestParameters: CueCueNumberTextFormatAlignmentOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatAlignmentResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatAlignment.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/alignment`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatAlignmentRequestToJSON(requestParameters.cueCueNumberTextFormatAlignmentRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatAlignmentResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/alignment {alignment} If alignment is given, set the text alignment of the specified cue to alignment. If not, return the alignment of the specified cue. alignment may be left, center, right, or justify.
     */
    async cueCueNumberTextFormatAlignment(requestParameters: CueCueNumberTextFormatAlignmentOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatAlignmentResponse> {
        const response = await this.cueCueNumberTextFormatAlignmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/color {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/backgroundColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/strikethroughColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/underlineColor {red} {green} {blue} {alpha} If red, green, blue, and alpha are specified, set the given color attribute of the specified cue to the corresponding color. If not, return the color for the given attribute of the specified cue. red, green, blue, and alpha can be decimal numbers between 0.0 and 1.0, where 1.0 is the maximum level. Thus, 1 0 0 1 is primary red, and 1 1 1 0.5 is white at 50% transparency. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatBackgroundColorRaw(requestParameters: CueCueNumberTextFormatBackgroundColorOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatBackgroundColorResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatBackgroundColor.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/backgroundColor`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatBackgroundColorRequestToJSON(requestParameters.cueCueNumberTextFormatBackgroundColorRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatBackgroundColorResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/color {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/backgroundColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/strikethroughColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/underlineColor {red} {green} {blue} {alpha} If red, green, blue, and alpha are specified, set the given color attribute of the specified cue to the corresponding color. If not, return the color for the given attribute of the specified cue. red, green, blue, and alpha can be decimal numbers between 0.0 and 1.0, where 1.0 is the maximum level. Thus, 1 0 0 1 is primary red, and 1 1 1 0.5 is white at 50% transparency. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatBackgroundColor(requestParameters: CueCueNumberTextFormatBackgroundColorOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatBackgroundColorResponse> {
        const response = await this.cueCueNumberTextFormatBackgroundColorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/color {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/backgroundColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/strikethroughColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/underlineColor {red} {green} {blue} {alpha} If red, green, blue, and alpha are specified, set the given color attribute of the specified cue to the corresponding color. If not, return the color for the given attribute of the specified cue. red, green, blue, and alpha can be decimal numbers between 0.0 and 1.0, where 1.0 is the maximum level. Thus, 1 0 0 1 is primary red, and 1 1 1 0.5 is white at 50% transparency. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatColorRaw(requestParameters: CueCueNumberTextFormatColorOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatColorResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatColor.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/color`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatColorRequestToJSON(requestParameters.cueCueNumberTextFormatColorRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatColorResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/color {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/backgroundColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/strikethroughColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/underlineColor {red} {green} {blue} {alpha} If red, green, blue, and alpha are specified, set the given color attribute of the specified cue to the corresponding color. If not, return the color for the given attribute of the specified cue. red, green, blue, and alpha can be decimal numbers between 0.0 and 1.0, where 1.0 is the maximum level. Thus, 1 0 0 1 is primary red, and 1 1 1 0.5 is white at 50% transparency. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatColor(requestParameters: CueCueNumberTextFormatColorOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatColorResponse> {
        const response = await this.cueCueNumberTextFormatColorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/fontFamily Read-only; return the font family name (Helvetica, Courier New, etc.) used in the specified cue. You may optionally send this command in the form: /cue/{cue_number}/text/format/fontFamily/{index}/{length}, in which index is a whole number or a percentage string (e.g. 53%) which lets you specify the start of a substring, and length is a number or percentage string which specifies the length of that substring. The first character is index 0. For example: /cue/1/text/format/fontFamily/4/12 will return the font family name used for characters 5 through 17 of cue 1. You may set length to -1 to specify to end the of the string. You may also optionally send this command in the form: /cue/{cue_number}/text/format/fontFamily/word/{word_index}, in which word_index is a whole number which specifies a single word within the text of the cue. The first word is word 0.
     */
    async cueCueNumberTextFormatFontFamilyRaw(requestParameters: CueCueNumberTextFormatFontFamilyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatFontFamilyResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatFontFamily.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/fontFamily`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatFontFamilyResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/fontFamily Read-only; return the font family name (Helvetica, Courier New, etc.) used in the specified cue. You may optionally send this command in the form: /cue/{cue_number}/text/format/fontFamily/{index}/{length}, in which index is a whole number or a percentage string (e.g. 53%) which lets you specify the start of a substring, and length is a number or percentage string which specifies the length of that substring. The first character is index 0. For example: /cue/1/text/format/fontFamily/4/12 will return the font family name used for characters 5 through 17 of cue 1. You may set length to -1 to specify to end the of the string. You may also optionally send this command in the form: /cue/{cue_number}/text/format/fontFamily/word/{word_index}, in which word_index is a whole number which specifies a single word within the text of the cue. The first word is word 0.
     */
    async cueCueNumberTextFormatFontFamily(requestParameters: CueCueNumberTextFormatFontFamilyRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatFontFamilyResponse> {
        const response = await this.cueCueNumberTextFormatFontFamilyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/fontFamilyAndStyle {family} {style} If family and style are given, set the font family and style of the text of the specified cue to family and style. Otherwise, return the font family and style for the specified cue. Individual commands for font family and style are not available because the combination of both values is required to reliably describe an individual font. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatFontFamilyAndStyleRaw(requestParameters: CueCueNumberTextFormatFontFamilyAndStyleOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatFontFamilyAndStyleResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatFontFamilyAndStyle.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/fontFamilyAndStyle`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatFontFamilyAndStyleRequestToJSON(requestParameters.cueCueNumberTextFormatFontFamilyAndStyleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatFontFamilyAndStyleResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/fontFamilyAndStyle {family} {style} If family and style are given, set the font family and style of the text of the specified cue to family and style. Otherwise, return the font family and style for the specified cue. Individual commands for font family and style are not available because the combination of both values is required to reliably describe an individual font. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatFontFamilyAndStyle(requestParameters: CueCueNumberTextFormatFontFamilyAndStyleOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatFontFamilyAndStyleResponse> {
        const response = await this.cueCueNumberTextFormatFontFamilyAndStyleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/fontName {name} If name is given, set the font of the text of the specified cue. If not, return the name of the font used for the specified cue. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatFontNameRaw(requestParameters: CueCueNumberTextFormatFontNameOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatFontNameResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatFontName.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/fontName`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatFontNameRequestToJSON(requestParameters.cueCueNumberTextFormatFontNameRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatFontNameResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/fontName {name} If name is given, set the font of the text of the specified cue. If not, return the name of the font used for the specified cue. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatFontName(requestParameters: CueCueNumberTextFormatFontNameOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatFontNameResponse> {
        const response = await this.cueCueNumberTextFormatFontNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/fontSize {number} If number is specified, set the font size of the text of the specified cue to number. If not, return the font size of the text of the specified cue. This command may use increment and decrement syntax as described above. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatFontSizeRaw(requestParameters: CueCueNumberTextFormatFontSizeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatFontSizeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatFontSize.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/fontSize`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatFontSizeRequestToJSON(requestParameters.cueCueNumberTextFormatFontSizeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatFontSizeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/fontSize {number} If number is specified, set the font size of the text of the specified cue to number. If not, return the font size of the text of the specified cue. This command may use increment and decrement syntax as described above. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatFontSize(requestParameters: CueCueNumberTextFormatFontSizeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatFontSizeResponse> {
        const response = await this.cueCueNumberTextFormatFontSizeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/fontStyle Read-only; return the style (Bold Oblique, Regular, etc.) used in the specified cue. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatFontStyleRaw(requestParameters: CueCueNumberTextFormatFontStyleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatFontStyleResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatFontStyle.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/fontStyle`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatFontStyleResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/fontStyle Read-only; return the style (Bold Oblique, Regular, etc.) used in the specified cue. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatFontStyle(requestParameters: CueCueNumberTextFormatFontStyleRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatFontStyleResponse> {
        const response = await this.cueCueNumberTextFormatFontStyleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/lineSpacing {number} If number is specified, set the line spacing of the text of the specified cue to number. If not, return the line spacing of the text of the specified cue. This command may use increment and decrement syntax as described above. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily, although it only works if you index the first word or character in a line. Its also important to remember that the invisible return character at the end of a line (created by pressing the return key) counts as a character.
     */
    async cueCueNumberTextFormatLineSpacingRaw(requestParameters: CueCueNumberTextFormatLineSpacingOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatLineSpacingResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatLineSpacing.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/lineSpacing`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatLineSpacingRequestToJSON(requestParameters.cueCueNumberTextFormatLineSpacingRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatLineSpacingResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/lineSpacing {number} If number is specified, set the line spacing of the text of the specified cue to number. If not, return the line spacing of the text of the specified cue. This command may use increment and decrement syntax as described above. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily, although it only works if you index the first word or character in a line. Its also important to remember that the invisible return character at the end of a line (created by pressing the return key) counts as a character.
     */
    async cueCueNumberTextFormatLineSpacing(requestParameters: CueCueNumberTextFormatLineSpacingOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatLineSpacingResponse> {
        const response = await this.cueCueNumberTextFormatLineSpacingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/color {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/backgroundColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/strikethroughColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/underlineColor {red} {green} {blue} {alpha} If red, green, blue, and alpha are specified, set the given color attribute of the specified cue to the corresponding color. If not, return the color for the given attribute of the specified cue. red, green, blue, and alpha can be decimal numbers between 0.0 and 1.0, where 1.0 is the maximum level. Thus, 1 0 0 1 is primary red, and 1 1 1 0.5 is white at 50% transparency. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatStrikethroughColorRaw(requestParameters: CueCueNumberTextFormatStrikethroughColorOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatStrikethroughColorResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatStrikethroughColor.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/strikethroughColor`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatStrikethroughColorRequestToJSON(requestParameters.cueCueNumberTextFormatStrikethroughColorRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatStrikethroughColorResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/color {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/backgroundColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/strikethroughColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/underlineColor {red} {green} {blue} {alpha} If red, green, blue, and alpha are specified, set the given color attribute of the specified cue to the corresponding color. If not, return the color for the given attribute of the specified cue. red, green, blue, and alpha can be decimal numbers between 0.0 and 1.0, where 1.0 is the maximum level. Thus, 1 0 0 1 is primary red, and 1 1 1 0.5 is white at 50% transparency. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatStrikethroughColor(requestParameters: CueCueNumberTextFormatStrikethroughColorOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatStrikethroughColorResponse> {
        const response = await this.cueCueNumberTextFormatStrikethroughColorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/strikethroughStyle {style} /cue/{cue_number}/text/format/underlineStyle {style} If style is given, set the strikethrough or underline style of the text of the specified cue to style. Otherwise, return the strikethrough or underline style for the specified cue.  style may be none, single, or double. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatStrikethroughStyleRaw(requestParameters: CueCueNumberTextFormatStrikethroughStyleOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatStrikethroughStyleResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatStrikethroughStyle.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/strikethroughStyle`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatStrikethroughStyleRequestToJSON(requestParameters.cueCueNumberTextFormatStrikethroughStyleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatStrikethroughStyleResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/strikethroughStyle {style} /cue/{cue_number}/text/format/underlineStyle {style} If style is given, set the strikethrough or underline style of the text of the specified cue to style. Otherwise, return the strikethrough or underline style for the specified cue.  style may be none, single, or double. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatStrikethroughStyle(requestParameters: CueCueNumberTextFormatStrikethroughStyleOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatStrikethroughStyleResponse> {
        const response = await this.cueCueNumberTextFormatStrikethroughStyleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/color {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/backgroundColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/strikethroughColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/underlineColor {red} {green} {blue} {alpha} If red, green, blue, and alpha are specified, set the given color attribute of the specified cue to the corresponding color. If not, return the color for the given attribute of the specified cue. red, green, blue, and alpha can be decimal numbers between 0.0 and 1.0, where 1.0 is the maximum level. Thus, 1 0 0 1 is primary red, and 1 1 1 0.5 is white at 50% transparency. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatUnderlineColorRaw(requestParameters: CueCueNumberTextFormatUnderlineColorOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatUnderlineColorResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatUnderlineColor.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/underlineColor`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatUnderlineColorRequestToJSON(requestParameters.cueCueNumberTextFormatUnderlineColorRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatUnderlineColorResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/color {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/backgroundColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/strikethroughColor {red} {green} {blue} {alpha} /cue/{cue_number}/text/format/underlineColor {red} {green} {blue} {alpha} If red, green, blue, and alpha are specified, set the given color attribute of the specified cue to the corresponding color. If not, return the color for the given attribute of the specified cue. red, green, blue, and alpha can be decimal numbers between 0.0 and 1.0, where 1.0 is the maximum level. Thus, 1 0 0 1 is primary red, and 1 1 1 0.5 is white at 50% transparency. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatUnderlineColor(requestParameters: CueCueNumberTextFormatUnderlineColorOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatUnderlineColorResponse> {
        const response = await this.cueCueNumberTextFormatUnderlineColorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/format/strikethroughStyle {style} /cue/{cue_number}/text/format/underlineStyle {style} If style is given, set the strikethrough or underline style of the text of the specified cue to style. Otherwise, return the strikethrough or underline style for the specified cue.  style may be none, single, or double. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatUnderlineStyleRaw(requestParameters: CueCueNumberTextFormatUnderlineStyleOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextFormatUnderlineStyleResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextFormatUnderlineStyle.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/text/format/underlineStyle`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTextFormatUnderlineStyleRequestToJSON(requestParameters.cueCueNumberTextFormatUnderlineStyleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextFormatUnderlineStyleResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/format/strikethroughStyle {style} /cue/{cue_number}/text/format/underlineStyle {style} If style is given, set the strikethrough or underline style of the text of the specified cue to style. Otherwise, return the strikethrough or underline style for the specified cue.  style may be none, single, or double. This command may also use the optional /{index}/{length} and /word/{word_index} forms as described above in the entry for /cue/{cue_number}/text/format/fontFamily.
     */
    async cueCueNumberTextFormatUnderlineStyle(requestParameters: CueCueNumberTextFormatUnderlineStyleOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextFormatUnderlineStyleResponse> {
        const response = await this.cueCueNumberTextFormatUnderlineStyleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/text/outputSize /cue/{cue_number}/liveText/outputSize Read-only; return a two-item array containing the width and height of the text or liveText of the specified cue. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberTextOutputSizeRaw(requestParameters: CueCueNumberTextOutputSizeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTextOutputSizeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTextOutputSize.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/text/outputSize`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTextOutputSizeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/text/outputSize /cue/{cue_number}/liveText/outputSize Read-only; return a two-item array containing the width and height of the text or liveText of the specified cue. Live methods are the same as their non-live counterparts, but operate on the active, live value of a running cue, rather than changing the start state of the cue. Invoking these methods does not cause the document to have unsaved changes.
     */
    async cueCueNumberTextOutputSize(requestParameters: CueCueNumberTextOutputSizeRequest, initOverrides?: RequestInit): Promise<CueCueNumberTextOutputSizeResponse> {
        const response = await this.cueCueNumberTextOutputSizeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/timecodeFormat {number} If number is given, set the MSC timecode format of the specified cue to number. If not, return the MSC timecode format of the specified cue. Valid formats are: 0 - 24 fps 1 - 25 fps 2 - 30 fps drop 3 - 30 fps non-drop
     */
    async cueCueNumberTimecodeFormatRaw(requestParameters: CueCueNumberTimecodeFormatOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTimecodeFormatResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTimecodeFormat.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/timecodeFormat`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTimecodeFormatRequestToJSON(requestParameters.cueCueNumberTimecodeFormatRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTimecodeFormatResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/timecodeFormat {number} If number is given, set the MSC timecode format of the specified cue to number. If not, return the MSC timecode format of the specified cue. Valid formats are: 0 - 24 fps 1 - 25 fps 2 - 30 fps drop 3 - 30 fps non-drop
     */
    async cueCueNumberTimecodeFormat(requestParameters: CueCueNumberTimecodeFormatOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTimecodeFormatResponse> {
        const response = await this.cueCueNumberTimecodeFormatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/timecodeString {string} If number is given, set the MSC timecode string of the specified cue to number. If not, return the MSC timecode string of the specified cue.
     */
    async cueCueNumberTimecodeStringRaw(requestParameters: CueCueNumberTimecodeStringOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTimecodeStringResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTimecodeString.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/timecodeString`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTimecodeStringRequestToJSON(requestParameters.cueCueNumberTimecodeStringRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTimecodeStringResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/timecodeString {string} If number is given, set the MSC timecode string of the specified cue to number. If not, return the MSC timecode string of the specified cue.
     */
    async cueCueNumberTimecodeString(requestParameters: CueCueNumberTimecodeStringOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTimecodeStringResponse> {
        const response = await this.cueCueNumberTimecodeStringRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/togglePause Toggle the paused state of the specified cue. That is, if the cue is playing, this command will pause it. If the cue is paused, this command will resume it. If the specified cue is not playing, this command has no effect.
     */
    async cueCueNumberTogglePauseRaw(requestParameters: CueCueNumberTogglePauseRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTogglePauseResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTogglePause.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/togglePause`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTogglePauseResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/togglePause Toggle the paused state of the specified cue. That is, if the cue is playing, this command will pause it. If the cue is paused, this command will resume it. If the specified cue is not playing, this command has no effect.
     */
    async cueCueNumberTogglePause(requestParameters: CueCueNumberTogglePauseRequest, initOverrides?: RequestInit): Promise<CueCueNumberTogglePauseResponse> {
        const response = await this.cueCueNumberTogglePauseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/translation {x} {y} If x and y are given, set the translation of the specified cue to (x,y). If not, return the current translation of the specified cue. x and y can be any decimal numbers.
     */
    async cueCueNumberTranslationRaw(requestParameters: CueCueNumberTranslationOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTranslationResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTranslation.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/translation`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTranslationRequestToJSON(requestParameters.cueCueNumberTranslationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTranslationResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/translation {x} {y} If x and y are given, set the translation of the specified cue to (x,y). If not, return the current translation of the specified cue. x and y can be any decimal numbers.
     */
    async cueCueNumberTranslation(requestParameters: CueCueNumberTranslationOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTranslationResponse> {
        const response = await this.cueCueNumberTranslationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/translationX {number} If number is given, set the X-axis translation of the specified cue to number. If not, return the X-axis translation of the specified cue. number can be any decimal number.
     */
    async cueCueNumberTranslationXRaw(requestParameters: CueCueNumberTranslationXOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTranslationXResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTranslationX.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/translationX`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTranslationXRequestToJSON(requestParameters.cueCueNumberTranslationXRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTranslationXResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/translationX {number} If number is given, set the X-axis translation of the specified cue to number. If not, return the X-axis translation of the specified cue. number can be any decimal number.
     */
    async cueCueNumberTranslationX(requestParameters: CueCueNumberTranslationXOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTranslationXResponse> {
        const response = await this.cueCueNumberTranslationXRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/translationY {number} If number is given, set the Y-axis translation of the specified cue to number. If not, return the Y-axis translation of the specified cue. number can be any decimal number.
     */
    async cueCueNumberTranslationYRaw(requestParameters: CueCueNumberTranslationYOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTranslationYResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberTranslationY.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/translationY`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberTranslationYRequestToJSON(requestParameters.cueCueNumberTranslationYRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTranslationYResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/translationY {number} If number is given, set the Y-axis translation of the specified cue to number. If not, return the Y-axis translation of the specified cue. number can be any decimal number.
     */
    async cueCueNumberTranslationY(requestParameters: CueCueNumberTranslationYOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberTranslationYResponse> {
        const response = await this.cueCueNumberTranslationYRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/type Return the type (Audio, Video, Fade, etc.) of the specified cue.
     */
    async cueCueNumberTypeRaw(requestParameters: CueCueNumberTypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberTypeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberType.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/type`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberTypeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/type Return the type (Audio, Video, Fade, etc.) of the specified cue.
     */
    async cueCueNumberType(requestParameters: CueCueNumberTypeRequest, initOverrides?: RequestInit): Promise<CueCueNumberTypeResponse> {
        const response = await this.cueCueNumberTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/rawString {string} /cue/{cue_number}/udpString {string} If string is given, set the UDP string of the specified cue to string. If not, return the UDP string of the specified cue.
     */
    async cueCueNumberUdpStringRaw(requestParameters: CueCueNumberUdpStringOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberUdpStringResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberUdpString.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/udpString`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberUdpStringRequestToJSON(requestParameters.cueCueNumberUdpStringRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberUdpStringResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/rawString {string} /cue/{cue_number}/udpString {string} If string is given, set the UDP string of the specified cue to string. If not, return the UDP string of the specified cue.
     */
    async cueCueNumberUdpString(requestParameters: CueCueNumberUdpStringOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberUdpStringResponse> {
        const response = await this.cueCueNumberUdpStringRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/uniqueID Return the uniqueID of the specified cue.
     */
    async cueCueNumberUniqueIdRaw(requestParameters: CueCueNumberUniqueIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberUniqueIDResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberUniqueId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{cue_number}/uniqueID`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberUniqueIDResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/uniqueID Return the uniqueID of the specified cue.
     */
    async cueCueNumberUniqueId(requestParameters: CueCueNumberUniqueIdRequest, initOverrides?: RequestInit): Promise<CueCueNumberUniqueIDResponse> {
        const response = await this.cueCueNumberUniqueIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/updateLightCommand {string} {number} If the specified cue contains a command for the instrument or group string, then update that command to the specified value number. If the specified cue does not contain a command for the instrument or group string, then add a command in the form string = number. string can be the name of an instrument or group, with or without a parameter. number must be an acceptable value for the specified instrument or group. This method is deprecated starting in QLab 4.4, and is replaced by /replaceLightCommand.
     */
    async cueCueNumberUpdateLightCommandRaw(requestParameters: CueCueNumberUpdateLightCommandOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberUpdateLightCommandResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberUpdateLightCommand.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/updateLightCommand`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberUpdateLightCommandRequestToJSON(requestParameters.cueCueNumberUpdateLightCommandRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberUpdateLightCommandResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/updateLightCommand {string} {number} If the specified cue contains a command for the instrument or group string, then update that command to the specified value number. If the specified cue does not contain a command for the instrument or group string, then add a command in the form string = number. string can be the name of an instrument or group, with or without a parameter. number must be an acceptable value for the specified instrument or group. This method is deprecated starting in QLab 4.4, and is replaced by /replaceLightCommand.
     */
    async cueCueNumberUpdateLightCommand(requestParameters: CueCueNumberUpdateLightCommandOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberUpdateLightCommandResponse> {
        const response = await this.cueCueNumberUpdateLightCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/valuesForKeys {json_string} This special method can be used to request a custom collection of state about the given cue. json_string must be a JSON-formatted string representing an array of keys you wish to query. For example: /cue/2/valuesForKeys \"[\\\"opacity\\\",\\\"surfaceSize\\\"]\" would return the values of opacity and surfaceSize of cue 2, assuming cue 2 is a Video cue.
     */
    async cueCueNumberValuesForKeysRaw(requestParameters: CueCueNumberValuesForKeysOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberValuesForKeysResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberValuesForKeys.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/valuesForKeys`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberValuesForKeysRequestToJSON(requestParameters.cueCueNumberValuesForKeysRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberValuesForKeysResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/valuesForKeys {json_string} This special method can be used to request a custom collection of state about the given cue. json_string must be a JSON-formatted string representing an array of keys you wish to query. For example: /cue/2/valuesForKeys \"[\\\"opacity\\\",\\\"surfaceSize\\\"]\" would return the values of opacity and surfaceSize of cue 2, assuming cue 2 is a Video cue.
     */
    async cueCueNumberValuesForKeys(requestParameters: CueCueNumberValuesForKeysOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberValuesForKeysResponse> {
        const response = await this.cueCueNumberValuesForKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/valuesForKeysWithArguments {json_string} This special method can be used to request a custom collection of state about the given cue. json_string must be a JSON-formatted string representing a dictionary of keys and arguments you wish to query. For example: /cue/2/valuesForKeysWithArguments \"{\\\"level\\\":[0,0]}\" would return a dictionary that contains the value of the master volume level of cue 2, assuming cue 2 has audio levels. Note that this method is limited to returning one value per key, even if you send multiple keys with different arguments.
     */
    async cueCueNumberValuesForKeysWithArgumentsRaw(requestParameters: CueCueNumberValuesForKeysWithArgumentsOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberValuesForKeysWithArgumentsResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberValuesForKeysWithArguments.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/valuesForKeysWithArguments`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberValuesForKeysWithArgumentsRequestToJSON(requestParameters.cueCueNumberValuesForKeysWithArgumentsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberValuesForKeysWithArgumentsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/valuesForKeysWithArguments {json_string} This special method can be used to request a custom collection of state about the given cue. json_string must be a JSON-formatted string representing a dictionary of keys and arguments you wish to query. For example: /cue/2/valuesForKeysWithArguments \"{\\\"level\\\":[0,0]}\" would return a dictionary that contains the value of the master volume level of cue 2, assuming cue 2 has audio levels. Note that this method is limited to returning one value per key, even if you send multiple keys with different arguments.
     */
    async cueCueNumberValuesForKeysWithArguments(requestParameters: CueCueNumberValuesForKeysWithArgumentsOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberValuesForKeysWithArgumentsResponse> {
        const response = await this.cueCueNumberValuesForKeysWithArgumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{cue_number}/willFade {row} {column} {number} If number, row and column are all given, set the active state (i.e. yellow or grey) of crosspoint {row,column}. number is interpreted as a boolean; 0 equals false, any other number equals true. row and column must be whole numbers. If row and column are given, but not number, return the active state of crosspoint {row,column}. If no arguments are given, return all the currently active crosspoints in the specified cue. The levels are returned as an array of arrays, like so: [row0Array, row1Array, row2Array, ...]
     */
    async cueCueNumberWillFadeRaw(requestParameters: CueCueNumberWillFadeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueCueNumberWillFadeResponse>> {
        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling cueCueNumberWillFade.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/cue/{cue_number}/willFade`.replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CueCueNumberWillFadeRequestToJSON(requestParameters.cueCueNumberWillFadeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueCueNumberWillFadeResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{cue_number}/willFade {row} {column} {number} If number, row and column are all given, set the active state (i.e. yellow or grey) of crosspoint {row,column}. number is interpreted as a boolean; 0 equals false, any other number equals true. row and column must be whole numbers. If row and column are given, but not number, return the active state of crosspoint {row,column}. If no arguments are given, return all the currently active crosspoints in the specified cue. The levels are returned as an array of arrays, like so: [row0Array, row1Array, row2Array, ...]
     */
    async cueCueNumberWillFade(requestParameters: CueCueNumberWillFadeOperationRequest, initOverrides?: RequestInit): Promise<CueCueNumberWillFadeResponse> {
        const response = await this.cueCueNumberWillFadeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async cueListsShallowRaw(requestParameters: CueListsShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueListsShallowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cueLists/shallow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueListsShallowResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async cueListsShallow(requestParameters: CueListsShallowRequest = {}, initOverrides?: RequestInit): Promise<CueListsShallowResponse> {
        const response = await this.cueListsShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async cueListsUniqueIDsRaw(requestParameters: CueListsUniqueIDsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueListsUniqueIDsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cueLists/uniqueIDs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueListsUniqueIDsResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async cueListsUniqueIDs(requestParameters: CueListsUniqueIDsRequest = {}, initOverrides?: RequestInit): Promise<CueListsUniqueIDsResponse> {
        const response = await this.cueListsUniqueIDsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async cueListsUniqueIDsShallowRaw(requestParameters: CueListsUniqueIDsShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueListsUniqueIDsShallowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cueLists/uniqueIDs/shallow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueListsUniqueIDsShallowResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async cueListsUniqueIDsShallow(requestParameters: CueListsUniqueIDsShallowRequest = {}, initOverrides?: RequestInit): Promise<CueListsUniqueIDsShallowResponse> {
        const response = await this.cueListsUniqueIDsShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{number}/children/shallow If the specified cue is a list, cart, or Group cue, return the cue numbers of the child cues of that list, cart, or Group. Nested Groups will not be queried, and so only the first layer of the cue hierarchy will be returned.
     */
    async cueNumberChildrenShallowRaw(requestParameters: CueNumberChildrenShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueNumberChildrenShallowResponse>> {
        if (requestParameters.number === null || requestParameters.number === undefined) {
            throw new runtime.RequiredError('number','Required parameter requestParameters.number was null or undefined when calling cueNumberChildrenShallow.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{number}/children/shallow`.replace(`{${"number"}}`, encodeURIComponent(String(requestParameters.number))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueNumberChildrenShallowResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{number}/children/shallow If the specified cue is a list, cart, or Group cue, return the cue numbers of the child cues of that list, cart, or Group. Nested Groups will not be queried, and so only the first layer of the cue hierarchy will be returned.
     */
    async cueNumberChildrenShallow(requestParameters: CueNumberChildrenShallowRequest, initOverrides?: RequestInit): Promise<CueNumberChildrenShallowResponse> {
        const response = await this.cueNumberChildrenShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{number}/children/uniqueIDs If the specified cue is a list, cart, or Group cue, return the cue IDs of the child cues of that list, cart, or Group, and the cue IDs of any children of nested Groups.
     */
    async cueNumberChildrenUniqueIDsRaw(requestParameters: CueNumberChildrenUniqueIDsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueNumberChildrenUniqueIDsResponse>> {
        if (requestParameters.number === null || requestParameters.number === undefined) {
            throw new runtime.RequiredError('number','Required parameter requestParameters.number was null or undefined when calling cueNumberChildrenUniqueIDs.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{number}/children/uniqueIDs`.replace(`{${"number"}}`, encodeURIComponent(String(requestParameters.number))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueNumberChildrenUniqueIDsResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{number}/children/uniqueIDs If the specified cue is a list, cart, or Group cue, return the cue IDs of the child cues of that list, cart, or Group, and the cue IDs of any children of nested Groups.
     */
    async cueNumberChildrenUniqueIDs(requestParameters: CueNumberChildrenUniqueIDsRequest, initOverrides?: RequestInit): Promise<CueNumberChildrenUniqueIDsResponse> {
        const response = await this.cueNumberChildrenUniqueIDsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /cue/{number}/children/uniqueIDs/shallow If the specified cue is a list, cart, or Group cue, return the cue IDs of the child cues of that list, cart, or Group. Nested Groups will not be queried, and so only the first layer of the cue hierarchy will be returned.
     */
    async cueNumberChildrenUniqueIDsShallowRaw(requestParameters: CueNumberChildrenUniqueIDsShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CueNumberChildrenUniqueIDsShallowResponse>> {
        if (requestParameters.number === null || requestParameters.number === undefined) {
            throw new runtime.RequiredError('number','Required parameter requestParameters.number was null or undefined when calling cueNumberChildrenUniqueIDsShallow.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/cue/{number}/children/uniqueIDs/shallow`.replace(`{${"number"}}`, encodeURIComponent(String(requestParameters.number))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CueNumberChildrenUniqueIDsShallowResponseFromJSON(jsonValue));
    }

    /**
     * /cue/{number}/children/uniqueIDs/shallow If the specified cue is a list, cart, or Group cue, return the cue IDs of the child cues of that list, cart, or Group. Nested Groups will not be queried, and so only the first layer of the cue hierarchy will be returned.
     */
    async cueNumberChildrenUniqueIDsShallow(requestParameters: CueNumberChildrenUniqueIDsShallowRequest, initOverrides?: RequestInit): Promise<CueNumberChildrenUniqueIDsShallowResponse> {
        const response = await this.cueNumberChildrenUniqueIDsShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /fontFamiliesAndStyles Return a dictionary with each available font family name (e.g. Helvetica, Courier New) paired with an array of its available styles (e.g. Regular, Light Oblique). For example: {   \"Apple Color Emoji\" :     [       \"Regular\"     ],   \"Apple SD Gothic Neo\" :     [       \"Regular\",       \"Medium\",       \"Light\",       \"UltraLight\",       \"Thin\",       \"SemiBold\",       \"Bold\",       \"ExtraBold\",       \"Heavy\"     ],   ... }
     */
    async fontFamiliesAndStylesRaw(requestParameters: FontFamiliesAndStylesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FontFamiliesAndStylesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fontFamiliesAndStyles`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FontFamiliesAndStylesResponseFromJSON(jsonValue));
    }

    /**
     * /fontFamiliesAndStyles Return a dictionary with each available font family name (e.g. Helvetica, Courier New) paired with an array of its available styles (e.g. Regular, Light Oblique). For example: {   \"Apple Color Emoji\" :     [       \"Regular\"     ],   \"Apple SD Gothic Neo\" :     [       \"Regular\",       \"Medium\",       \"Light\",       \"UltraLight\",       \"Thin\",       \"SemiBold\",       \"Bold\",       \"ExtraBold\",       \"Heavy\"     ],   ... }
     */
    async fontFamiliesAndStyles(requestParameters: FontFamiliesAndStylesRequest = {}, initOverrides?: RequestInit): Promise<FontFamiliesAndStylesResponse> {
        const response = await this.fontFamiliesAndStylesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /fontNames Return an array of the names/PostScript names of all available fonts. For example: [   \"AppleColorEmoji\",   \"AppleSDGothicNeo-Bold\",   \"AppleSDGothicNeo-ExtraBold\",   \"AppleSDGothicNeo-Heavy\",   \"AppleSDGothicNeo-Light\",   ... ]
     */
    async fontNamesRaw(requestParameters: FontNamesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FontNamesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fontNames`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FontNamesResponseFromJSON(jsonValue));
    }

    /**
     * /fontNames Return an array of the names/PostScript names of all available fonts. For example: [   \"AppleColorEmoji\",   \"AppleSDGothicNeo-Bold\",   \"AppleSDGothicNeo-ExtraBold\",   \"AppleSDGothicNeo-Heavy\",   \"AppleSDGothicNeo-Light\",   ... ]
     */
    async fontNames(requestParameters: FontNamesRequest = {}, initOverrides?: RequestInit): Promise<FontNamesResponse> {
        const response = await this.fontNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /liveFadePreview {number} Enable or disable live fade preview. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current status of live fade preview.
     */
    async liveFadePreviewRaw(requestParameters: LiveFadePreviewOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LiveFadePreviewResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/liveFadePreview`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LiveFadePreviewRequestToJSON(requestParameters.liveFadePreviewRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LiveFadePreviewResponseFromJSON(jsonValue));
    }

    /**
     * /liveFadePreview {number} Enable or disable live fade preview. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current status of live fade preview.
     */
    async liveFadePreview(requestParameters: LiveFadePreviewOperationRequest = {}, initOverrides?: RequestInit): Promise<LiveFadePreviewResponse> {
        const response = await this.liveFadePreviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrideWindow {number} Show or hide the Override Window. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current visibility of the Override Window.
     */
    async overrideWindowRaw(requestParameters: OverrideWindowOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverrideWindowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrideWindow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverrideWindowRequestToJSON(requestParameters.overrideWindowRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverrideWindowResponseFromJSON(jsonValue));
    }

    /**
     * /overrideWindow {number} Show or hide the Override Window. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current visibility of the Override Window.
     */
    async overrideWindow(requestParameters: OverrideWindowOperationRequest = {}, initOverrides?: RequestInit): Promise<OverrideWindowResponse> {
        const response = await this.overrideWindowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/artNetEnabled {number} Set the Art-net output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the Art-net output override.
     */
    async overridesArtNetEnabledRaw(requestParameters: OverridesArtNetEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesArtNetEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/artNetEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesArtNetEnabledRequestToJSON(requestParameters.overridesArtNetEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesArtNetEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/artNetEnabled {number} Set the Art-net output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the Art-net output override.
     */
    async overridesArtNetEnabled(requestParameters: OverridesArtNetEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesArtNetEnabledResponse> {
        const response = await this.overridesArtNetEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/midiInputEnabled {number} Set the MIDI input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MIDI input override.
     */
    async overridesMidiInputEnabledRaw(requestParameters: OverridesMidiInputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesMidiInputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/midiInputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesMidiInputEnabledRequestToJSON(requestParameters.overridesMidiInputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesMidiInputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/midiInputEnabled {number} Set the MIDI input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MIDI input override.
     */
    async overridesMidiInputEnabled(requestParameters: OverridesMidiInputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesMidiInputEnabledResponse> {
        const response = await this.overridesMidiInputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/midiOutputEnabled {number} Set the MIDI output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MIDI output override.
     */
    async overridesMidiOutputEnabledRaw(requestParameters: OverridesMidiOutputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesMidiOutputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/midiOutputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesMidiOutputEnabledRequestToJSON(requestParameters.overridesMidiOutputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesMidiOutputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/midiOutputEnabled {number} Set the MIDI output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MIDI output override.
     */
    async overridesMidiOutputEnabled(requestParameters: OverridesMidiOutputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesMidiOutputEnabledResponse> {
        const response = await this.overridesMidiOutputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/mscInputEnabled {number} Set the MSC input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MSC input override.
     */
    async overridesMscInputEnabledRaw(requestParameters: OverridesMscInputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesMscInputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/mscInputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesMscInputEnabledRequestToJSON(requestParameters.overridesMscInputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesMscInputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/mscInputEnabled {number} Set the MSC input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MSC input override.
     */
    async overridesMscInputEnabled(requestParameters: OverridesMscInputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesMscInputEnabledResponse> {
        const response = await this.overridesMscInputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/mscOutputEnabled {number} Set the MSC output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MSC output override.
     */
    async overridesMscOutputEnabledRaw(requestParameters: OverridesMscOutputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesMscOutputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/mscOutputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesMscOutputEnabledRequestToJSON(requestParameters.overridesMscOutputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesMscOutputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/mscOutputEnabled {number} Set the MSC output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MSC output override.
     */
    async overridesMscOutputEnabled(requestParameters: OverridesMscOutputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesMscOutputEnabledResponse> {
        const response = await this.overridesMscOutputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/oscInputEnabled {number} Set the OSC input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the OSC input override.
     */
    async overridesOscInputEnabledRaw(requestParameters: OverridesOscInputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesOscInputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/oscInputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesOscInputEnabledRequestToJSON(requestParameters.overridesOscInputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesOscInputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/oscInputEnabled {number} Set the OSC input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the OSC input override.
     */
    async overridesOscInputEnabled(requestParameters: OverridesOscInputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesOscInputEnabledResponse> {
        const response = await this.overridesOscInputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/oscOutputEnabled {number} Set the OSC output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the OSC output override.
     */
    async overridesOscOutputEnabledRaw(requestParameters: OverridesOscOutputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesOscOutputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/oscOutputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesOscOutputEnabledRequestToJSON(requestParameters.overridesOscOutputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesOscOutputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/oscOutputEnabled {number} Set the OSC output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the OSC output override.
     */
    async overridesOscOutputEnabled(requestParameters: OverridesOscOutputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesOscOutputEnabledResponse> {
        const response = await this.overridesOscOutputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/sysexInputEnabled {number} Set the MIDI SysEx input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MIDI SysEx input override.
     */
    async overridesSysexInputEnabledRaw(requestParameters: OverridesSysexInputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesSysexInputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/sysexInputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesSysexInputEnabledRequestToJSON(requestParameters.overridesSysexInputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesSysexInputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/sysexInputEnabled {number} Set the MIDI SysEx input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MIDI SysEx input override.
     */
    async overridesSysexInputEnabled(requestParameters: OverridesSysexInputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesSysexInputEnabledResponse> {
        const response = await this.overridesSysexInputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/sysexOutputEnabled {number} Set the MIDI SysEx output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MIDI SysEx output override.
     */
    async overridesSysexOutputEnabledRaw(requestParameters: OverridesSysexOutputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesSysexOutputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/sysexOutputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesSysexOutputEnabledRequestToJSON(requestParameters.overridesSysexOutputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesSysexOutputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/sysexOutputEnabled {number} Set the MIDI SysEx output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the MIDI SysEx output override.
     */
    async overridesSysexOutputEnabled(requestParameters: OverridesSysexOutputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesSysexOutputEnabledResponse> {
        const response = await this.overridesSysexOutputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/timecodeInputEnabled {number} Set the timecode input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the timecode input override.
     */
    async overridesTimecodeInputEnabledRaw(requestParameters: OverridesTimecodeInputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesTimecodeInputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/timecodeInputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesTimecodeInputEnabledRequestToJSON(requestParameters.overridesTimecodeInputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesTimecodeInputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/timecodeInputEnabled {number} Set the timecode input override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the timecode input override.
     */
    async overridesTimecodeInputEnabled(requestParameters: OverridesTimecodeInputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesTimecodeInputEnabledResponse> {
        const response = await this.overridesTimecodeInputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/timecodeOutputEnabled {number} Set the timecode output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the timecode output override.
     */
    async overridesTimecodeOutputEnabledRaw(requestParameters: OverridesTimecodeOutputEnabledOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesTimecodeOutputEnabledResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/overrides/timecodeOutputEnabled`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OverridesTimecodeOutputEnabledRequestToJSON(requestParameters.overridesTimecodeOutputEnabledRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesTimecodeOutputEnabledResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/timecodeOutputEnabled {number} Set the timecode output override to true or false. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current state of the timecode output override.
     */
    async overridesTimecodeOutputEnabled(requestParameters: OverridesTimecodeOutputEnabledOperationRequest = {}, initOverrides?: RequestInit): Promise<OverridesTimecodeOutputEnabledResponse> {
        const response = await this.overridesTimecodeOutputEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleArtNet Enable or disable Art-net output.
     */
    async overridesToggleArtNetRaw(requestParameters: OverridesToggleArtNetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleArtNetResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleArtNet`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleArtNetResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleArtNet Enable or disable Art-net output.
     */
    async overridesToggleArtNet(requestParameters: OverridesToggleArtNetRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleArtNetResponse> {
        const response = await this.overridesToggleArtNetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleMidiInput Enable or disable MIDI input.
     */
    async overridesToggleMidiInputRaw(requestParameters: OverridesToggleMidiInputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleMidiInputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleMidiInput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleMidiInputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleMidiInput Enable or disable MIDI input.
     */
    async overridesToggleMidiInput(requestParameters: OverridesToggleMidiInputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleMidiInputResponse> {
        const response = await this.overridesToggleMidiInputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleMidiOutput Enable or disable MIDI output.
     */
    async overridesToggleMidiOutputRaw(requestParameters: OverridesToggleMidiOutputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleMidiOutputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleMidiOutput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleMidiOutputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleMidiOutput Enable or disable MIDI output.
     */
    async overridesToggleMidiOutput(requestParameters: OverridesToggleMidiOutputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleMidiOutputResponse> {
        const response = await this.overridesToggleMidiOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleMscInput Enable or disable MSC input.
     */
    async overridesToggleMscInputRaw(requestParameters: OverridesToggleMscInputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleMscInputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleMscInput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleMscInputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleMscInput Enable or disable MSC input.
     */
    async overridesToggleMscInput(requestParameters: OverridesToggleMscInputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleMscInputResponse> {
        const response = await this.overridesToggleMscInputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleMscOutput Enable or disable MSC output.
     */
    async overridesToggleMscOutputRaw(requestParameters: OverridesToggleMscOutputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleMscOutputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleMscOutput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleMscOutputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleMscOutput Enable or disable MSC output.
     */
    async overridesToggleMscOutput(requestParameters: OverridesToggleMscOutputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleMscOutputResponse> {
        const response = await this.overridesToggleMscOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleOscInput Enable or disable OSC input.
     */
    async overridesToggleOscInputRaw(requestParameters: OverridesToggleOscInputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleOscInputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleOscInput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleOscInputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleOscInput Enable or disable OSC input.
     */
    async overridesToggleOscInput(requestParameters: OverridesToggleOscInputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleOscInputResponse> {
        const response = await this.overridesToggleOscInputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleOscOutput Enable or disable OSC output.
     */
    async overridesToggleOscOutputRaw(requestParameters: OverridesToggleOscOutputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleOscOutputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleOscOutput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleOscOutputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleOscOutput Enable or disable OSC output.
     */
    async overridesToggleOscOutput(requestParameters: OverridesToggleOscOutputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleOscOutputResponse> {
        const response = await this.overridesToggleOscOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleSysexInput Enable or disable SysEx input.
     */
    async overridesToggleSysexInputRaw(requestParameters: OverridesToggleSysexInputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleSysexInputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleSysexInput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleSysexInputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleSysexInput Enable or disable SysEx input.
     */
    async overridesToggleSysexInput(requestParameters: OverridesToggleSysexInputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleSysexInputResponse> {
        const response = await this.overridesToggleSysexInputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleSysexOutput Enable or disable SysEx output.
     */
    async overridesToggleSysexOutputRaw(requestParameters: OverridesToggleSysexOutputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleSysexOutputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleSysexOutput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleSysexOutputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleSysexOutput Enable or disable SysEx output.
     */
    async overridesToggleSysexOutput(requestParameters: OverridesToggleSysexOutputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleSysexOutputResponse> {
        const response = await this.overridesToggleSysexOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleTimecodeInput Enable or disable timecode input.
     */
    async overridesToggleTimecodeInputRaw(requestParameters: OverridesToggleTimecodeInputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleTimecodeInputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleTimecodeInput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleTimecodeInputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleTimecodeInput Enable or disable timecode input.
     */
    async overridesToggleTimecodeInput(requestParameters: OverridesToggleTimecodeInputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleTimecodeInputResponse> {
        const response = await this.overridesToggleTimecodeInputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /overrides/toggleTimecodeOutput Enable or disable timecode output.
     */
    async overridesToggleTimecodeOutputRaw(requestParameters: OverridesToggleTimecodeOutputRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<OverridesToggleTimecodeOutputResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/overrides/toggleTimecodeOutput`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverridesToggleTimecodeOutputResponseFromJSON(jsonValue));
    }

    /**
     * /overrides/toggleTimecodeOutput Enable or disable timecode output.
     */
    async overridesToggleTimecodeOutput(requestParameters: OverridesToggleTimecodeOutputRequest = {}, initOverrides?: RequestInit): Promise<OverridesToggleTimecodeOutputResponse> {
        const response = await this.overridesToggleTimecodeOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /replyFormat {format_string} Set the format of QLabs reply messages to suit your needs. format_string is a string containing your desired reply format. The string can optionally contain the following tokens that will be replaced when sending the reply:  #workspace_id# - the workspace ID #address# - the OSC address of the reply #status# - ok / error #data# - the data of the reply  QLab will do its best to create a reply message with the format you specify. For example, lets say you set QLabs replay format with the following message: /replyFormat #address# #data# Then, if you sent /cue/1/colorName, you would get the reply: /cue/1/colorName green. The #address# token resolves to colorName, since that was the OSC address you sent, and the #data# token resolves to green, assuming the color of cue 1 is in fact green.
     */
    async replyFormatRaw(requestParameters: ReplyFormatOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ReplyFormatResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/replyFormat`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReplyFormatRequestToJSON(requestParameters.replyFormatRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReplyFormatResponseFromJSON(jsonValue));
    }

    /**
     * /replyFormat {format_string} Set the format of QLabs reply messages to suit your needs. format_string is a string containing your desired reply format. The string can optionally contain the following tokens that will be replaced when sending the reply:  #workspace_id# - the workspace ID #address# - the OSC address of the reply #status# - ok / error #data# - the data of the reply  QLab will do its best to create a reply message with the format you specify. For example, lets say you set QLabs replay format with the following message: /replyFormat #address# #data# Then, if you sent /cue/1/colorName, you would get the reply: /cue/1/colorName green. The #address# token resolves to colorName, since that was the OSC address you sent, and the #data# token resolves to green, assuming the color of cue 1 is in fact green.
     */
    async replyFormat(requestParameters: ReplyFormatOperationRequest = {}, initOverrides?: RequestInit): Promise<ReplyFormatResponse> {
        const response = await this.replyFormatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningCuesShallowRaw(requestParameters: RunningCuesShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RunningCuesShallowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/runningCues/shallow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunningCuesShallowResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningCuesShallow(requestParameters: RunningCuesShallowRequest = {}, initOverrides?: RequestInit): Promise<RunningCuesShallowResponse> {
        const response = await this.runningCuesShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningCuesUniqueIDsRaw(requestParameters: RunningCuesUniqueIDsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RunningCuesUniqueIDsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/runningCues/uniqueIDs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunningCuesUniqueIDsResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningCuesUniqueIDs(requestParameters: RunningCuesUniqueIDsRequest = {}, initOverrides?: RequestInit): Promise<RunningCuesUniqueIDsResponse> {
        const response = await this.runningCuesUniqueIDsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningCuesUniqueIDsShallowRaw(requestParameters: RunningCuesUniqueIDsShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RunningCuesUniqueIDsShallowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/runningCues/uniqueIDs/shallow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunningCuesUniqueIDsShallowResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningCuesUniqueIDsShallow(requestParameters: RunningCuesUniqueIDsShallowRequest = {}, initOverrides?: RequestInit): Promise<RunningCuesUniqueIDsShallowResponse> {
        const response = await this.runningCuesUniqueIDsShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningOrPausedCuesShallowRaw(requestParameters: RunningOrPausedCuesShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RunningOrPausedCuesShallowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/runningOrPausedCues/shallow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunningOrPausedCuesShallowResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningOrPausedCuesShallow(requestParameters: RunningOrPausedCuesShallowRequest = {}, initOverrides?: RequestInit): Promise<RunningOrPausedCuesShallowResponse> {
        const response = await this.runningOrPausedCuesShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningOrPausedCuesUniqueIDsRaw(requestParameters: RunningOrPausedCuesUniqueIDsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RunningOrPausedCuesUniqueIDsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/runningOrPausedCues/uniqueIDs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunningOrPausedCuesUniqueIDsResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningOrPausedCuesUniqueIDs(requestParameters: RunningOrPausedCuesUniqueIDsRequest = {}, initOverrides?: RequestInit): Promise<RunningOrPausedCuesUniqueIDsResponse> {
        const response = await this.runningOrPausedCuesUniqueIDsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningOrPausedCuesUniqueIDsShallowRaw(requestParameters: RunningOrPausedCuesUniqueIDsShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RunningOrPausedCuesUniqueIDsShallowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/runningOrPausedCues/uniqueIDs/shallow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunningOrPausedCuesUniqueIDsShallowResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async runningOrPausedCuesUniqueIDsShallow(requestParameters: RunningOrPausedCuesUniqueIDsShallowRequest = {}, initOverrides?: RequestInit): Promise<RunningOrPausedCuesUniqueIDsShallowResponse> {
        const response = await this.runningOrPausedCuesUniqueIDsShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async selectedCuesShallowRaw(requestParameters: SelectedCuesShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SelectedCuesShallowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/selectedCues/shallow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SelectedCuesShallowResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async selectedCuesShallow(requestParameters: SelectedCuesShallowRequest = {}, initOverrides?: RequestInit): Promise<SelectedCuesShallowResponse> {
        const response = await this.selectedCuesShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async selectedCuesUniqueIDsRaw(requestParameters: SelectedCuesUniqueIDsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SelectedCuesUniqueIDsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/selectedCues/uniqueIDs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SelectedCuesUniqueIDsResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async selectedCuesUniqueIDs(requestParameters: SelectedCuesUniqueIDsRequest = {}, initOverrides?: RequestInit): Promise<SelectedCuesUniqueIDsResponse> {
        const response = await this.selectedCuesUniqueIDsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async selectedCuesUniqueIDsShallowRaw(requestParameters: SelectedCuesUniqueIDsShallowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SelectedCuesUniqueIDsShallowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/selectedCues/uniqueIDs/shallow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SelectedCuesUniqueIDsShallowResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async selectedCuesUniqueIDsShallow(requestParameters: SelectedCuesUniqueIDsShallowRequest = {}, initOverrides?: RequestInit): Promise<SelectedCuesUniqueIDsShallowResponse> {
        const response = await this.selectedCuesUniqueIDsShallowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/audio/maxVolume /settings/audio/minVolume Read-only; return the decibel value of the Min: and Max: levels from the Volume Limits section of Workspace Settings > Audio.
     */
    async settingsAudioMaxVolumeRaw(requestParameters: SettingsAudioMaxVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsAudioMaxVolumeResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/settings/audio/maxVolume`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsAudioMaxVolumeResponseFromJSON(jsonValue));
    }

    /**
     * /settings/audio/maxVolume /settings/audio/minVolume Read-only; return the decibel value of the Min: and Max: levels from the Volume Limits section of Workspace Settings > Audio.
     */
    async settingsAudioMaxVolume(requestParameters: SettingsAudioMaxVolumeRequest = {}, initOverrides?: RequestInit): Promise<SettingsAudioMaxVolumeResponse> {
        const response = await this.settingsAudioMaxVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/audio/maxVolume /settings/audio/minVolume Read-only; return the decibel value of the Min: and Max: levels from the Volume Limits section of Workspace Settings > Audio.
     */
    async settingsAudioMinVolumeRaw(requestParameters: SettingsAudioMinVolumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsAudioMinVolumeResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/settings/audio/minVolume`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsAudioMinVolumeResponseFromJSON(jsonValue));
    }

    /**
     * /settings/audio/maxVolume /settings/audio/minVolume Read-only; return the decibel value of the Min: and Max: levels from the Volume Limits section of Workspace Settings > Audio.
     */
    async settingsAudioMinVolume(requestParameters: SettingsAudioMinVolumeRequest = {}, initOverrides?: RequestInit): Promise<SettingsAudioMinVolumeResponse> {
        const response = await this.settingsAudioMinVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/audio/outputChannelNames /settings/mic/outputChannelNames Read-only; return a JSON dictionary of output names for Audio or Mic output patches. The keys in the dictionary are the patch numbers, and the values are dictionaries of output channel numbers and names. If a given patch does not have customized output names, that patch will not be included in the dictionary.
     */
    async settingsAudioOutputChannelNamesRaw(requestParameters: SettingsAudioOutputChannelNamesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsAudioOutputChannelNamesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/settings/audio/outputChannelNames`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsAudioOutputChannelNamesResponseFromJSON(jsonValue));
    }

    /**
     * /settings/audio/outputChannelNames /settings/mic/outputChannelNames Read-only; return a JSON dictionary of output names for Audio or Mic output patches. The keys in the dictionary are the patch numbers, and the values are dictionaries of output channel numbers and names. If a given patch does not have customized output names, that patch will not be included in the dictionary.
     */
    async settingsAudioOutputChannelNames(requestParameters: SettingsAudioOutputChannelNamesRequest = {}, initOverrides?: RequestInit): Promise<SettingsAudioOutputChannelNamesResponse> {
        const response = await this.settingsAudioOutputChannelNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/general/minGoTime {number} If number is given, set the minimum time required between each GO to number seconds. If not, return the minimum time required between each GO.
     */
    async settingsGeneralMinGoTimeRaw(requestParameters: SettingsGeneralMinGoTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsGeneralMinGoTimeResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/settings/general/minGoTime`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SettingsGeneralMinGoTimeRequestToJSON(requestParameters.settingsGeneralMinGoTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsGeneralMinGoTimeResponseFromJSON(jsonValue));
    }

    /**
     * /settings/general/minGoTime {number} If number is given, set the minimum time required between each GO to number seconds. If not, return the minimum time required between each GO.
     */
    async settingsGeneralMinGoTime(requestParameters: SettingsGeneralMinGoTimeOperationRequest = {}, initOverrides?: RequestInit): Promise<SettingsGeneralMinGoTimeResponse> {
        const response = await this.settingsGeneralMinGoTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/audio/outputChannelNames /settings/mic/outputChannelNames Read-only; return a JSON dictionary of output names for Audio or Mic output patches. The keys in the dictionary are the patch numbers, and the values are dictionaries of output channel numbers and names. If a given patch does not have customized output names, that patch will not be included in the dictionary.
     */
    async settingsMicOutputChannelNamesRaw(requestParameters: SettingsMicOutputChannelNamesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsMicOutputChannelNamesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/settings/mic/outputChannelNames`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsMicOutputChannelNamesResponseFromJSON(jsonValue));
    }

    /**
     * /settings/audio/outputChannelNames /settings/mic/outputChannelNames Read-only; return a JSON dictionary of output names for Audio or Mic output patches. The keys in the dictionary are the patch numbers, and the values are dictionaries of output channel numbers and names. If a given patch does not have customized output names, that patch will not be included in the dictionary.
     */
    async settingsMicOutputChannelNames(requestParameters: SettingsMicOutputChannelNamesRequest = {}, initOverrides?: RequestInit): Promise<SettingsMicOutputChannelNamesResponse> {
        const response = await this.settingsMicOutputChannelNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/video/surfaces Read-only; return an array of dictionaries describing all video surfaces defined in the workspace. Each dictionary takes the form: {     \"surfaceID\" : number,     \"surfaceName\" : string,     \"width\" : number,     \"height\" : number,     \"warpType\" : number,     \"patchSplitsX\": array of numbers,     \"patchSplitsY\": array of numbers,     \"screenAssignments\": array (see below), } Each item in the screenAssignments array is a dictionary in this form: {     \"name\" : string,     \"frame\" : string representation of a rectangle (i.e. \"{{0,0} {1280,800}}\"),     \"enableGrid\" : number (BOOL),     \"enableGuides\" : number (BOOL),     \"controlPoints\" : array containing arrays of string representations of points (i.e. \"{0,0}\"), }
     */
    async settingsVideoSurfacesRaw(requestParameters: SettingsVideoSurfacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsVideoSurfacesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/settings/video/surfaces`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsVideoSurfacesResponseFromJSON(jsonValue));
    }

    /**
     * /settings/video/surfaces Read-only; return an array of dictionaries describing all video surfaces defined in the workspace. Each dictionary takes the form: {     \"surfaceID\" : number,     \"surfaceName\" : string,     \"width\" : number,     \"height\" : number,     \"warpType\" : number,     \"patchSplitsX\": array of numbers,     \"patchSplitsY\": array of numbers,     \"screenAssignments\": array (see below), } Each item in the screenAssignments array is a dictionary in this form: {     \"name\" : string,     \"frame\" : string representation of a rectangle (i.e. \"{{0,0} {1280,800}}\"),     \"enableGrid\" : number (BOOL),     \"enableGuides\" : number (BOOL),     \"controlPoints\" : array containing arrays of string representations of points (i.e. \"{0,0}\"), }
     */
    async settingsVideoSurfaces(requestParameters: SettingsVideoSurfacesRequest = {}, initOverrides?: RequestInit): Promise<SettingsVideoSurfacesResponse> {
        const response = await this.settingsVideoSurfacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/video/surfaces/{surfaceID} Read-only; return a dictionary for the specified surface. The dictionaries take the same form as above.
     */
    async settingsVideoSurfacesSurfaceIdRaw(requestParameters: SettingsVideoSurfacesSurfaceIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsVideoSurfacesSurfaceIDResponse>> {
        if (requestParameters.surfaceID === null || requestParameters.surfaceID === undefined) {
            throw new runtime.RequiredError('surfaceID','Required parameter requestParameters.surfaceID was null or undefined when calling settingsVideoSurfacesSurfaceId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/settings/video/surfaces/{surfaceID}`.replace(`{${"surfaceID"}}`, encodeURIComponent(String(requestParameters.surfaceID))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsVideoSurfacesSurfaceIDResponseFromJSON(jsonValue));
    }

    /**
     * /settings/video/surfaces/{surfaceID} Read-only; return a dictionary for the specified surface. The dictionaries take the same form as above.
     */
    async settingsVideoSurfacesSurfaceId(requestParameters: SettingsVideoSurfacesSurfaceIdRequest, initOverrides?: RequestInit): Promise<SettingsVideoSurfacesSurfaceIDResponse> {
        const response = await this.settingsVideoSurfacesSurfaceIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/controlPoint {row_index} {column_index} {location} Set the specified control point on the specified screen in the specified surface to location. location must be a string of the form: {xPosition,yPosition}, including the curly braces, where xPosition and yPosition are both integers. row_index and column_index refer to the grid of control points in their original, unaltered positions. If no argument is provided, return the current location of the specified control point on the specified screen in the specified surface.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexControlPointRaw(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexControlPointRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsVideoSurfacesSurfaceIDScreenIndexControlPointResponse>> {
        if (requestParameters.surfaceID === null || requestParameters.surfaceID === undefined) {
            throw new runtime.RequiredError('surfaceID','Required parameter requestParameters.surfaceID was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexControlPoint.');
        }

        if (requestParameters.screenIndex === null || requestParameters.screenIndex === undefined) {
            throw new runtime.RequiredError('screenIndex','Required parameter requestParameters.screenIndex was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexControlPoint.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/settings/video/surfaces/{surfaceID}/{screenIndex}/controlPoint`.replace(`{${"surfaceID"}}`, encodeURIComponent(String(requestParameters.surfaceID))).replace(`{${"screenIndex"}}`, encodeURIComponent(String(requestParameters.screenIndex))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SettingsVideoSurfacesSurfaceIDScreenIndexControlPointRequestToJSON(requestParameters.settingsVideoSurfacesSurfaceIDScreenIndexControlPointRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsVideoSurfacesSurfaceIDScreenIndexControlPointResponseFromJSON(jsonValue));
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/controlPoint {row_index} {column_index} {location} Set the specified control point on the specified screen in the specified surface to location. location must be a string of the form: {xPosition,yPosition}, including the curly braces, where xPosition and yPosition are both integers. row_index and column_index refer to the grid of control points in their original, unaltered positions. If no argument is provided, return the current location of the specified control point on the specified screen in the specified surface.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexControlPoint(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexControlPointRequest, initOverrides?: RequestInit): Promise<SettingsVideoSurfacesSurfaceIDScreenIndexControlPointResponse> {
        const response = await this.settingsVideoSurfacesSurfaceIdScreenIndexControlPointRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/enableGrid {number} Shows or hides the grid display for the specified screen in the specified surface. number is interpreted as a boolean; 0 equals false (dont show grid), any other number equals true (do show grid.) If no argument is provided, return the current display state of the grid. screenIndex is a range of whole numbers, starting with 0, representing the list of screens assigned to a surface. The first screen listed in the Surface Editor is screenIndex 0, the second is screenIndex 1, and so on.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexEnableGridRaw(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexEnableGridRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridResponse>> {
        if (requestParameters.surfaceID === null || requestParameters.surfaceID === undefined) {
            throw new runtime.RequiredError('surfaceID','Required parameter requestParameters.surfaceID was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexEnableGrid.');
        }

        if (requestParameters.screenIndex === null || requestParameters.screenIndex === undefined) {
            throw new runtime.RequiredError('screenIndex','Required parameter requestParameters.screenIndex was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexEnableGrid.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/settings/video/surfaces/{surfaceID}/{screenIndex}/enableGrid`.replace(`{${"surfaceID"}}`, encodeURIComponent(String(requestParameters.surfaceID))).replace(`{${"screenIndex"}}`, encodeURIComponent(String(requestParameters.screenIndex))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridRequestToJSON(requestParameters.settingsVideoSurfacesSurfaceIDScreenIndexEnableGridRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridResponseFromJSON(jsonValue));
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/enableGrid {number} Shows or hides the grid display for the specified screen in the specified surface. number is interpreted as a boolean; 0 equals false (dont show grid), any other number equals true (do show grid.) If no argument is provided, return the current display state of the grid. screenIndex is a range of whole numbers, starting with 0, representing the list of screens assigned to a surface. The first screen listed in the Surface Editor is screenIndex 0, the second is screenIndex 1, and so on.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexEnableGrid(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexEnableGridRequest, initOverrides?: RequestInit): Promise<SettingsVideoSurfacesSurfaceIDScreenIndexEnableGridResponse> {
        const response = await this.settingsVideoSurfacesSurfaceIdScreenIndexEnableGridRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/enableGuides {number} Shows or hides the guides on the specified screen in the specified surface. number is interpreted as a boolean; 0 equals false (dont show guides), any other number equals true (do show grid.) If no argument is provided, return the current display state of the guides.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexEnableGuidesRaw(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexEnableGuidesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesResponse>> {
        if (requestParameters.surfaceID === null || requestParameters.surfaceID === undefined) {
            throw new runtime.RequiredError('surfaceID','Required parameter requestParameters.surfaceID was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexEnableGuides.');
        }

        if (requestParameters.screenIndex === null || requestParameters.screenIndex === undefined) {
            throw new runtime.RequiredError('screenIndex','Required parameter requestParameters.screenIndex was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexEnableGuides.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/settings/video/surfaces/{surfaceID}/{screenIndex}/enableGuides`.replace(`{${"surfaceID"}}`, encodeURIComponent(String(requestParameters.surfaceID))).replace(`{${"screenIndex"}}`, encodeURIComponent(String(requestParameters.screenIndex))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesRequestToJSON(requestParameters.settingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesResponseFromJSON(jsonValue));
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/enableGuides {number} Shows or hides the guides on the specified screen in the specified surface. number is interpreted as a boolean; 0 equals false (dont show guides), any other number equals true (do show grid.) If no argument is provided, return the current display state of the guides.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexEnableGuides(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexEnableGuidesRequest, initOverrides?: RequestInit): Promise<SettingsVideoSurfacesSurfaceIDScreenIndexEnableGuidesResponse> {
        const response = await this.settingsVideoSurfacesSurfaceIdScreenIndexEnableGuidesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/origin {location} Set the origin point for the specified screen in the specified surface to location. location must be a string of the form: {xPosition,yPosition}, including the curly braces, where xPosition and yPosition are both integers. If no argument is provided, return the current location of the origin for the specified screen in the specified surface.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexOriginRaw(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexOriginRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsVideoSurfacesSurfaceIDScreenIndexOriginResponse>> {
        if (requestParameters.surfaceID === null || requestParameters.surfaceID === undefined) {
            throw new runtime.RequiredError('surfaceID','Required parameter requestParameters.surfaceID was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexOrigin.');
        }

        if (requestParameters.screenIndex === null || requestParameters.screenIndex === undefined) {
            throw new runtime.RequiredError('screenIndex','Required parameter requestParameters.screenIndex was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexOrigin.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/settings/video/surfaces/{surfaceID}/{screenIndex}/origin`.replace(`{${"surfaceID"}}`, encodeURIComponent(String(requestParameters.surfaceID))).replace(`{${"screenIndex"}}`, encodeURIComponent(String(requestParameters.screenIndex))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SettingsVideoSurfacesSurfaceIDScreenIndexOriginRequestToJSON(requestParameters.settingsVideoSurfacesSurfaceIDScreenIndexOriginRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsVideoSurfacesSurfaceIDScreenIndexOriginResponseFromJSON(jsonValue));
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/origin {location} Set the origin point for the specified screen in the specified surface to location. location must be a string of the form: {xPosition,yPosition}, including the curly braces, where xPosition and yPosition are both integers. If no argument is provided, return the current location of the origin for the specified screen in the specified surface.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexOrigin(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexOriginRequest, initOverrides?: RequestInit): Promise<SettingsVideoSurfacesSurfaceIDScreenIndexOriginResponse> {
        const response = await this.settingsVideoSurfacesSurfaceIdScreenIndexOriginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/resetControlPoints Reset all control points for the specified screen in the specified surface.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexResetControlPointsRaw(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexResetControlPointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SettingsVideoSurfacesSurfaceIDScreenIndexResetControlPointsResponse>> {
        if (requestParameters.surfaceID === null || requestParameters.surfaceID === undefined) {
            throw new runtime.RequiredError('surfaceID','Required parameter requestParameters.surfaceID was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexResetControlPoints.');
        }

        if (requestParameters.screenIndex === null || requestParameters.screenIndex === undefined) {
            throw new runtime.RequiredError('screenIndex','Required parameter requestParameters.screenIndex was null or undefined when calling settingsVideoSurfacesSurfaceIdScreenIndexResetControlPoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/settings/video/surfaces/{surfaceID}/{screenIndex}/resetControlPoints`.replace(`{${"surfaceID"}}`, encodeURIComponent(String(requestParameters.surfaceID))).replace(`{${"screenIndex"}}`, encodeURIComponent(String(requestParameters.screenIndex))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsVideoSurfacesSurfaceIDScreenIndexResetControlPointsResponseFromJSON(jsonValue));
    }

    /**
     * /settings/video/surfaces/{surfaceID}/{screenIndex}/resetControlPoints Reset all control points for the specified screen in the specified surface.
     */
    async settingsVideoSurfacesSurfaceIdScreenIndexResetControlPoints(requestParameters: SettingsVideoSurfacesSurfaceIdScreenIndexResetControlPointsRequest, initOverrides?: RequestInit): Promise<SettingsVideoSurfacesSurfaceIDScreenIndexResetControlPointsResponse> {
        const response = await this.settingsVideoSurfacesSurfaceIdScreenIndexResetControlPointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /timecodeWindow {number} Show or hide the Timecode Window. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current visibility of the Timecode Window.
     */
    async timecodeWindowRaw(requestParameters: TimecodeWindowOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TimecodeWindowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timecodeWindow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TimecodeWindowRequestToJSON(requestParameters.timecodeWindowRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TimecodeWindowResponseFromJSON(jsonValue));
    }

    /**
     * /timecodeWindow {number} Show or hide the Timecode Window. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current visibility of the Timecode Window.
     */
    async timecodeWindow(requestParameters: TimecodeWindowOperationRequest = {}, initOverrides?: RequestInit): Promise<TimecodeWindowResponse> {
        const response = await this.timecodeWindowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /toggleAuditionWindow Show or hide the Audition Window.
     */
    async toggleAuditionWindowRaw(requestParameters: ToggleAuditionWindowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ToggleAuditionWindowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/toggleAuditionWindow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ToggleAuditionWindowResponseFromJSON(jsonValue));
    }

    /**
     * /toggleAuditionWindow Show or hide the Audition Window.
     */
    async toggleAuditionWindow(requestParameters: ToggleAuditionWindowRequest = {}, initOverrides?: RequestInit): Promise<ToggleAuditionWindowResponse> {
        const response = await this.toggleAuditionWindowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /toggleLiveFadePreview Enable or disable live fade preview.
     */
    async toggleLiveFadePreviewRaw(requestParameters: ToggleLiveFadePreviewRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ToggleLiveFadePreviewResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/toggleLiveFadePreview`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ToggleLiveFadePreviewResponseFromJSON(jsonValue));
    }

    /**
     * /toggleLiveFadePreview Enable or disable live fade preview.
     */
    async toggleLiveFadePreview(requestParameters: ToggleLiveFadePreviewRequest = {}, initOverrides?: RequestInit): Promise<ToggleLiveFadePreviewResponse> {
        const response = await this.toggleLiveFadePreviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /toggleOverrideWindow Show or hide the Override Window.
     */
    async toggleOverrideWindowRaw(requestParameters: ToggleOverrideWindowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ToggleOverrideWindowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/toggleOverrideWindow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ToggleOverrideWindowResponseFromJSON(jsonValue));
    }

    /**
     * /toggleOverrideWindow Show or hide the Override Window.
     */
    async toggleOverrideWindow(requestParameters: ToggleOverrideWindowRequest = {}, initOverrides?: RequestInit): Promise<ToggleOverrideWindowResponse> {
        const response = await this.toggleOverrideWindowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /toggleTimecodeWindow Show or hide the Timecode Window.
     */
    async toggleTimecodeWindowRaw(requestParameters: ToggleTimecodeWindowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ToggleTimecodeWindowResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/toggleTimecodeWindow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ToggleTimecodeWindowResponseFromJSON(jsonValue));
    }

    /**
     * /toggleTimecodeWindow Show or hide the Timecode Window.
     */
    async toggleTimecodeWindow(requestParameters: ToggleTimecodeWindowRequest = {}, initOverrides?: RequestInit): Promise<ToggleTimecodeWindowResponse> {
        const response = await this.toggleTimecodeWindowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /version Return QLabs version number.
     */
    async versionRaw(requestParameters: VersionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<VersionResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/version`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionResponseFromJSON(jsonValue));
    }

    /**
     * /version Return QLabs version number.
     */
    async version(requestParameters: VersionRequest = {}, initOverrides?: RequestInit): Promise<VersionResponse> {
        const response = await this.versionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workingDirectory {path} Get or set the current working directory. If provided, the path string is the working directory you wish to set. You can provide two kinds of paths:  Full paths, e.g. /a/full/path/to/some/directory/ Paths beginning with a tilde, e.g. ~/a/path/to some/directory  Paths beginning with a tilde (~) will be expanded; the tilde signifies relative to the users home directory.
     */
    async workingDirectoryRaw(requestParameters: WorkingDirectoryOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkingDirectoryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workingDirectory`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkingDirectoryRequestToJSON(requestParameters.workingDirectoryRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkingDirectoryResponseFromJSON(jsonValue));
    }

    /**
     * /workingDirectory {path} Get or set the current working directory. If provided, the path string is the working directory you wish to set. You can provide two kinds of paths:  Full paths, e.g. /a/full/path/to/some/directory/ Paths beginning with a tilde, e.g. ~/a/path/to some/directory  Paths beginning with a tilde (~) will be expanded; the tilde signifies relative to the users home directory.
     */
    async workingDirectory(requestParameters: WorkingDirectoryOperationRequest = {}, initOverrides?: RequestInit): Promise<WorkingDirectoryResponse> {
        const response = await this.workingDirectoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/basePath Return a string which is the path to the directory containing the QLab workspace. If the workspace is not yet saved, this will be an empty string.
     */
    async workspaceIdBasePathRaw(requestParameters: WorkspaceIdBasePathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdBasePathResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdBasePath.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/basePath`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdBasePathResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/basePath Return a string which is the path to the directory containing the QLab workspace. If the workspace is not yet saved, this will be an empty string.
     */
    async workspaceIdBasePath(requestParameters: WorkspaceIdBasePathRequest, initOverrides?: RequestInit): Promise<WorkspaceIdBasePathResponse> {
        const response = await this.workspaceIdBasePathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/connect {passcode_string} Connect to this workspace with an optional passcode string. If the workspace has a passcode, you MUST supply it before any other commands will be accepted by the workspace or the cues it contains. If the workspace does not have a passcode, the /workspace/{id}/connect method is optional. Returns ok if there is no passcode, or the passcode matches. Returns badpass if the passcode does not match. Returns error if the workspace does not exist.
     */
    async workspaceIdConnectRaw(requestParameters: WorkspaceIdConnectOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdConnectResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdConnect.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/connect`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdConnectRequestToJSON(requestParameters.workspaceIdConnectRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdConnectResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/connect {passcode_string} Connect to this workspace with an optional passcode string. If the workspace has a passcode, you MUST supply it before any other commands will be accepted by the workspace or the cues it contains. If the workspace does not have a passcode, the /workspace/{id}/connect method is optional. Returns ok if there is no passcode, or the passcode matches. Returns badpass if the passcode does not match. Returns error if the workspace does not exist.
     */
    async workspaceIdConnect(requestParameters: WorkspaceIdConnectOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdConnectResponse> {
        const response = await this.workspaceIdConnectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async workspaceIdCueListsRaw(requestParameters: WorkspaceIdCueListsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdCueListsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdCueLists.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/cueLists`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdCueListsResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async workspaceIdCueLists(requestParameters: WorkspaceIdCueListsRequest, initOverrides?: RequestInit): Promise<WorkspaceIdCueListsResponse> {
        const response = await this.workspaceIdCueListsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardClearRaw(requestParameters: WorkspaceIdDashboardClearRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardClearResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardClear.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/clear`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardClearResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardClear(requestParameters: WorkspaceIdDashboardClearRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardClearResponse> {
        const response = await this.workspaceIdDashboardClearRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/mode {string} Set the Light Dashboards view mode to string. Supported modes are sliders and tiles. If no argument is provided, this method does nothing.
     */
    async workspaceIdDashboardModeRaw(requestParameters: WorkspaceIdDashboardModeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardModeResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardMode.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/dashboard/mode`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdDashboardModeRequestToJSON(requestParameters.workspaceIdDashboardModeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardModeResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/mode {string} Set the Light Dashboards view mode to string. Supported modes are sliders and tiles. If no argument is provided, this method does nothing.
     */
    async workspaceIdDashboardMode(requestParameters: WorkspaceIdDashboardModeOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardModeResponse> {
        const response = await this.workspaceIdDashboardModeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardNewCueWithAllRaw(requestParameters: WorkspaceIdDashboardNewCueWithAllRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardNewCueWithAllResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardNewCueWithAll.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/newCueWithAll`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardNewCueWithAllResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardNewCueWithAll(requestParameters: WorkspaceIdDashboardNewCueWithAllRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardNewCueWithAllResponse> {
        const response = await this.workspaceIdDashboardNewCueWithAllRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardNewCueWithChangesRaw(requestParameters: WorkspaceIdDashboardNewCueWithChangesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardNewCueWithChangesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardNewCueWithChanges.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/newCueWithChanges`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardNewCueWithChangesResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardNewCueWithChanges(requestParameters: WorkspaceIdDashboardNewCueWithChangesRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardNewCueWithChangesResponse> {
        const response = await this.workspaceIdDashboardNewCueWithChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/nextMode Toggles between sliders and tiles view modes in the Light Dashboard.
     */
    async workspaceIdDashboardNextModeRaw(requestParameters: WorkspaceIdDashboardNextModeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardNextModeResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardNextMode.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/nextMode`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardNextModeResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/nextMode Toggles between sliders and tiles view modes in the Light Dashboard.
     */
    async workspaceIdDashboardNextMode(requestParameters: WorkspaceIdDashboardNextModeRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardNextModeResponse> {
        const response = await this.workspaceIdDashboardNextModeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardRecordAllToLatestRaw(requestParameters: WorkspaceIdDashboardRecordAllToLatestRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardRecordAllToLatestResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardRecordAllToLatest.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/recordAllToLatest`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardRecordAllToLatestResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardRecordAllToLatest(requestParameters: WorkspaceIdDashboardRecordAllToLatestRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardRecordAllToLatestResponse> {
        const response = await this.workspaceIdDashboardRecordAllToLatestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardRecordAllToSelectedRaw(requestParameters: WorkspaceIdDashboardRecordAllToSelectedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardRecordAllToSelectedResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardRecordAllToSelected.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/recordAllToSelected`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardRecordAllToSelectedResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardRecordAllToSelected(requestParameters: WorkspaceIdDashboardRecordAllToSelectedRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardRecordAllToSelectedResponse> {
        const response = await this.workspaceIdDashboardRecordAllToSelectedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/redo Re-does the last action taken in the Light Dashboard. If nothing has been un-done in the Dashboard, this command has no effect.
     */
    async workspaceIdDashboardRedoRaw(requestParameters: WorkspaceIdDashboardRedoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardRedoResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardRedo.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/redo`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardRedoResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/redo Re-does the last action taken in the Light Dashboard. If nothing has been un-done in the Dashboard, this command has no effect.
     */
    async workspaceIdDashboardRedo(requestParameters: WorkspaceIdDashboardRedoRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardRedoResponse> {
        const response = await this.workspaceIdDashboardRedoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardRevertRaw(requestParameters: WorkspaceIdDashboardRevertRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardRevertResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardRevert.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/revert`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardRevertResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardRevert(requestParameters: WorkspaceIdDashboardRevertRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardRevertResponse> {
        const response = await this.workspaceIdDashboardRevertRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/setLight {string} {setting} {time} Set instrument or light group string to level setting in the Light Dashboard. string may include a parameter name; if it does not, the default parameter for the specified instrument or light group will be addressed. setting must be an acceptable value for the specified parameter of the specified instrument or group. If setting is a decimal number, the Light Dashboard may round it to the nearest equivalent DMX value. time is an optional whole or decimal number. If provided, the parameter will be faded from its current value to level over that many seconds. If time is omitted, it will be assumed to be 0.0 seconds.
     */
    async workspaceIdDashboardSetLightRaw(requestParameters: WorkspaceIdDashboardSetLightOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardSetLightResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardSetLight.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/dashboard/setLight`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdDashboardSetLightRequestToJSON(requestParameters.workspaceIdDashboardSetLightRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardSetLightResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/setLight {string} {setting} {time} Set instrument or light group string to level setting in the Light Dashboard. string may include a parameter name; if it does not, the default parameter for the specified instrument or light group will be addressed. setting must be an acceptable value for the specified parameter of the specified instrument or group. If setting is a decimal number, the Light Dashboard may round it to the nearest equivalent DMX value. time is an optional whole or decimal number. If provided, the parameter will be faded from its current value to level over that many seconds. If time is omitted, it will be assumed to be 0.0 seconds.
     */
    async workspaceIdDashboardSetLight(requestParameters: WorkspaceIdDashboardSetLightOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardSetLightResponse> {
        const response = await this.workspaceIdDashboardSetLightRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/undo Un-does the last action taken in the Light Dashboard. If nothing has been done in the Dashboard, this command has no effect.
     */
    async workspaceIdDashboardUndoRaw(requestParameters: WorkspaceIdDashboardUndoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardUndoResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardUndo.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/undo`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardUndoResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/undo Un-does the last action taken in the Light Dashboard. If nothing has been done in the Dashboard, this command has no effect.
     */
    async workspaceIdDashboardUndo(requestParameters: WorkspaceIdDashboardUndoRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardUndoResponse> {
        const response = await this.workspaceIdDashboardUndoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardUpdateLatestCueRaw(requestParameters: WorkspaceIdDashboardUpdateLatestCueRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardUpdateLatestCueResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardUpdateLatestCue.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/updateLatestCue`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardUpdateLatestCueResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardUpdateLatestCue(requestParameters: WorkspaceIdDashboardUpdateLatestCueRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardUpdateLatestCueResponse> {
        const response = await this.workspaceIdDashboardUpdateLatestCueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardUpdateOriginatingCuesRaw(requestParameters: WorkspaceIdDashboardUpdateOriginatingCuesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardUpdateOriginatingCuesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardUpdateOriginatingCues.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/updateOriginatingCues`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardUpdateOriginatingCuesResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardUpdateOriginatingCues(requestParameters: WorkspaceIdDashboardUpdateOriginatingCuesRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardUpdateOriginatingCuesResponse> {
        const response = await this.workspaceIdDashboardUpdateOriginatingCuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardUpdateSelectedCuesRaw(requestParameters: WorkspaceIdDashboardUpdateSelectedCuesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDashboardUpdateSelectedCuesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDashboardUpdateSelectedCues.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/dashboard/updateSelectedCues`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDashboardUpdateSelectedCuesResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/dashboard/clear /workspace/{id}/dashboard/updateLatestCue /workspace/{id}/dashboard/updateOriginatingCues /workspace/{id}/dashboard/updateSelectedCues /workspace/{id}/dashboard/newCueWithAll /workspace/{id}/dashboard/newCueWithChanges /workspace/{id}/dashboard/recordAllToLatest /workspace/{id}/dashboard/recordAllToSelected /workspace/{id}/dashboard/revert These commands are the equivalent of clicking their corresponding buttons in the Light Dashboard.
     */
    async workspaceIdDashboardUpdateSelectedCues(requestParameters: WorkspaceIdDashboardUpdateSelectedCuesRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDashboardUpdateSelectedCuesResponse> {
        const response = await this.workspaceIdDashboardUpdateSelectedCuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/delete/{cue_number} /workspace/{id}/delete_id/{cue_id} /workspace/{id}/delete/active /workspace/{id}/delete/selected Delete the specified cue(s).
     */
    async workspaceIdDeleteActiveRaw(requestParameters: WorkspaceIdDeleteActiveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDeleteActiveResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDeleteActive.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/delete/active`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDeleteActiveResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/delete/{cue_number} /workspace/{id}/delete_id/{cue_id} /workspace/{id}/delete/active /workspace/{id}/delete/selected Delete the specified cue(s).
     */
    async workspaceIdDeleteActive(requestParameters: WorkspaceIdDeleteActiveRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDeleteActiveResponse> {
        const response = await this.workspaceIdDeleteActiveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/delete/{cue_number} /workspace/{id}/delete_id/{cue_id} /workspace/{id}/delete/active /workspace/{id}/delete/selected Delete the specified cue(s).
     */
    async workspaceIdDeleteCueNumberRaw(requestParameters: WorkspaceIdDeleteCueNumberRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDeleteCueNumberResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDeleteCueNumber.');
        }

        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling workspaceIdDeleteCueNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/delete/{cue_number}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDeleteCueNumberResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/delete/{cue_number} /workspace/{id}/delete_id/{cue_id} /workspace/{id}/delete/active /workspace/{id}/delete/selected Delete the specified cue(s).
     */
    async workspaceIdDeleteCueNumber(requestParameters: WorkspaceIdDeleteCueNumberRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDeleteCueNumberResponse> {
        const response = await this.workspaceIdDeleteCueNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/delete/{cue_number} /workspace/{id}/delete_id/{cue_id} /workspace/{id}/delete/active /workspace/{id}/delete/selected Delete the specified cue(s).
     */
    async workspaceIdDeleteIdCueIdRaw(requestParameters: WorkspaceIdDeleteIdCueIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDeleteIdCueIdResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDeleteIdCueId.');
        }

        if (requestParameters.cueId === null || requestParameters.cueId === undefined) {
            throw new runtime.RequiredError('cueId','Required parameter requestParameters.cueId was null or undefined when calling workspaceIdDeleteIdCueId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/delete_id/{cue_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_id"}}`, encodeURIComponent(String(requestParameters.cueId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDeleteIdCueIdResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/delete/{cue_number} /workspace/{id}/delete_id/{cue_id} /workspace/{id}/delete/active /workspace/{id}/delete/selected Delete the specified cue(s).
     */
    async workspaceIdDeleteIdCueId(requestParameters: WorkspaceIdDeleteIdCueIdRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDeleteIdCueIdResponse> {
        const response = await this.workspaceIdDeleteIdCueIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/delete/{cue_number} /workspace/{id}/delete_id/{cue_id} /workspace/{id}/delete/active /workspace/{id}/delete/selected Delete the specified cue(s).
     */
    async workspaceIdDeleteSelectedRaw(requestParameters: WorkspaceIdDeleteSelectedRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDeleteSelectedResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDeleteSelected.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/delete/selected`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDeleteSelectedResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/delete/{cue_number} /workspace/{id}/delete_id/{cue_id} /workspace/{id}/delete/active /workspace/{id}/delete/selected Delete the specified cue(s).
     */
    async workspaceIdDeleteSelected(requestParameters: WorkspaceIdDeleteSelectedRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDeleteSelectedResponse> {
        const response = await this.workspaceIdDeleteSelectedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/disconnect Disconnect from this workspace. You should invoke this method when you will no longer be sending messages to this workspace. If you are communicating to QLab via UDP, QLab will automatically disconnect your client if it has not heard any messages from it in the last 61 seconds. Any message (e.g. thump) will serve to keep the client connected. If you are disconnected and the workspace has a password, you will need to reconnect with that password before further commands will be accepted. If you are communicating to QLab via TCP, QLab will not automatically disconnect your client. The client will remain connected until the client sends the disconnect message or the TCP connection itself is disconnected.
     */
    async workspaceIdDisconnectRaw(requestParameters: WorkspaceIdDisconnectRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDisconnectResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDisconnect.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/disconnect`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDisconnectResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/disconnect Disconnect from this workspace. You should invoke this method when you will no longer be sending messages to this workspace. If you are communicating to QLab via UDP, QLab will automatically disconnect your client if it has not heard any messages from it in the last 61 seconds. Any message (e.g. thump) will serve to keep the client connected. If you are disconnected and the workspace has a password, you will need to reconnect with that password before further commands will be accepted. If you are communicating to QLab via TCP, QLab will not automatically disconnect your client. The client will remain connected until the client sends the disconnect message or the TCP connection itself is disconnected.
     */
    async workspaceIdDisconnect(requestParameters: WorkspaceIdDisconnectRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDisconnectResponse> {
        const response = await this.workspaceIdDisconnectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/doubleGoWindowRemaining Read-only; when workspace double go protection is engaged, return the number of seconds that must elapse until the next GO is permitted. Returns 0 when a GO is currently allowed or if double go protection is not enabled.
     */
    async workspaceIdDoubleGoWindowRemainingRaw(requestParameters: WorkspaceIdDoubleGoWindowRemainingRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdDoubleGoWindowRemainingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDoubleGoWindowRemaining.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/doubleGoWindowRemaining`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdDoubleGoWindowRemainingResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/doubleGoWindowRemaining Read-only; when workspace double go protection is engaged, return the number of seconds that must elapse until the next GO is permitted. Returns 0 when a GO is currently allowed or if double go protection is not enabled.
     */
    async workspaceIdDoubleGoWindowRemaining(requestParameters: WorkspaceIdDoubleGoWindowRemainingRequest, initOverrides?: RequestInit): Promise<WorkspaceIdDoubleGoWindowRemainingResponse> {
        const response = await this.workspaceIdDoubleGoWindowRemainingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/fullScreen {number} Number is interpreted as a boolean, and sets whether the workspace is displayed in macOS full screen mode. If no argument is provided, this returns the current full screen status of the workspace.
     */
    async workspaceIdFullScreenRaw(requestParameters: WorkspaceIdFullScreenOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdFullScreenResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdFullScreen.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/fullScreen`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdFullScreenRequestToJSON(requestParameters.workspaceIdFullScreenRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdFullScreenResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/fullScreen {number} Number is interpreted as a boolean, and sets whether the workspace is displayed in macOS full screen mode. If no argument is provided, this returns the current full screen status of the workspace.
     */
    async workspaceIdFullScreen(requestParameters: WorkspaceIdFullScreenOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdFullScreenResponse> {
        const response = await this.workspaceIdFullScreenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/go {cue_number} Tell the current cue list of the given workspace to GO. cue_number is optional; if given, it must match a cue number in the given workspace. QLab will jump to the specified cue and then GO. If no argument is provided, the current cue list in the given workspace will GO on whatever cue is currently standing by. In this OSC method, QLab cannot use the same technique it uses in other places to turn numbers into strings when necessary. Therefore, when using cue_number in this method, it must always be enclosed in quotation marks.   : /go  : /go \"53\"  : /go 53 
     */
    async workspaceIdGoRaw(requestParameters: WorkspaceIdGoOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdGoResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdGo.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/go`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdGoRequestToJSON(requestParameters.workspaceIdGoRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdGoResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/go {cue_number} Tell the current cue list of the given workspace to GO. cue_number is optional; if given, it must match a cue number in the given workspace. QLab will jump to the specified cue and then GO. If no argument is provided, the current cue list in the given workspace will GO on whatever cue is currently standing by. In this OSC method, QLab cannot use the same technique it uses in other places to turn numbers into strings when necessary. Therefore, when using cue_number in this method, it must always be enclosed in quotation marks.   : /go  : /go \"53\"  : /go 53 
     */
    async workspaceIdGo(requestParameters: WorkspaceIdGoOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdGoResponse> {
        const response = await this.workspaceIdGoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/go/{cue_number} Tell QLab to jump to cue cue_number and then GO. cue_number must match a cue number in the given workspace.
     */
    async workspaceIdGoCueNumberRaw(requestParameters: WorkspaceIdGoCueNumberRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdGoCueNumberResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdGoCueNumber.');
        }

        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling workspaceIdGoCueNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/go/{cue_number}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdGoCueNumberResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/go/{cue_number} Tell QLab to jump to cue cue_number and then GO. cue_number must match a cue number in the given workspace.
     */
    async workspaceIdGoCueNumber(requestParameters: WorkspaceIdGoCueNumberRequest, initOverrides?: RequestInit): Promise<WorkspaceIdGoCueNumberResponse> {
        const response = await this.workspaceIdGoCueNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/hardStop Stop playback and cut all effects immediately.
     */
    async workspaceIdHardStopRaw(requestParameters: WorkspaceIdHardStopRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdHardStopResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdHardStop.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/hardStop`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdHardStopResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/hardStop Stop playback and cut all effects immediately.
     */
    async workspaceIdHardStop(requestParameters: WorkspaceIdHardStopRequest, initOverrides?: RequestInit): Promise<WorkspaceIdHardStopResponse> {
        const response = await this.workspaceIdHardStopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/lightDashboard {number} Show or hide the Light Dashboard. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current visibility of the Light Dashboard.
     */
    async workspaceIdLightDashboardRaw(requestParameters: WorkspaceIdLightDashboardOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdLightDashboardResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdLightDashboard.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/lightDashboard`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdLightDashboardRequestToJSON(requestParameters.workspaceIdLightDashboardRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdLightDashboardResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/lightDashboard {number} Show or hide the Light Dashboard. number is interpreted as a boolean; 0 equals false, any other number equals true. If no argument is provided, return the current visibility of the Light Dashboard.
     */
    async workspaceIdLightDashboard(requestParameters: WorkspaceIdLightDashboardOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdLightDashboardResponse> {
        const response = await this.workspaceIdLightDashboardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/move/{cue_id} {new_index} {new_parent_cue_id} Move the specified cue from its current position to the given new_index position within the cues current parent Group, Cart, or List. new_index is required and must be an integer. new_parent_cue_id is optional, and must be a string. If new_parent_cue_id is provided, move the specified cue from its current position to the given new_index position within the Group, Cart, or List whose unique ID is new_parent_cue_id. If the move fails for any reason (i.e. a Group Cue cannot be moved inside of another Group cue that it already contains), QLab will send an error reply. If the move succeeds, QLab will reply with status: ok and data containing a dictionary with 2 key/value pairs: [     {         \"parent_cue_id\": string,         \"index\": integer     } ] parent_cue_id is a string with the unique ID of the Group, Cart, or List that contains the cue that was moved. index is an integer with the index of the position of the moved cue in its new parent.
     */
    async workspaceIdMoveCueIdRaw(requestParameters: WorkspaceIdMoveCueIdOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdMoveCueIdResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdMoveCueId.');
        }

        if (requestParameters.cueId === null || requestParameters.cueId === undefined) {
            throw new runtime.RequiredError('cueId','Required parameter requestParameters.cueId was null or undefined when calling workspaceIdMoveCueId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/move/{cue_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_id"}}`, encodeURIComponent(String(requestParameters.cueId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdMoveCueIdRequestToJSON(requestParameters.workspaceIdMoveCueIdRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdMoveCueIdResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/move/{cue_id} {new_index} {new_parent_cue_id} Move the specified cue from its current position to the given new_index position within the cues current parent Group, Cart, or List. new_index is required and must be an integer. new_parent_cue_id is optional, and must be a string. If new_parent_cue_id is provided, move the specified cue from its current position to the given new_index position within the Group, Cart, or List whose unique ID is new_parent_cue_id. If the move fails for any reason (i.e. a Group Cue cannot be moved inside of another Group cue that it already contains), QLab will send an error reply. If the move succeeds, QLab will reply with status: ok and data containing a dictionary with 2 key/value pairs: [     {         \"parent_cue_id\": string,         \"index\": integer     } ] parent_cue_id is a string with the unique ID of the Group, Cart, or List that contains the cue that was moved. index is an integer with the index of the position of the moved cue in its new parent.
     */
    async workspaceIdMoveCueId(requestParameters: WorkspaceIdMoveCueIdOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdMoveCueIdResponse> {
        const response = await this.workspaceIdMoveCueIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/new {cue_type} Create a new cue. cue_type is a string stating which kind of cue to create. Supported strings include: audio, mic, video, camera, text, light, fade, network, midi, midi file, timecode, group, start, stop, pause, load, reset, devamp, goto, target, arm, disarm, wait, memo, script, list, cuelist, cue list, cart, cuecart, or cue cart. This method returns the unique ID of the new cue. The newly created cue will also be selected, so subsequent commands can address the new cue either using the unique ID or simply addressing the currently selected cue. This method has three optional additional arguments: /workspace/{id}/new {cue_type} {cue_ID} {cart_row} {cart_column} If {cue_ID} is supplied, the new cue will be created after that cue. If {cue_ID} specifies a cart, the new cue will be created within the cart. You must then specify the position in the cart using {cart_row} and {cart_column}. {cart_row} and {cart_column} must be integers.
     */
    async workspaceIdNewRaw(requestParameters: WorkspaceIdNewOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdNewResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdNew.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/new`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdNewRequestToJSON(requestParameters.workspaceIdNewRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdNewResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/new {cue_type} Create a new cue. cue_type is a string stating which kind of cue to create. Supported strings include: audio, mic, video, camera, text, light, fade, network, midi, midi file, timecode, group, start, stop, pause, load, reset, devamp, goto, target, arm, disarm, wait, memo, script, list, cuelist, cue list, cart, cuecart, or cue cart. This method returns the unique ID of the new cue. The newly created cue will also be selected, so subsequent commands can address the new cue either using the unique ID or simply addressing the currently selected cue. This method has three optional additional arguments: /workspace/{id}/new {cue_type} {cue_ID} {cart_row} {cart_column} If {cue_ID} is supplied, the new cue will be created after that cue. If {cue_ID} specifies a cart, the new cue will be created within the cart. You must then specify the position in the cart using {cart_row} and {cart_column}. {cart_row} and {cart_column} must be integers.
     */
    async workspaceIdNew(requestParameters: WorkspaceIdNewOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdNewResponse> {
        const response = await this.workspaceIdNewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/panic Tell the workspace to panic. A panic is a brief gradual fade out leading into a hard stop. A double panic will trigger an immediate hard stop.
     */
    async workspaceIdPanicRaw(requestParameters: WorkspaceIdPanicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPanicResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPanic.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/panic`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPanicResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/panic Tell the workspace to panic. A panic is a brief gradual fade out leading into a hard stop. A double panic will trigger an immediate hard stop.
     */
    async workspaceIdPanic(requestParameters: WorkspaceIdPanicRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPanicResponse> {
        const response = await this.workspaceIdPanicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/panicInTime {number} Panic over the specified time, rather than over the panic time defined in the workspace.
     */
    async workspaceIdPanicInTimeRaw(requestParameters: WorkspaceIdPanicInTimeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPanicInTimeResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPanicInTime.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/panicInTime`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdPanicInTimeRequestToJSON(requestParameters.workspaceIdPanicInTimeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPanicInTimeResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/panicInTime {number} Panic over the specified time, rather than over the panic time defined in the workspace.
     */
    async workspaceIdPanicInTime(requestParameters: WorkspaceIdPanicInTimeOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPanicInTimeResponse> {
        const response = await this.workspaceIdPanicInTimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/pause Pause all currently running cues in the workspace.
     */
    async workspaceIdPauseRaw(requestParameters: WorkspaceIdPauseRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPauseResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPause.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/pause`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPauseResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/pause Pause all currently running cues in the workspace.
     */
    async workspaceIdPause(requestParameters: WorkspaceIdPauseRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPauseResponse> {
        const response = await this.workspaceIdPauseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/{cue_number} /workspace/{id}/playheadId/{cue_id} /workspace/{id}/playbackPosition/{cue_number} /workspace/{id}/playbackPositionId/{cue_id} Set the playhead (also called the playback position) of the active cue list to the given cue. When using /playheadId or playbackPositionId, sending the value none will unset the playhead.
     */
    async workspaceIdPlaybackPositionCueNumberRaw(requestParameters: WorkspaceIdPlaybackPositionCueNumberRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlaybackPositionCueNumberResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlaybackPositionCueNumber.');
        }

        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling workspaceIdPlaybackPositionCueNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playbackPosition/{cue_number}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlaybackPositionCueNumberResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/{cue_number} /workspace/{id}/playheadId/{cue_id} /workspace/{id}/playbackPosition/{cue_number} /workspace/{id}/playbackPositionId/{cue_id} Set the playhead (also called the playback position) of the active cue list to the given cue. When using /playheadId or playbackPositionId, sending the value none will unset the playhead.
     */
    async workspaceIdPlaybackPositionCueNumber(requestParameters: WorkspaceIdPlaybackPositionCueNumberRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlaybackPositionCueNumberResponse> {
        const response = await this.workspaceIdPlaybackPositionCueNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/{cue_number} /workspace/{id}/playheadId/{cue_id} /workspace/{id}/playbackPosition/{cue_number} /workspace/{id}/playbackPositionId/{cue_id} Set the playhead (also called the playback position) of the active cue list to the given cue. When using /playheadId or playbackPositionId, sending the value none will unset the playhead.
     */
    async workspaceIdPlaybackPositionIdCueIdRaw(requestParameters: WorkspaceIdPlaybackPositionIdCueIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlaybackPositionIdCueIdResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlaybackPositionIdCueId.');
        }

        if (requestParameters.cueId === null || requestParameters.cueId === undefined) {
            throw new runtime.RequiredError('cueId','Required parameter requestParameters.cueId was null or undefined when calling workspaceIdPlaybackPositionIdCueId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playbackPositionId/{cue_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_id"}}`, encodeURIComponent(String(requestParameters.cueId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlaybackPositionIdCueIdResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/{cue_number} /workspace/{id}/playheadId/{cue_id} /workspace/{id}/playbackPosition/{cue_number} /workspace/{id}/playbackPositionId/{cue_id} Set the playhead (also called the playback position) of the active cue list to the given cue. When using /playheadId or playbackPositionId, sending the value none will unset the playhead.
     */
    async workspaceIdPlaybackPositionIdCueId(requestParameters: WorkspaceIdPlaybackPositionIdCueIdRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlaybackPositionIdCueIdResponse> {
        const response = await this.workspaceIdPlaybackPositionIdCueIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/next /workspace/{id}/playbackPosition/next Move the playhead (also called the playback position) of the active cue list to the next cue.
     */
    async workspaceIdPlaybackPositionNextRaw(requestParameters: WorkspaceIdPlaybackPositionNextRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlaybackPositionNextResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlaybackPositionNext.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playbackPosition/next`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlaybackPositionNextResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/next /workspace/{id}/playbackPosition/next Move the playhead (also called the playback position) of the active cue list to the next cue.
     */
    async workspaceIdPlaybackPositionNext(requestParameters: WorkspaceIdPlaybackPositionNextRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlaybackPositionNextResponse> {
        const response = await this.workspaceIdPlaybackPositionNextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/nextSequence /workspace/{id}/playbackPosition/nextSequence Move the playhead (also called the playback position) of the active cue list to the next cue sequence.
     */
    async workspaceIdPlaybackPositionNextSequenceRaw(requestParameters: WorkspaceIdPlaybackPositionNextSequenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlaybackPositionNextSequenceResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlaybackPositionNextSequence.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playbackPosition/nextSequence`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlaybackPositionNextSequenceResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/nextSequence /workspace/{id}/playbackPosition/nextSequence Move the playhead (also called the playback position) of the active cue list to the next cue sequence.
     */
    async workspaceIdPlaybackPositionNextSequence(requestParameters: WorkspaceIdPlaybackPositionNextSequenceRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlaybackPositionNextSequenceResponse> {
        const response = await this.workspaceIdPlaybackPositionNextSequenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/previous /workspace/{id}/playbackPosition/previous Move the playhead (also called the playback position) of the active cue list to the previous cue.
     */
    async workspaceIdPlaybackPositionPreviousRaw(requestParameters: WorkspaceIdPlaybackPositionPreviousRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlaybackPositionPreviousResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlaybackPositionPrevious.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playbackPosition/previous`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlaybackPositionPreviousResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/previous /workspace/{id}/playbackPosition/previous Move the playhead (also called the playback position) of the active cue list to the previous cue.
     */
    async workspaceIdPlaybackPositionPrevious(requestParameters: WorkspaceIdPlaybackPositionPreviousRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlaybackPositionPreviousResponse> {
        const response = await this.workspaceIdPlaybackPositionPreviousRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/previousSequence /workspace/{id}/playbackPosition/previousSequence Move the playhead (also called the playback position) of the active cue list to the previous cue sequence.
     */
    async workspaceIdPlaybackPositionPreviousSequenceRaw(requestParameters: WorkspaceIdPlaybackPositionPreviousSequenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlaybackPositionPreviousSequenceResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlaybackPositionPreviousSequence.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playbackPosition/previousSequence`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlaybackPositionPreviousSequenceResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/previousSequence /workspace/{id}/playbackPosition/previousSequence Move the playhead (also called the playback position) of the active cue list to the previous cue sequence.
     */
    async workspaceIdPlaybackPositionPreviousSequence(requestParameters: WorkspaceIdPlaybackPositionPreviousSequenceRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlaybackPositionPreviousSequenceResponse> {
        const response = await this.workspaceIdPlaybackPositionPreviousSequenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/{cue_number} /workspace/{id}/playheadId/{cue_id} /workspace/{id}/playbackPosition/{cue_number} /workspace/{id}/playbackPositionId/{cue_id} Set the playhead (also called the playback position) of the active cue list to the given cue. When using /playheadId or playbackPositionId, sending the value none will unset the playhead.
     */
    async workspaceIdPlayheadCueNumberRaw(requestParameters: WorkspaceIdPlayheadCueNumberRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlayheadCueNumberResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlayheadCueNumber.');
        }

        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling workspaceIdPlayheadCueNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playhead/{cue_number}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlayheadCueNumberResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/{cue_number} /workspace/{id}/playheadId/{cue_id} /workspace/{id}/playbackPosition/{cue_number} /workspace/{id}/playbackPositionId/{cue_id} Set the playhead (also called the playback position) of the active cue list to the given cue. When using /playheadId or playbackPositionId, sending the value none will unset the playhead.
     */
    async workspaceIdPlayheadCueNumber(requestParameters: WorkspaceIdPlayheadCueNumberRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlayheadCueNumberResponse> {
        const response = await this.workspaceIdPlayheadCueNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/{cue_number} /workspace/{id}/playheadId/{cue_id} /workspace/{id}/playbackPosition/{cue_number} /workspace/{id}/playbackPositionId/{cue_id} Set the playhead (also called the playback position) of the active cue list to the given cue. When using /playheadId or playbackPositionId, sending the value none will unset the playhead.
     */
    async workspaceIdPlayheadIdCueIdRaw(requestParameters: WorkspaceIdPlayheadIdCueIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlayheadIdCueIdResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlayheadIdCueId.');
        }

        if (requestParameters.cueId === null || requestParameters.cueId === undefined) {
            throw new runtime.RequiredError('cueId','Required parameter requestParameters.cueId was null or undefined when calling workspaceIdPlayheadIdCueId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playheadId/{cue_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_id"}}`, encodeURIComponent(String(requestParameters.cueId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlayheadIdCueIdResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/{cue_number} /workspace/{id}/playheadId/{cue_id} /workspace/{id}/playbackPosition/{cue_number} /workspace/{id}/playbackPositionId/{cue_id} Set the playhead (also called the playback position) of the active cue list to the given cue. When using /playheadId or playbackPositionId, sending the value none will unset the playhead.
     */
    async workspaceIdPlayheadIdCueId(requestParameters: WorkspaceIdPlayheadIdCueIdRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlayheadIdCueIdResponse> {
        const response = await this.workspaceIdPlayheadIdCueIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/next /workspace/{id}/playbackPosition/next Move the playhead (also called the playback position) of the active cue list to the next cue.
     */
    async workspaceIdPlayheadNextRaw(requestParameters: WorkspaceIdPlayheadNextRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlayheadNextResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlayheadNext.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playhead/next`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlayheadNextResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/next /workspace/{id}/playbackPosition/next Move the playhead (also called the playback position) of the active cue list to the next cue.
     */
    async workspaceIdPlayheadNext(requestParameters: WorkspaceIdPlayheadNextRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlayheadNextResponse> {
        const response = await this.workspaceIdPlayheadNextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/nextSequence /workspace/{id}/playbackPosition/nextSequence Move the playhead (also called the playback position) of the active cue list to the next cue sequence.
     */
    async workspaceIdPlayheadNextSequenceRaw(requestParameters: WorkspaceIdPlayheadNextSequenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlayheadNextSequenceResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlayheadNextSequence.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playhead/nextSequence`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlayheadNextSequenceResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/nextSequence /workspace/{id}/playbackPosition/nextSequence Move the playhead (also called the playback position) of the active cue list to the next cue sequence.
     */
    async workspaceIdPlayheadNextSequence(requestParameters: WorkspaceIdPlayheadNextSequenceRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlayheadNextSequenceResponse> {
        const response = await this.workspaceIdPlayheadNextSequenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/previous /workspace/{id}/playbackPosition/previous Move the playhead (also called the playback position) of the active cue list to the previous cue.
     */
    async workspaceIdPlayheadPreviousRaw(requestParameters: WorkspaceIdPlayheadPreviousRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlayheadPreviousResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlayheadPrevious.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playhead/previous`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlayheadPreviousResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/previous /workspace/{id}/playbackPosition/previous Move the playhead (also called the playback position) of the active cue list to the previous cue.
     */
    async workspaceIdPlayheadPrevious(requestParameters: WorkspaceIdPlayheadPreviousRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlayheadPreviousResponse> {
        const response = await this.workspaceIdPlayheadPreviousRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/playhead/previousSequence /workspace/{id}/playbackPosition/previousSequence Move the playhead (also called the playback position) of the active cue list to the previous cue sequence.
     */
    async workspaceIdPlayheadPreviousSequenceRaw(requestParameters: WorkspaceIdPlayheadPreviousSequenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdPlayheadPreviousSequenceResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPlayheadPreviousSequence.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/playhead/previousSequence`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdPlayheadPreviousSequenceResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/playhead/previousSequence /workspace/{id}/playbackPosition/previousSequence Move the playhead (also called the playback position) of the active cue list to the previous cue sequence.
     */
    async workspaceIdPlayheadPreviousSequence(requestParameters: WorkspaceIdPlayheadPreviousSequenceRequest, initOverrides?: RequestInit): Promise<WorkspaceIdPlayheadPreviousSequenceResponse> {
        const response = await this.workspaceIdPlayheadPreviousSequenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/undo /workspace/{id}/redo Undo or redo the most recent change of the workspace.
     */
    async workspaceIdRedoRaw(requestParameters: WorkspaceIdRedoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdRedoResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdRedo.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/redo`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdRedoResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/undo /workspace/{id}/redo Undo or redo the most recent change of the workspace.
     */
    async workspaceIdRedo(requestParameters: WorkspaceIdRedoRequest, initOverrides?: RequestInit): Promise<WorkspaceIdRedoResponse> {
        const response = await this.workspaceIdRedoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/renumber {startNumber} {incrementNumber} Renumber the selected cues, starting at startNumber and incrementing by incrementNumber.
     */
    async workspaceIdRenumberRaw(requestParameters: WorkspaceIdRenumberOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdRenumberResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdRenumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/renumber`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdRenumberRequestToJSON(requestParameters.workspaceIdRenumberRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdRenumberResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/renumber {startNumber} {incrementNumber} Renumber the selected cues, starting at startNumber and incrementing by incrementNumber.
     */
    async workspaceIdRenumber(requestParameters: WorkspaceIdRenumberOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdRenumberResponse> {
        const response = await this.workspaceIdRenumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/reset Reset the workspace. Resetting stops all cues, returns the playhead to the top of the current cue list, and restores any temporary changes made to cues (such as retargeting via a Target cue or adjustments using a live OSC method.)
     */
    async workspaceIdResetRaw(requestParameters: WorkspaceIdResetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdResetResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdReset.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/reset`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdResetResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/reset Reset the workspace. Resetting stops all cues, returns the playhead to the top of the current cue list, and restores any temporary changes made to cues (such as retargeting via a Target cue or adjustments using a live OSC method.)
     */
    async workspaceIdReset(requestParameters: WorkspaceIdResetRequest, initOverrides?: RequestInit): Promise<WorkspaceIdResetResponse> {
        const response = await this.workspaceIdResetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/resume Un-pause all paused cues in the workspace.
     */
    async workspaceIdResumeRaw(requestParameters: WorkspaceIdResumeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdResumeResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdResume.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/resume`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdResumeResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/resume Un-pause all paused cues in the workspace.
     */
    async workspaceIdResume(requestParameters: WorkspaceIdResumeRequest, initOverrides?: RequestInit): Promise<WorkspaceIdResumeResponse> {
        const response = await this.workspaceIdResumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async workspaceIdRunningCuesRaw(requestParameters: WorkspaceIdRunningCuesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdRunningCuesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdRunningCues.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/runningCues`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdRunningCuesResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async workspaceIdRunningCues(requestParameters: WorkspaceIdRunningCuesRequest, initOverrides?: RequestInit): Promise<WorkspaceIdRunningCuesResponse> {
        const response = await this.workspaceIdRunningCuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async workspaceIdRunningOrPausedCuesRaw(requestParameters: WorkspaceIdRunningOrPausedCuesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdRunningOrPausedCuesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdRunningOrPausedCues.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/runningOrPausedCues`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdRunningOrPausedCuesResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async workspaceIdRunningOrPausedCues(requestParameters: WorkspaceIdRunningOrPausedCuesRequest, initOverrides?: RequestInit): Promise<WorkspaceIdRunningOrPausedCuesResponse> {
        const response = await this.workspaceIdRunningOrPausedCuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/save Tell the given workspace to save itself to disk.
     */
    async workspaceIdSaveRaw(requestParameters: WorkspaceIdSaveRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdSaveResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdSave.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/save`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdSaveResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/save Tell the given workspace to save itself to disk.
     */
    async workspaceIdSave(requestParameters: WorkspaceIdSaveRequest, initOverrides?: RequestInit): Promise<WorkspaceIdSaveResponse> {
        const response = await this.workspaceIdSaveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/select/{cue_number} /workspace/{id}/select_id/{id} Select the specified cue(s).
     */
    async workspaceIdSelectCueNumberRaw(requestParameters: WorkspaceIdSelectCueNumberRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdSelectCueNumberResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdSelectCueNumber.');
        }

        if (requestParameters.cueNumber === null || requestParameters.cueNumber === undefined) {
            throw new runtime.RequiredError('cueNumber','Required parameter requestParameters.cueNumber was null or undefined when calling workspaceIdSelectCueNumber.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/select/{cue_number}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"cue_number"}}`, encodeURIComponent(String(requestParameters.cueNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdSelectCueNumberResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/select/{cue_number} /workspace/{id}/select_id/{id} Select the specified cue(s).
     */
    async workspaceIdSelectCueNumber(requestParameters: WorkspaceIdSelectCueNumberRequest, initOverrides?: RequestInit): Promise<WorkspaceIdSelectCueNumberResponse> {
        const response = await this.workspaceIdSelectCueNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/select/{cue_number} /workspace/{id}/select_id/{id} Select the specified cue(s).
     */
    async workspaceIdSelectIdSelectIdRaw(requestParameters: WorkspaceIdSelectIdSelectIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdSelectIdSelectIdResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdSelectIdSelectId.');
        }

        if (requestParameters.selectId === null || requestParameters.selectId === undefined) {
            throw new runtime.RequiredError('selectId','Required parameter requestParameters.selectId was null or undefined when calling workspaceIdSelectIdSelectId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/select_id/{selectId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"selectId"}}`, encodeURIComponent(String(requestParameters.selectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdSelectIdSelectIdResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/select/{cue_number} /workspace/{id}/select_id/{id} Select the specified cue(s).
     */
    async workspaceIdSelectIdSelectId(requestParameters: WorkspaceIdSelectIdSelectIdRequest, initOverrides?: RequestInit): Promise<WorkspaceIdSelectIdSelectIdResponse> {
        const response = await this.workspaceIdSelectIdSelectIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/select/next Move the selection down one cue.
     */
    async workspaceIdSelectNextRaw(requestParameters: WorkspaceIdSelectNextRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdSelectNextResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdSelectNext.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/select/next`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdSelectNextResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/select/next Move the selection down one cue.
     */
    async workspaceIdSelectNext(requestParameters: WorkspaceIdSelectNextRequest, initOverrides?: RequestInit): Promise<WorkspaceIdSelectNextResponse> {
        const response = await this.workspaceIdSelectNextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/select/previous Move the selection up one cue.
     */
    async workspaceIdSelectPreviousRaw(requestParameters: WorkspaceIdSelectPreviousRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdSelectPreviousResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdSelectPrevious.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/select/previous`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdSelectPreviousResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/select/previous Move the selection up one cue.
     */
    async workspaceIdSelectPrevious(requestParameters: WorkspaceIdSelectPreviousRequest, initOverrides?: RequestInit): Promise<WorkspaceIdSelectPreviousResponse> {
        const response = await this.workspaceIdSelectPreviousRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async workspaceIdSelectedCuesRaw(requestParameters: WorkspaceIdSelectedCuesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdSelectedCuesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdSelectedCues.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/selectedCues`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdSelectedCuesResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/cueLists /workspace/{id}/selectedCues /workspace/{id}/runningCues /workspace/{id}/runningOrPausedCues All return an array of cue dictionaries: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number     } ] If any of the included cues are Group cues, the dictionary will include an array of cue dictionaries for all children in the group: [     {         \"uniqueID\": string,         \"number\": string         \"name\": string         \"listName\": string         \"type\": string         \"colorName\": string         \"flagged\": number         \"armed\": number         \"cues\": [ { }, { }, { } ]     } ] colorName may be none, red, orange, green, blue, or purple. Note: Methods that reply with an array of cue dictionaries may generate large OSC messages. These messages can easily grow larger than the maximum size supported by UDP datagrams. If you need to access these methods you should communicate to QLab over a TCP connection rather than a UDP connection. Starting with QLab 4.4.3, versions of these commands are available which return less data: /cueLists/shallow /selectedCues/shallow /runningCues/shallow /runningOrPausedCues/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues. /cueLists/uniqueIDs /selectedCues/uniqueIDs /runningCues/uniqueIDs /runningOrPausedCues/uniqueIDs These methods return only the cue IDs of the cues in question, and not all the other information about them. Cue IDs of children of Group cues is included. /cueLists/uniqueIDs/shallow /selectedCues/uniqueIDs/shallow /runningCues/uniqueIDs/shallow /runningOrPausedCues/uniqueIDs/shallow These methods are identical to the similar methods above, except they do not include any data for the children of Group cues.
     */
    async workspaceIdSelectedCues(requestParameters: WorkspaceIdSelectedCuesRequest, initOverrides?: RequestInit): Promise<WorkspaceIdSelectedCuesResponse> {
        const response = await this.workspaceIdSelectedCuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/selectionIsPlayhead {number} Number is interpreted as a boolean, and sets whether the selection is locked to the playhead. If no argument is provided, return whether the selection is currently locked to the playhead.
     */
    async workspaceIdSelectionIsPlayheadRaw(requestParameters: WorkspaceIdSelectionIsPlayheadOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdSelectionIsPlayheadResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdSelectionIsPlayhead.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/selectionIsPlayhead`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdSelectionIsPlayheadRequestToJSON(requestParameters.workspaceIdSelectionIsPlayheadRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdSelectionIsPlayheadResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/selectionIsPlayhead {number} Number is interpreted as a boolean, and sets whether the selection is locked to the playhead. If no argument is provided, return whether the selection is currently locked to the playhead.
     */
    async workspaceIdSelectionIsPlayhead(requestParameters: WorkspaceIdSelectionIsPlayheadOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdSelectionIsPlayheadResponse> {
        const response = await this.workspaceIdSelectionIsPlayheadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/showMode {number} Number is interpreted as a boolean, and sets whether the workspace is in show mode. If no argument is provided, return whether the workspace is currently in show mode.
     */
    async workspaceIdShowModeRaw(requestParameters: WorkspaceIdShowModeOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdShowModeResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdShowMode.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/showMode`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdShowModeRequestToJSON(requestParameters.workspaceIdShowModeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdShowModeResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/showMode {number} Number is interpreted as a boolean, and sets whether the workspace is in show mode. If no argument is provided, return whether the workspace is currently in show mode.
     */
    async workspaceIdShowMode(requestParameters: WorkspaceIdShowModeOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdShowModeResponse> {
        const response = await this.workspaceIdShowModeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/stop Stop playback but allow effects to continue rendering. e.g., playback stops, but reverbs decay naturally.
     */
    async workspaceIdStopRaw(requestParameters: WorkspaceIdStopRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdStopResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdStop.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/stop`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdStopResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/stop Stop playback but allow effects to continue rendering. e.g., playback stops, but reverbs decay naturally.
     */
    async workspaceIdStop(requestParameters: WorkspaceIdStopRequest, initOverrides?: RequestInit): Promise<WorkspaceIdStopResponse> {
        const response = await this.workspaceIdStopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/thump A simple heartbeat method for this workspace. Returns the data thump. (Thump-thump, thump-thump.)
     */
    async workspaceIdThumpRaw(requestParameters: WorkspaceIdThumpRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdThumpResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdThump.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/thump`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdThumpResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/thump A simple heartbeat method for this workspace. Returns the data thump. (Thump-thump, thump-thump.)
     */
    async workspaceIdThump(requestParameters: WorkspaceIdThumpRequest, initOverrides?: RequestInit): Promise<WorkspaceIdThumpResponse> {
        const response = await this.workspaceIdThumpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/toggleEditShowMode Switch between show mode and edit mode.
     */
    async workspaceIdToggleEditShowModeRaw(requestParameters: WorkspaceIdToggleEditShowModeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdToggleEditShowModeResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdToggleEditShowMode.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/toggleEditShowMode`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdToggleEditShowModeResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/toggleEditShowMode Switch between show mode and edit mode.
     */
    async workspaceIdToggleEditShowMode(requestParameters: WorkspaceIdToggleEditShowModeRequest, initOverrides?: RequestInit): Promise<WorkspaceIdToggleEditShowModeResponse> {
        const response = await this.workspaceIdToggleEditShowModeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/toggleFullScreen Turn full screen mode on or off.
     */
    async workspaceIdToggleFullScreenRaw(requestParameters: WorkspaceIdToggleFullScreenRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdToggleFullScreenResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdToggleFullScreen.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/toggleFullScreen`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdToggleFullScreenResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/toggleFullScreen Turn full screen mode on or off.
     */
    async workspaceIdToggleFullScreen(requestParameters: WorkspaceIdToggleFullScreenRequest, initOverrides?: RequestInit): Promise<WorkspaceIdToggleFullScreenResponse> {
        const response = await this.workspaceIdToggleFullScreenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/toggleLightDashboard If the Light Dashboard is closed, open it and place focus in the command line. If the Light Dashboard is open, but focus is not in the command line, place focus in the command line. If the Light Dashboard is open and focus is in the command line, move focus to the main workspace window.
     */
    async workspaceIdToggleLightDashboardRaw(requestParameters: WorkspaceIdToggleLightDashboardRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdToggleLightDashboardResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdToggleLightDashboard.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/toggleLightDashboard`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdToggleLightDashboardResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/toggleLightDashboard If the Light Dashboard is closed, open it and place focus in the command line. If the Light Dashboard is open, but focus is not in the command line, place focus in the command line. If the Light Dashboard is open and focus is in the command line, move focus to the main workspace window.
     */
    async workspaceIdToggleLightDashboard(requestParameters: WorkspaceIdToggleLightDashboardRequest, initOverrides?: RequestInit): Promise<WorkspaceIdToggleLightDashboardResponse> {
        const response = await this.workspaceIdToggleLightDashboardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/toggleSelectionIsPlayhead Lock or unlock the selection to the playhead.
     */
    async workspaceIdToggleSelectionIsPlayheadRaw(requestParameters: WorkspaceIdToggleSelectionIsPlayheadRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdToggleSelectionIsPlayheadResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdToggleSelectionIsPlayhead.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/toggleSelectionIsPlayhead`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdToggleSelectionIsPlayheadResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/toggleSelectionIsPlayhead Lock or unlock the selection to the playhead.
     */
    async workspaceIdToggleSelectionIsPlayhead(requestParameters: WorkspaceIdToggleSelectionIsPlayheadRequest, initOverrides?: RequestInit): Promise<WorkspaceIdToggleSelectionIsPlayheadResponse> {
        const response = await this.workspaceIdToggleSelectionIsPlayheadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/undo /workspace/{id}/redo Undo or redo the most recent change of the workspace.
     */
    async workspaceIdUndoRaw(requestParameters: WorkspaceIdUndoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdUndoResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdUndo.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}/undo`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdUndoResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/undo /workspace/{id}/redo Undo or redo the most recent change of the workspace.
     */
    async workspaceIdUndo(requestParameters: WorkspaceIdUndoRequest, initOverrides?: RequestInit): Promise<WorkspaceIdUndoResponse> {
        const response = await this.workspaceIdUndoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspace/{id}/updates {number} number is interpreted as a boolean. If yes, your client wants push notifications of cue changes. If no, your client no longer wants push notifications of cue changes.
     */
    async workspaceIdUpdatesRaw(requestParameters: WorkspaceIdUpdatesOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspaceIdUpdatesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdUpdates.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/workspace/{id}/updates`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceIdUpdatesRequestToJSON(requestParameters.workspaceIdUpdatesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceIdUpdatesResponseFromJSON(jsonValue));
    }

    /**
     * /workspace/{id}/updates {number} number is interpreted as a boolean. If yes, your client wants push notifications of cue changes. If no, your client no longer wants push notifications of cue changes.
     */
    async workspaceIdUpdates(requestParameters: WorkspaceIdUpdatesOperationRequest, initOverrides?: RequestInit): Promise<WorkspaceIdUpdatesResponse> {
        const response = await this.workspaceIdUpdatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * /workspaces Return an array of workspace dictionaries: [     {         \"uniqueID\": string,         \"displayName\": string,         \"hasPasscode\": number,         \"version\": string     } ] Workspace methods Workspace OSC methods use the form /workspace/{id}/command, where {id} may be either the display name of the workspace, such as hamlet.qlab4, or the unique ID of the workspace, which can be found in the Info tab of the Status Window. Note, however, that addressing by display name will work only if the display name is composed of characters allowed in OSC method names. This does NOT include spaces, unicode, diacritical, or other special characters. Addressing a workspace by its unique ID looks like this: /workspace/1B11984A-3EBC-4A9C-A004-B9E3AA32DA6B/go Addressing a workspace by its display name looks like this: /workspace/hamlet.qlab4/go If you send a workspace method without the /workspace/{id} portion of the address, then the method will be sent to the current workspace, which is the front-most, active document. So, if your hamlet.qlab4 workspace is the front-most, active document, and you send QLab the OSC command /go, then hamlet.qlab4 will GO. Workspaces respond to the following commands:
     */
    async workspacesRaw(requestParameters: WorkspacesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<WorkspacesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expectResponse !== undefined) {
            queryParameters['expect-response'] = requestParameters.expectResponse;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspaces`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspacesResponseFromJSON(jsonValue));
    }

    /**
     * /workspaces Return an array of workspace dictionaries: [     {         \"uniqueID\": string,         \"displayName\": string,         \"hasPasscode\": number,         \"version\": string     } ] Workspace methods Workspace OSC methods use the form /workspace/{id}/command, where {id} may be either the display name of the workspace, such as hamlet.qlab4, or the unique ID of the workspace, which can be found in the Info tab of the Status Window. Note, however, that addressing by display name will work only if the display name is composed of characters allowed in OSC method names. This does NOT include spaces, unicode, diacritical, or other special characters. Addressing a workspace by its unique ID looks like this: /workspace/1B11984A-3EBC-4A9C-A004-B9E3AA32DA6B/go Addressing a workspace by its display name looks like this: /workspace/hamlet.qlab4/go If you send a workspace method without the /workspace/{id} portion of the address, then the method will be sent to the current workspace, which is the front-most, active document. So, if your hamlet.qlab4 workspace is the front-most, active document, and you send QLab the OSC command /go, then hamlet.qlab4 will GO. Workspaces respond to the following commands:
     */
    async workspaces(requestParameters: WorkspacesRequest = {}, initOverrides?: RequestInit): Promise<WorkspacesResponse> {
        const response = await this.workspacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
